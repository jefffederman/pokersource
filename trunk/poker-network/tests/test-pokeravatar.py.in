#!@PYTHON@
# -*- mode: python -*-
#
# Copyright (C) 2007 Loic Dachary <loic@dachary.org>
# Copyright (C) 2008 Bradley M. Kuhn <bkuhn@ebb.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.
#

import sys, os
sys.path.insert(0, "@srcdir@/..")
sys.path.insert(0, "..")

import libxml2

import socket
import time
from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor, defer, error, base
from twisted.python import failure, runtime

from tests.testmessages import silence_all_messages
os.environ['VERBOSE_T'] = '0'
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from pokerengine import pokertournament
#
# Must be done before importing pokerclient or pokerclient
# will have to be patched too.
#
from tests import testclock
from pokernetwork import dispatch
twisted.internet.base.DelayedCall.debug = True

from pokerui import pokerinterface
from pokernetwork import pokerservice
from pokernetwork import pokernetworkconfig
from pokernetwork import pokerclient
from pokernetwork import currencyclient
currencyclient.CurrencyClient = currencyclient.FakeCurrencyClient
from pokernetwork.pokerclientpackets import *

class ConstantDeckShuffler:
    def shuffle(self, what):
        what[:] = [40, 13, 32, 9, 19, 31, 15, 14, 50, 34, 20, 6, 43, 44, 28, 29, 48, 3, 21, 45, 23, 37, 35, 11, 5, 22, 24, 30, 27, 39, 46, 33, 0, 8, 1, 42, 36, 16, 49, 2, 10, 26, 4, 18, 7, 41, 47, 17]

from pokerengine import pokergame
pokergame.shuffler = ConstantDeckShuffler()

class ConstantPlayerShuffler:
    def shuffle(self, what):
        what.sort()

pokertournament.shuffler = ConstantPlayerShuffler()

settings_xml_server = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="3" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="20" round="0" position="0" showdown="0" autodeal_max="1" finish="0" messages="60" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="2-4-limit" seats="10" player_timeout="60" currency_serial="0" />
  <table name="Table3" variant="holdem" betting_structure="test18pokerclient" seats="10" player_timeout="600" muck_timeout="600" currency_serial="1" forced_dealer_seat="0" />

  <listen tcp="19480" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes"/>
  <database name="pokernetworktest" host="@MYSQL_TEST_DBHOST@" user="pokernetworktest" password="pokernetwork"
            root_user="@MYSQL_TEST_DBROOT@" root_password="@MYSQL_TEST_DBROOT_PASSWORD@" schema="@srcdir@/../../database/schema.sql" command="@MYSQL@" />
  <path>.. ../@srcdir@ @POKER_ENGINE_PKGSYSCONFDIR@ @POKER_NETWORK_PKGSYSCONFDIR@</path>
  <users temporary="BOT"/>
</server>
"""

settings_xml_client = """<?xml version="1.0" encoding="ISO-8859-1"?>
<settings display2d="yes" display3d="no" ping="15000" verbose="3" delays="true" tcptimeout="2000" upgrades="no">
   <delays blind_ante_position="0" position="0" begin_round="0" end_round="0" end_round_last="0" showdown="0" lag="60"/> 
  <screen fullscreen="no" width="1024" height="768"/>
  <name>user1</name>
  <passwd>password1</passwd>
  <remember>yes</remember>
  <muck>yes</muck>
  <auto_post>no</auto_post>
  <chat max_chars="40" line_length="20"/>
  <web browser="/usr/bin/firefox">http://localhost/poker-web/</web>
  <sound>yes</sound>
  <tournaments currency_serial="1" type="sit_n_go" sort="name"/>
  <lobby currency_serial="1" type="holdem" sort="name"/>
  <shadow>yes</shadow>
  <vprogram>yes</vprogram>
  
  <user path="~/.poker2d"/>
  <path>.. ../@srcdir@ @POKER_ENGINE_PKGSYSCONFDIR@ @POKER_NETWORK_PKGSYSCONFDIR@</path> 
  <rsync path="/usr/bin/rsync" dir="." source="rsync.pok3d.com::pok3d/linux-gnu" target="/tmp/installed" upgrades="share/poker-network/upgrades"/>
  <data path="data" sounds="data/sounds"/>
  <handlist start="0" count="10"/>
</settings>
"""

TABLE1 = 100
TABLE2 = 101
TABLE3 = 102

class PokerAvatarTestCase(unittest.TestCase):
    def destroyDb(self, arg = None):
        if len("@MYSQL_TEST_DBROOT_PASSWORD@") > 0:
            os.system("@MYSQL@ -u @MYSQL_TEST_DBROOT@ --password='@MYSQL_TEST_DBROOT_PASSWORD@' -h '@MYSQL_TEST_DBHOST@' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("@MYSQL@ -u @MYSQL_TEST_DBROOT@ -h '@MYSQL_TEST_DBHOST@' -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    def setUpServer(self):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml_server, len(settings_xml_server))
        settings.header = settings.doc.xpathNewContext()
        #
        # Setup server
        #
        self.service = pokerservice.PokerService(settings)
        self.service.verbose = 6
        self.service.startService()
        factory = pokerservice.IPokerFactory(self.service)
        self.p = reactor.listenTCP(0, factory,
                                   interface="127.0.0.1")
        self.port = self.p.getHost().port

    def setUpClient(self, index):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml_client, len(settings_xml_client))
        settings.header = settings.doc.xpathNewContext()
        self.client_factory[index] = pokerclient.PokerClientFactory(settings = settings)
        def setUpProtocol(client):
            client._poll_frequency = 0.1
            return client
        d = self.client_factory[index].established_deferred
        d.addCallback(setUpProtocol)
        return d

    # ------------------------------------------------------
    def setUp(self):
        testclock._seconds_reset()        
        self.destroyDb()
        self.setUpServer()
        self.client_factory = [None, None]
        def connectClient1(client): 
            reactor.connectTCP('127.0.0.1', self.port, self.client_factory[1])
            return client

        d = self.setUpClient(0)
        d.addCallback(connectClient1)
        self.setUpClient(1)
        reactor.connectTCP('127.0.0.1', self.port, self.client_factory[0])
    # -------------------------------------------------------------------------
    def cleanSessions(self, arg):
        #
        # twisted Session code has leftovers : disable the hanging delayed call warnings
        # of trial by nuking all what's left.
        #
        pending = reactor.getDelayedCalls()
        if pending:
            for p in pending:
                if p.active():
#                    print "still pending:" + str(p)
                    p.cancel()
        return arg
    # -------------------------------------------------------------------------
    def tearDown(self):
        d = self.service.stopService()
        d.addCallback(lambda x: self.p.stopListening())
#        d.addCallback(self.destroyDb)
        d.addCallback(self.cleanSessions)
        return d
    # -------------------------------------------------------------------------
    def quit(self, args):
        client = args[0]
        if self.service.verbose > 0:
            print "test-pokerclient: quit client " + str(client.getSerial())
        client.sendPacket(PacketQuit())
        if hasattr(client, "transport"):
            client.transport.loseConnection()
            return client.connection_lost_deferred
        else:
            raise UserWarning, "quit does not have transport %d" % client.getSerial()
    # -------------------------------------------------------------------------
    def ping(self, client):
        client.sendPacket(PacketPing())
        return (client,)
    # -------------------------------------------------------------------------
    def test01_ping(self):
        """ test01_ping """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.ping)
        d.addCallback(self.quit)
        return d
    # -------------------------------------------------------------------------
    def sendExplain(self, client):
        client.sendPacket(PacketPokerExplain(value = PacketPokerExplain.ALL))
        return client.packetDeferred(True, PACKET_ACK)
    # -------------------------------------------------------------------------
    def setupCallbackChain(self, client):
        return ((client, None))
    # -------------------------------------------------------------------------
    def explain(self, (client, packet)):
        avatar = self.service.avatars[0]
        self.assertNotEqual(None, avatar.explain)
        serial = 200
        packet_serial = PacketSerial(serial = serial)
        self.assertTrue(avatar.explain.explain(packet_serial))
        self.assertEqual(packet_serial, avatar.explain.forward_packets[0])
        self.assertEqual(serial, avatar.explain.getSerial())
        return (client,)
    # -------------------------------------------------------------------------
    def test02_explain(self):
        """ test02_explain """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.explain)
        d.addCallback(self.quit)
        return d
    # -------------------------------------------------------------------------
    def login(self, (client, packet), index):
        client.sendPacket(PacketLogin(name = 'user%d' % index, password = 'password1'))
        return client.packetDeferred(True, PACKET_POKER_PLAYER_INFO)
    # ------------------------------------------------------------------------
    def login_again(self, (client, packet)):
        avatar = self.service.avatars[0]
        self.assertNotEqual(None, avatar.explain)
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketLogin(name = 'user0', password = 'password1'))
        answer = avatar._packets_queue[0]
        self.assertEqual(PACKET_ERROR, answer.type)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test03_login_again(self):
        """ test03_login """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.login_again)
        d.addCallback(self.quit)
        return d
    # ------------------------------------------------------------------------
    def test04_createTable(self):
        """Tests receipt of a table creation packet, followed by creation of a
           table once the avatar is logged in."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        def handleTable((client, packet)):
            avatar = self.service.avatars[0]
            avatar.handlePacket(PacketPokerTable(id = 1, seats  = 5,
                    name = "A Testing Cash Table", variant = "holdem",
                    betting_structure = '2-4-limit', player_timeout =  6,
                    currency_serial = 0))
            self.assertEquals(len(avatar.tables), 1)
            for  (kk, vv) in avatar.tables.items():
                self.assertEquals(vv.game.name, "A Testing Cash Table")
                self.assertEquals(vv.game.max_players, 5)
                self.assertEquals(vv.game.variant, 'holdem')
                self.assertEquals(vv.game.betting_structure, '2-4-limit')
            # Set Explain should now generate an error that we're at a table.
            self.assertEquals(avatar.setExplain("This should fail"), False)
            return (client, packet)

        d.addCallback(handleTable)
        return d
    # -------------------------------------------------------------------------
    def test05_testStrInterpolation(self):
        """Tests to make sure the string output of an avatar is accurate"""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        def stringAvatar((client, packet)):
            print str(self.service.avatars[0])
            self.assertEquals(str(self.service.avatars[0]),
                              "PokerAvatar serial = 4, name = user0")
            return (client, packet)
            
        d.addCallback(stringAvatar)
        return d
    # -------------------------------------------------------------------------
    def normalSetRoles(self, (client, packet), id, myRoles, rolesString):
        avatar = self.service.avatars[0]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerSetRole(serial = client.getSerial(), roles = myRoles))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_ROLES:
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.roles, rolesString)
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # -------------------------------------------------------------------------
    def test06_setRoles(self):
        """Tests setting of roles"""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.normalSetRoles, 0, PacketPokerRoles.PLAY, "PLAY")
        d.addCallback(self.login, 0)
        d.addCallback(self.quit)
        return d
    # -------------------------------------------------------------------------
    def test06_5_setRolesIsAnErrorWhenDoneAfterLogin(self):
        """Tests setting of roles after a login has already occurred.  Results are
        undefined in this case."""
        # While I was writing full coverage tests here, Loic and I
        # discovered that bad behavior occurs if you set roles after
        # you've logged in.  It must be done before, as is done in the
        # above test.  Loic documented this in
        # pokernetwork/pokerpackets.py as of r3654 about this issue.  This
        # test here looks for the blow-up that we discovered in the
        # undefined behavhior.  Since we've determined the behavior to be
        # undefined, this test might need to be updated later to test for
        # the undefined behavior we see. ;) Perhaps testing for things
        # that aren't defined with this.
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        def setRoles((client, packet)):
            avatar = self.service.avatars[0]
            avatar.handlePacket(PacketPokerSetRole(serial = client.getSerial(), roles = PacketPokerRoles.PLAY))
            try:
                avatar.logout()
            except KeyError, ke:
                self.assertEquals(ke.args[0], client.getSerial())
            # Reset avatar role values back to blank so future errors of
            # this type do not occur.
            avatar.roles = ""
            return (client, packet)
        d.addCallback(setRoles)
        return d
    # -------------------------------------------------------------------------
    def errorSetRoles(self, (client, packet), id, myRoles, errorCode, errorMessage):
        avatar = self.service.avatars[0]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerSetRole(serial = client.getSerial(), roles = myRoles))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ERROR:
                self.assertEquals(packet.other_type, PACKET_POKER_SET_ROLE)
                self.assertEquals(packet.code, errorCode)
                self.assertEquals(packet.message, errorMessage)
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # -------------------------------------------------------------------------
    def test06_7_setUnknownRole(self):
        """Tests setting of a role that is unknown."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        # This error message will need to be fixed if you add additional valid roles 
        d.addCallback(self.errorSetRoles, 0, "YOU_HAVE_NEVER_HEARD_OF_THIS_ROLE",
                      PacketPokerSetRole.UNKNOWN_ROLE, "role YOU_HAVE_NEVER_HEARD_OF_THIS_ROLE is unknown (roles = ['PLAY', 'EDIT'])")
        d.addCallback(self.login, 0)
        d.addCallback(self.quit)
        return d
    # -------------------------------------------------------------------------
    def test06_8_setRoleAfterAnotherUserHas(self):
        """Tests setting of a role that is unknown."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.normalSetRoles, 0, PacketPokerRoles.PLAY, "PLAY")
        d.addCallback(self.login, 0)
        d2 = self.client_factory[1].established_deferred
        d2.addCallback(self.sendExplain)
        d2.addCallback(self.errorSetRoles, 0, PacketPokerRoles.PLAY,
                       PacketPokerSetRole.NOT_AVAILABLE,
                      "another client already has role %s" % PacketPokerRoles.PLAY)
        d2.addCallback(self.login, 1)
        d2.addCallback(self.quit)
        return defer.DeferredList((d, d2))
    # -------------------------------------------------------------------------
    def test07_getImage(self):
        """Tests player getting its image"""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        def getImage((client, packet)):
            avatar = self.service.avatars[0]
            avatar.queuePackets()
            avatar.handlePacketLogic(PacketPokerGetPlayerImage(
                    serial = client.getSerial()))
            found = False
            for packet in avatar._packets_queue:
                if packet.type == PACKET_POKER_PLAYER_IMAGE:
                    found = True
                    self.assertEquals(packet.serial, client.getSerial())
                    self.assertEquals(packet.image_type, "image/png")
            self.assertEquals(found, True)
            return (client, packet)
        d.addCallback(getImage)
        d.addCallback(self.quit)
        return d
    # -------------------------------------------------------------------------
    def joinTable(self, (client, packet), id, gameId, name, struct):
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTableJoin(serial = client.getSerial(),
                                                      game_id = gameId))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_TABLE:
                found = True
                for  (kk, vv) in avatar.tables.items():
                    self.assertEquals(vv.game.id, table.game.id)
                    self.assertEquals(vv.game.name, name)
                    self.assertEquals(vv.game.max_players, 10)
                    self.assertEquals(vv.game.variant, 'holdem')
                    self.assertEquals(vv.game.betting_structure, struct)
                    self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test08_joinTable(self):
        """Tests table joining."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 101, 'Table2', '2-4-limit')
        d.addCallback(self.quit)
        return d
    # -------------------------------------------------------------------------
    def seatTable(self, (client, packet), id, gameId):
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        seatNumber = id + 1
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerSeat(serial = client.getSerial(),
                                                seat = seatNumber, game_id = gameId))
        found = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_SEATS:
                found += 1
                self.assertEquals(packet.game_id, table.game.id)
                self.assertEquals(packet.seats[seatNumber], client.getSerial())
            if packet.type == PACKET_POKER_PLAYER_ARRIVE:
                found += 1 
                self.assertEquals(packet.game_id, table.game.id)
                self.assertEquals(packet.name, "user%d" % id)
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.seat, seatNumber)
            if packet.type == PACKET_POKER_PLAYER_CHIPS:
                found += 1
                self.assertEquals(packet.game_id, table.game.id)
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.bet, 0)
                self.assertEquals(packet.money, 0)
        self.assertEquals(found, 3)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test09_seatTable(self):
        """Tests table joining table and sitting down."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 101, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 101)
        d.addCallback(self.quit)
        return d
    # ------------------------------------------------------------------------
    def forceExplain(self, (client, packet), id):
        avatar = self.service.avatars[id]
        table = self.service.getTable(101)
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerExplain(
                serial = client.getSerial(), value = PacketPokerExplain.ALL))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ERROR:
                found = True
                self.assertEquals(packet.other_type, PACKET_POKER_EXPLAIN)
                self.assertEquals(packet.code, 0)
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test10_explainFailsOnceAtTable(self):
        """Tests to be sure setting explain fails when you are already
        connected to to table."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 101, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 101)
        d.addCallback(self.forceExplain, 0)
        d.addCallback(self.quit)
        return d
    # ------------------------------------------------------------------------
    def loginWithPasswordTooLong(self, (client, packet), index):
        client.sendPacket(PacketLogin(name = 'user%d' % index, password = 'passwordislongerthan15chars'))
        d = client.packetDeferred(True, PACKET_AUTH_REFUSED)
        def checkbadLoginReturn( (client, packet) ):
            self.assertEquals(packet.type, PACKET_AUTH_REFUSED)
            self.assertEquals(packet.message, "password must be at most 15 characters long")
            self.assertEquals(packet.code, 6)
            self.assertEquals(packet.other_type, PACKET_LOGIN)
            self.assertEquals(client.getSerial(), 0)
        d.addCallback(checkbadLoginReturn)
        return d
    # ------------------------------------------------------------------------
    def test11_loginWithPasswordTooLong(self):
        """Tests to be sure setting explain fails when you are already
        connected to to table."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.loginWithPasswordTooLong, 0)
        return d
    # -------------------------------------------------------------------------
    def buyInTable(self, (client, packet), id, gameId, myAmount):
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        seatNumber = id + 1
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerBuyIn(serial = client.getSerial(),
                                               amount = myAmount, game_id = gameId))
        found = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_PLAYER_CHIPS:
                found += 1
                self.assertEquals(packet.game_id, table.game.id)
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.bet, 0)
                self.assertEquals(packet.money, myAmount)
        self.assertEquals(found, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test12_buyIntoGame(self):
        """Tests to be sure once sat down, the user can buy into the game"""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 101, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 101)
        d.addCallback(self.buyInTable, 0, 101, 1000)
        d.addCallback(self.quit)
        return d
    # ------------------------------------------------------------------------
    def statsQuery(self, (client, packet), id):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerStatsQuery(serial = client.getSerial()))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_STATS:
                found = True
                self.assertEquals(packet.length, 19)
                self.assertEquals(packet.players, 2)
                assert(packet.bytesin > 0)
                assert(packet.bytesout > 0)
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test13_stats(self):
        """Test stats request"""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.statsQuery, 0)
        return d
    # ------------------------------------------------------------------------
    def readyToPlay(self, (client, packet), id, gameId ):
        
#        client.sendPacket(PacketPokerReadyToPlay(serial = client.getSerial(),
#                                                 game_id = gameId))
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerReadyToPlay(serial = client.getSerial(),
                                                        game_id = gameId))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ACK:
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def autoBlindAnte(self, (client, packet), id, gameId ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerAutoBlindAnte(serial= client.getSerial(),
                                                        game_id = gameId))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_AUTO_BLIND_ANTE:
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.game_id, gameId)
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def dealTable(self, (client, packet), gameId):
        table = self.service.getTable(gameId)
        table.beginTurn()
        table.update()
        return (client, packet)
    # ------------------------------------------------------------------------
    def beginHandSetup(self, (client, packet), gameId):
        table = self.service.getTable(gameId)
        avatar0 = self.service.avatars[0]
        avatar1 = self.service.avatars[1]
        avatar0.queuePackets()
        avatar1.queuePackets()
        # Handle the packets that initially arrive.  I learned what to
        # expect from "What to expect while a hand is being played?" in
        # pokerpackets.py
        packetList = []
        packetList.extend(avatar0.resetPacketsQueue())
        packetList.extend(avatar1.resetPacketsQueue())
        playersExpect = [ avatar0.getSerial(), avatar1.getSerial() ]
        playersExpect.sort()
        found = 0
        for packet in packetList:
            if packet.type == PACKET_POKER_IN_GAME:
                found += 1
                self.assertEquals(packet.serial, 0)
                self.assertEquals(packet.game_id, gameId)
                packet.players.sort()
                self.assertEquals(packet.players, playersExpect)
            elif packet.type == PACKET_POKER_DEALER:
                found += 1
                self.assertEquals(packet.dealer, 1)
                self.assertEquals(packet.previous_dealer, -1)
                self.assertEquals(packet.game_id, gameId)
            elif packet.type == PACKET_POKER_START:
                found += 1
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.level, 0)
                self.assertEquals(packet.hand_serial, 1)
                self.assertEquals(packet.serial, 0)
                self.assertEquals(packet.hands_count, 0)
                self.assertEquals(packet.time, 0)
            elif packet.type == PACKET_POKER_POSITION:
                found += 1
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.position, -1)
                self.assertEquals(True, packet.serial == avatar0.getSerial() 
                                        or packet.serial == avatar1.getSerial())
            elif packet.type == PACKET_POKER_CHIPS_POT_RESET:
                found += 1
                self.assertEquals(packet.cookie, "")
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.length, 11)
                self.assertEquals(packet.serial, 0)
            elif packet.type == PACKET_POKER_BLIND_REQUEST:
                found += 1
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.dead, 0)
                self.assertEquals(packet.serial, avatar1.getSerial())
                self.assertEquals(packet.amount, 100)
                self.assertEquals(packet.state, 'small')
            elif packet.type == PACKET_POKER_SELF_IN_POSITION:
                self.assertEquals(packet.serial, avatar1.getSerial())
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.position, -1)
                self.assertEquals(packet.length, 8)
            elif packet.type == PACKET_POKER_BOARD_CARDS:
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(True, packet.serial == avatar0.getSerial() 
                                        or packet.serial == avatar1.getSerial())
                
                self.assertEquals(packet.cards, [])
            # When I was writing this loop, I also saw a number of:
            # POKER_PLAYER_CHIPS and also the POKER_PLAYER_ARRIVE for
            # serial 5, but I thought it was safe to ignore them here.
        self.assertEquals(found, 14)
        avatar0.queuePackets()
        avatar1.queuePackets()
        return (client, packet)
    # ------------------------------------------------------------------------
    def doBlindPost(self, (client, packet), id, gameId):
        # By now, we should have seen as noted above, a request for the
        # blinds for avatar1 for 100 small blind.  Here we send it.
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerBlind(serial= avatar.getSerial(),
                                                   game_id = gameId, dead = 0,
                                                   amount = 100))
        return (client, packet)
    # ------------------------------------------------------------------------
    def startHandAndReceiveCards(self, (client, packet), gameId):
        table = self.service.getTable(gameId)
        avatar = []
        avatar.append(self.service.avatars[0])
        avatar.append(self.service.avatars[1])

        packetList = []
        packetList.append(avatar[0].resetPacketsQueue())
        packetList.append(avatar[1].resetPacketsQueue())
        found = 0

        # First look for all the packets that both of them get and should have.
        p = []
        p.extend(packetList[0])
        p.extend(packetList[1])
        found = 0
        for packet in p:
            if packet.type == PACKET_POKER_BLIND:
                found += 1
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.dead, 0)
                if packet.serial == avatar[1].getSerial():
                    self.assertEquals(packet.amount, 100)
                elif packet.serial == avatar[0].getSerial():
                    self.assertEquals(packet.amount, 200)
                else:
                    self.assertEquals("", "Unknown serial: %d" % packet.serial)
            elif packet.type == PACKET_POKER_CHIPS_PLAYER2BET:
                found += 1
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.cookie, "")
                if (packet.serial == avatar[0].getSerial()):
                        self.assertEquals(packet.chips, [100, 2])
                elif (packet.serial == avatar[1].getSerial()):
                    self.assertEquals(packet.chips, [100, 1])
                else:
                        assert("unknown serial in player2bet packet: %d" 
                               % packet.serial)
            elif packet.type == PACKET_POKER_CHIPS:
                found += 1
                self.assertEquals(packet.game_id, gameId)
                if (packet.serial == avatar[0].getSerial()):
                    self.assertEquals(packet.bet, 200)
                    self.assertEquals(packet.money, 800)
                elif (packet.serial == avatar[1].getSerial()):
                    self.assertEquals(packet.bet, 100)
                    self.assertEquals(packet.money, 900)
                else:
                    self.assertEquals(
                        "unknown serial in player2bet packet: %d" 
                        % packet.serial, "")
            elif packet.type == PACKET_POKER_CHAT:
                found += 1
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.serial, 0)
                if (packet.message not in [ "Dealer: user1 pays 1 blind\n",
                                            "Dealer: user0 pays 2 blind\n",
                                            "Dealer: pre-flop, 2 players\n" ]):
                    self.assertEquals("Unexpected message: %s" %
                                      packet.message, "")
            elif packet.type == PACKET_POKER_STATE:
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.serial, 0)
                self.assertEquals(packet.string, "pre-flop")
            elif packet.type == PACKET_POKER_BEGIN_ROUND:
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.serial, 0)
                self.assertEquals(packet.cookie, "")

        self.assertEquals(found, 14)

        for avid in [0, 1]:
            otherid = avid -1
            if otherid < 0:
                otherid = 1
            for packet in packetList[avid]:
                if packet.type == PACKET_POKER_PLAYER_CARDS:
                    self.assertEquals(packet.game_id, gameId)
                    if (packet.serial == avatar[avid].getSerial()):
                        self.assertEquals(len(packet.cards), 2)
                        for c in packet.cards:
                            self.assertTrue(c <  255)
                            self.assertTrue(c >  0)
                    elif (packet.serial == avatar[otherid].getSerial()):
                        self.assertEquals(packet.cards, [255, 255])
                elif packet.type == PACKET_POKER_BET_LIMIT:
                    self.assertEquals(packet.game_id, gameId)
                    self.assertEquals(packet.serial, 0)
                    self.assertEquals(packet.cookie, "")
                    self.assertEquals(packet.step, 100)
                    if (avid == 0):
                        self.assertEquals(packet.min, 200)
                        self.assertEquals(packet.max, 200)
                        self.assertEquals(packet.allin, 800)
                        self.assertEquals(packet.pot, 300)
                        self.assertEquals(packet.call, 0)
                    else:
                        self.assertEquals(packet.min, 300)
                        self.assertEquals(packet.max, 300)
                        self.assertEquals(packet.allin, 900)
                        self.assertEquals(packet.pot, 500)
                        self.assertEquals(packet.call, 100)
        return (client, packet)
    # ------------------------------------------------------------------------
    def sitTable(self, (client, packet), id, gameId):
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        seatNumber = id + 1
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerSit(serial = client.getSerial(),
                                                game_id = gameId))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_SIT:
                found = True
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.serial, client.getSerial())
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test15_handPlay(self):
        """Test playing an actual hand all the way through"""
        # The sequence of how to get yourself seated in a cash game was
        # taken from the instructions at the top of pokerpackets.py
        # labelled "How to sit at a cash game table ?"
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 101, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 101)
        d.addCallback(self.buyInTable, 0, 101, 1000)
        d.addCallback(self.autoBlindAnte, 0, 101)
        d.addCallback(self.sitTable, 0, 101)
        d.addCallback(self.readyToPlay, 0, 101)
        d2 = self.client_factory[1].established_deferred
        d2.addCallback(self.sendExplain)
        d2.addCallback(self.login, 1)
        d2.addCallback(self.joinTable, 1, 101, 'Table2', '2-4-limit')
        d2.addCallback(self.seatTable, 1, 101)
        d2.addCallback(self.buyInTable, 1, 101, 1000)
        # Note: this avatar does not autopost, and doBlindPost handles it.
        d2.addCallback(self.sitTable, 1, 101)
        d2.addCallback(self.readyToPlay, 1, 101)
        d2.addCallback(self.dealTable, 101)
        d2.addCallback(self.beginHandSetup, 101)
        d2.addCallback(self.doBlindPost, 1, 101)
        d2.addCallback(self.startHandAndReceiveCards, 101)
        return defer.DeferredList((d, d2))
    # -------------------------------------------------------------------------
    def sendExplainTooLate(self, (client, packet)):
        avatar = self.service.avatars[0]
        d = client.packetDeferred(True, PACKET_ERROR)
        def checkError( (client, packet) ):
            self.assertEquals(packet.type, PACKET_ERROR)
            self.assertEquals(packet.other_type, PACKET_POKER_EXPLAIN)
            self.assertEquals(packet.code, 0)
            self.assertEquals(packet.message, "no message")
        d.addCallback(checkError)
        # I believe that turning off packet queue here happens to get some
        # extra coverage in the pokeravatar.sendPacket() function.  Think
        # twice before using the queue in this test.
        avatar.noqueuePackets()
        client.sendPacket(PacketPokerExplain(value = PacketPokerExplain.ALL))
        return  d
    # -------------------------------------------------------------------------
    def test16_explainTooLate(self):
        """This test covers the case where you attempt to turn on explain
        after being at a table."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 101, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 101)
        d.addCallback(self.buyInTable, 0, 101, 1000)
        d.addCallback(self.autoBlindAnte, 0, 101)
        d.addCallback(self.sitTable, 0, 101)
        d.addCallback(self.sendExplainTooLate)
        return d
    # -------------------------------------------------------------------------
    def pingThenUnprivRegisterTourney(self, (client, packet)):
        avatar = self.service.avatars[0]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPing())
        avatar.handlePacketLogic(PacketPokerTourneyRegister(serial = client.getSerial(),
                                                            game_id = 102))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_AUTH_REQUEST:
                found = True
        self.assertEquals(found, True)
        return (client,)
    # -------------------------------------------------------------------------
    def test17_pingAndUnpriv(self):
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.pingThenUnprivRegisterTourney)
        return d
    # -------------------------------------------------------------------------
    def requestsWithWrongSerial(self, (client, packet), avid, gameId):
        import StringIO

        avatar = self.service.avatars[avid]
        avatar.queuePackets()
        someoneElseSerial = client.getSerial() + 1
        userByUser = " for user %d by user %d" % (someoneElseSerial, client.getSerial())
        forPlayerByPlayer = " for player %d by player %d" % \
            (someoneElseSerial, client.getSerial())
        playerByPlayer = " player %d by player %d" % \
            (someoneElseSerial, client.getSerial())
        ofPlayerByPlayer = " of player %d by player %d" % \
            (someoneElseSerial, client.getSerial())
        messageStart = "PokerAvatar: "
        badPacketAttempts = {
            'user_info' : { 'output' : 
                          "%sattempt to get user info%s\n" % (messageStart, userByUser),
                          'packet' :
                              PacketPokerGetUserInfo(serial = someoneElseSerial) },
            'get_personal' : { 'output' :
                              "%sattempt to get personal info%s\n" % (messageStart, userByUser),
                                'packet' :
                                    PacketPokerGetPersonalInfo(serial = someoneElseSerial),
                               'err_type': PACKET_AUTH_REQUEST },
            'player_info' : { 'output': "%sattempt to set player info%s" \
                                  % (messageStart, forPlayerByPlayer),
                              'packet': 
                              PacketPokerPlayerInfo(serial = someoneElseSerial,
                                      name = "YOU_BEEN_CRACKED",
                                      url = "http://example.com/myhack", outfit = "Naked") },
            'player_image' : { 'output' :
                               "%sattempt to set player info%s" \
                                   % (messageStart, forPlayerByPlayer),
                               'packet' :
                                   PacketPokerPlayerImage(serial = someoneElseSerial,
                                      image_type = "crack/tiff", image = "YOU_BEEN_CRACKED") },
            'set_personal' : { 'output' :
                               "%sattempt to set player info%s" \
                                   % (messageStart, forPlayerByPlayer),
                               'packet' :
                                   PacketPokerPersonalInfo(serial = someoneElseSerial,
                                        firstname = "YOU_HAVE",
                                        lastname = "BEEN_CRACKED", birthday = "2001-01-01") },
            'cash_in' : { 'output' :
                              "%sattempt to cash in%s\n" % (messageStart, userByUser),
                          'packet' : 
                          PacketPokerCashIn(serial = someoneElseSerial, 
                                            name = "YOU_BEEN_CRACKED", value = 1000000,
                                            url = "http://example.com/myhack"),
                          'err_type' : PACKET_POKER_ERROR,
                          'other_type' : PACKET_POKER_CASH_IN },
            'cash_out' : { 'output' :
                               "%sattempt to cash out%s\n" % (messageStart, userByUser),
                           'packet' : 
                           PacketPokerCashOut(serial = someoneElseSerial, 
                                             name = "YOU_BEEN_CRACKED", value = 1000000,
                                             url = "http://example.com/myhack"),
                           'err_type' : PACKET_POKER_ERROR,
                           'other_type' : PACKET_POKER_CASH_OUT },
            'tourney_reg': { 'output':
                               "%sattempt to register in tournament %d%s" 
                                         % (messageStart, gameId, forPlayerByPlayer),
                             'packet' : 
                             PacketPokerTourneyRegister(serial = someoneElseSerial,
                                                        game_id = gameId) },
            'tourney_unreg': { 'output':
                                   "%sattempt to unregister from tournament %d%s"
                                         % (messageStart, gameId, forPlayerByPlayer),
                             'packet' : 
                               PacketPokerTourneyUnregister(serial = someoneElseSerial,
                                                            game_id = gameId) },
            'hand_hist' : { 'output':
                                "%sattempt to get history%s" % (messageStart, ofPlayerByPlayer),
                            'packet' :
                                PacketPokerHandHistory(serial = someoneElseSerial,
                                                       serial2name = { someoneElseSerial : "YOU_BEEN_CRACKED" },
                                                       history = 'CRACKED') },
            'ready' : { 'output':
                                "%sattempt to set ready to play%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerReadyToPlay(serial = someoneElseSerial,
                                                       game_id = gameId) },
            'proc' : { 'output':
                           "%sattempt to set processing hand%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerProcessingHand(serial = someoneElseSerial,
                                                          game_id = gameId) },
            'seat' : { 'output':
                           "%sattempt to get seat%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerSeat(serial = someoneElseSerial, 
                                                seat = 255, game_id = gameId) },
            'buyin' : { 'output':
                           "%sattempt to bring money%s" % (messageStart, \
                            forPlayerByPlayer),
                            'packet' :
                                PacketPokerBuyIn(serial = someoneElseSerial, 
                                                 amount = 1000, game_id = gameId) },
            'rebuy' : { 'output':
                           "%sattempt to rebuy%s" % (messageStart, forPlayerByPlayer),
                            'packet' :
                                PacketPokerRebuy(serial = someoneElseSerial, 
                                                 amount = 1000, game_id = gameId) },
            'chat' : { 'output':
                           "%sattempt chat%s" % (messageStart, forPlayerByPlayer),
                            'packet' :
                                PacketPokerChat(serial = someoneElseSerial, game_id = gameId,
                                    message = "I AM IN YOUR SERIALZ CHATING YOUR POKERZ") },
            'leave' : { 'output':
                           "%sattempt to leave%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerPlayerLeave(serial = someoneElseSerial, game_id = gameId,
                                                       seat = 2) },
            'sit' : { 'output':
                           "%sattempt to sit back%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerSit(serial = someoneElseSerial, game_id = gameId) },
            'sitout' : { 'output':
                           "%sattempt to sit out%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerSitOut(serial = someoneElseSerial, game_id = gameId) },
            'autoblind' : { 'output':
                           "%sattempt to set auto blind/ante%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerAutoBlindAnte(serial = someoneElseSerial, game_id = gameId) },
            'noautoblind' : { 'output':
                           "%sattempt to set auto blind/ante%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerNoautoBlindAnte(serial = someoneElseSerial, game_id = gameId) },
            'muckaccept' : { 'output':
                           "%sattempt to accept muck%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerMuckAccept(serial = someoneElseSerial, game_id = gameId) },
            'muckdeny' : { 'output':
                           "%sattempt to deny muck%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerMuckDeny(serial = someoneElseSerial, game_id = gameId) },
            'setaccount' : { 'output':
                           "password must be at least 5 characters long",
                            'packet' :
                                PacketPokerSetAccount(serial= someoneElseSerial),
                             'err_type' : PACKET_ERROR,
                             'other_type' : PACKET_POKER_SET_ACCOUNT },
            'automuck' : { 'output':
                           "%sattempt to set auto muck%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerAutoMuck(serial = someoneElseSerial, game_id = gameId, info = 0x01) },
            'blind' : { 'output':
                           "%sattempt to pay the blind%s %s" % (messageStart, \
                            ofPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerBlind(serial = someoneElseSerial, game_id = gameId, dead = 0,
                                               amount = 100) },
            'waitblind' : { 'output':
                           "%sattempt to wait for big blind%s %s" % (messageStart, \
                            ofPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerWaitBigBlind(serial = someoneElseSerial, game_id = gameId) },
            'ante' : { 'output':
                           "%sattempt to pay the ante%s %s" % (messageStart, \
                            ofPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerAnte(serial = someoneElseSerial, game_id = gameId,amount = 10) },
            'fold' : { 'output':
                           "%sattempt to fold%s %s" % (messageStart, \
                            playerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerFold(serial = someoneElseSerial, game_id = gameId) },
            'call' : { 'output':
                           "%sattempt to call%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerCall(serial = someoneElseSerial, game_id = gameId) },
            'raise' : { 'output':
                           "%sattempt to raise%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerRaise(serial = someoneElseSerial, game_id = gameId, amount=100) },
            'check' : { 'output':
                           "%sattempt to check%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerCheck(serial = someoneElseSerial, game_id = gameId) }
            }
        # Next, we loop through all the serial-related bad pack list,
        # attempting to handle each one.  Setup stdout to go to a string
        # so that we can test if they generate the right printed output.
        # Also, catch any error packets for those we expect to receive.
        for (key, info) in badPacketAttempts.iteritems():
            avatar.resetPacketsQueue()
            avatar.queuePackets()
            messageOutput = StringIO.StringIO()
            sys.stdout = messageOutput
            avatar.handlePacketLogic(info['packet'])
            data = messageOutput.getvalue()
            sys.stdout = sys.__stdout__
            messageOutput.close()
            self.assertEqual(data.find(info['output']) >= 0, True)

            found = False
            for packet in avatar.resetPacketsQueue():
                found = True
                self.assertEquals(packet.type, info['err_type'])
                if info.has_key('other_type'):
                    self.assertEquals(info['other_type'], packet.other_type)
            self.assertEquals(found, info.has_key('err_type'))
        return (client, packet)
    # -------------------------------------------------------------------------
    def test18_badAttempts(self):
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 101, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 101)
        d.addCallback(self.buyInTable, 0, 101, 1000)
        d.addCallback(self.autoBlindAnte, 0, 101)
        d.addCallback(self.sitTable, 0, 101)
        d.addCallback(self.requestsWithWrongSerial, 0, 101)
        return d
    # -------------------------------------------------------------------------
    def badBuyIn(self, (client, packet), id, gameId, myAmount):
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        seatNumber = id + 1
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerBuyIn(serial = client.getSerial(),
                                               amount = myAmount, game_id = gameId))
        found = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_ERROR:
                found += 1
                self.assertEquals(packet.game_id, table.game.id)
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.other_type, PACKET_POKER_BUY_IN)
        self.assertEquals(found, 1)
        return (client, packet)
    # -------------------------------------------------------------------------
    def test19_badBuyIn(self):
        """Test to cover the condition where the buyIn fails"""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 100, 'Table1', '100-200-no-limit')
        d.addCallback(self.seatTable, 0, 100)

        # Note: this only "works" (i.e., fails properly) if you have a
        # currency serial that is valid, because of this line in
        # pokerservice.py's buyInPlayer
        #     if not currency_serial: return amount
        d.addCallback(self.badBuyIn, 0, 100, 1)
        return d
    # ------------------------------------------------------------------------
    def noAutoBlindAnte(self, (client, packet), id, gameId ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerNoautoBlindAnte(serial= client.getSerial(),
                                                        game_id = gameId))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_NOAUTO_BLIND_ANTE:
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.game_id, gameId)
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # -------------------------------------------------------------------------
    def test20_turningOffAutoBlind(self):
        """Test to cover a player turning off their autoBlindAnte Setting"""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 101, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 101)
        d.addCallback(self.buyInTable, 0, 101, 1000)
        d.addCallback(self.autoBlindAnte, 0, 101)
        d.addCallback(self.noAutoBlindAnte, 0, 101)
        return d
    # ------------------------------------------------------------------------
    def sitOut(self, (client, packet), id, gameId ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerSitOut(serial= client.getSerial(),
                                                        game_id = gameId))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_SIT_OUT:
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.game_id, gameId)
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # -------------------------------------------------------------------------
    def test21_sitOut(self):
        """Test playing an actual hand all the way through"""
        # The sequence of how to get yourself seated in a cash game was
        # taken from the instructions at the top of pokerpackets.py
        # labelled "How to sit at a cash game table ?"
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 101, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 101)
        d.addCallback(self.buyInTable, 0, 101, 1000)
        d.addCallback(self.autoBlindAnte, 0, 101)
        d.addCallback(self.sitTable, 0, 101)
        d.addCallback(self.readyToPlay, 0, 101)
        d.addCallback(self.sitOut, 0, 101)
        return d
    # -------------------------------------------------------------------------
    def sitOutClosedGame(self, (client, packet), id, gameId ):
        table = self.service.getTable(gameId)
        table.game.close()

        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerSitOut(serial= client.getSerial(),
                                                        game_id = gameId))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_AUTO_FOLD:
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.game_id, gameId)
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # -------------------------------------------------------------------------
    def test22_sitOutClosedGame(self):
        """Test playing an actual hand all the way through"""
        # The sequence of how to get yourself seated in a cash game was
        # taken from the instructions at the top of pokerpackets.py
        # labelled "How to sit at a cash game table ?"
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 101, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 101)
        d.addCallback(self.buyInTable, 0, 101, 1000)
        d.addCallback(self.autoBlindAnte, 0, 101)
        d.addCallback(self.sitTable, 0, 101)
        d.addCallback(self.readyToPlay, 0, 101)
        d.addCallback(self.sitOutClosedGame, 0, 101)
        return d
    # ------------------------------------------------------------------------
    def doBlindPostAndHaveOtherGuyWaitForCardsAndQuit(self, (client, packet), id, gameId):
        # By now, we should have seen as noted above, a request for the
        # blinds for avatar1 for 100 small blind.  Here we send it.
        otherAvatar = self.service.avatars[0]
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerBlind(serial= avatar.getSerial(),
                                                   game_id = gameId, dead = 0,
                                                   amount = 100))
        otherAvatar.removePlayer(table, otherAvatar.getSerial())
        return (client, packet)
    # ------------------------------------------------------------------------
    def test23_quitPlayerInHand(self):
        """Test when a player quits in the middle of a hand."""
        # The sequence of how to get yourself seated in a cash game was
        # taken from the instructions at the top of pokerpackets.py
        # labelled "How to sit at a cash game table ?"
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 101, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 101)
        d.addCallback(self.buyInTable, 0, 101, 1000)
        d.addCallback(self.autoBlindAnte, 0, 101)
        d.addCallback(self.sitTable, 0, 101)
        d.addCallback(self.readyToPlay, 0, 101)
        d2 = self.client_factory[1].established_deferred
        d2.addCallback(self.sendExplain)
        d2.addCallback(self.login, 1)
        d2.addCallback(self.joinTable, 1, 101, 'Table2', '2-4-limit')
        d2.addCallback(self.seatTable, 1, 101)
        d2.addCallback(self.buyInTable, 1, 101, 1000)
        d2.addCallback(self.sitTable, 1, 101)
        d2.addCallback(self.readyToPlay, 1, 101)
        d2.addCallback(self.dealTable, 101)
        d2.addCallback(self.beginHandSetup, 101)
        d2.addCallback(self.doBlindPostAndHaveOtherGuyWaitForCardsAndQuit, 1, 101)
        return defer.DeferredList((d, d2))
    # ------------------------------------------------------------------------
    def getPersonalInfo(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerGetPersonalInfo(serial= client.getSerial()))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_PERSONAL_INFO:
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.name, "user%d" % id)
                self.assertEquals(packet.password, "")
                self.assertEquals(packet.rating, 1000)
                self.assertEquals(packet.affiliate, 0)
                self.assertEquals(packet.addr_street, "")
                self.assertEquals(packet.firstname, "Joe")
                self.assertEquals(packet.lastname, "Schmoe")
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def setPersonalInfo(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerPersonalInfo(serial= client.getSerial(),
                                                         firstname = "Joe",
                                                         lastname = "Schmoe"))
        return (client, packet)
    # ------------------------------------------------------------------------
    def test24_personalInfo(self):
        """Test lookup of personal information."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.setPersonalInfo, 0)
        d.addCallback(self.getPersonalInfo, 0)
        return d
    # ------------------------------------------------------------------------
    def listHands(self, (client, packet), id, mySerial):
        avatar = self.service.avatars[id]
        if mySerial == -1: mySerial = client.getSerial()
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerHandSelect(serial= mySerial, count = 5, start = 0))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_HAND_LIST:
                self.assertEquals(packet.count, 5)
                self.assertEquals(packet.hands, [])
                self.assertEquals(packet.total, 0)
                found = True
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerHandSelect(serial= None, count = 5, start = 0))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_HAND_LIST:
                self.assertEquals(packet.count, 5)
                self.assertEquals(packet.hands, [])
                self.assertEquals(packet.total, 0)
                found = True
        self.assertEquals(found, True)

        from _mysql_exceptions import OperationalError
        try:
            avatar.handlePacketLogic(PacketPokerHandSelect(serial= mySerial, count = 5, start = 0,
                                                           string = "Testing"))
        except OperationalError, oe:
            self.assertEquals(oe[0],1054)
            self.assertEquals(oe[1], "Unknown column 'Testing' in 'where clause'")

        return (client, packet)
    # ------------------------------------------------------------------------
    def test25_listHands(self):
        """Test for hand listing."""
        # It might be better to improve this test so that a few hands have
        # actually been played and therfore an actual hand list is available.
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.listHands, 1, -1)
        return d
    # ------------------------------------------------------------------------
    def listTables(self, (client, packet), id):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTableSelect(string = ""))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_TABLE_LIST:
                self.assertEquals(packet.players, 0)
                self.assertEquals(packet.tables, 3)
                count = 0
                for p in packet.packets:
                    count += 1
                    self.assertEquals(p.average_pot,  0)
                    self.assertEquals(p.hands_per_hour, 0)
                    self.assertEquals(p.percent_flop, 0)
                    self.assertEquals(p.players, 0)
                    self.assertEquals(p.observers, 0)
                    self.assertEquals(p.waiting, 0)
                    self.assertEquals(p.skin,  "default")
                    self.assertEquals(p.variant, "holdem")
                    if (p.id == 100):
                        self.assertEquals(p.name, "Table1")
                        self.assertEquals(p.betting_structure, "100-200-no-limit")
                        self.assertEquals(p.seats, 10)
                        self.assertEquals(p.player_timeout, 60)
                        self.assertEquals(p.currency_serial, 1)
                    elif (p.id == 101):
                        self.assertEquals(p.name, "Table2")
                        self.assertEquals(p.betting_structure, "2-4-limit")
                        self.assertEquals(p.player_timeout, 60)
                        self.assertEquals(p.muck_timeout, 5)
                        self.assertEquals(p.currency_serial, 0)
                    elif (p.id == 102):
                        self.assertEquals(p.name, "Table3")
                        self.assertEquals(p.betting_structure, "test18pokerclient")
                        self.assertEquals(p.player_timeout, 600)
                        self.assertEquals(p.muck_timeout, 600)
                        self.assertEquals(p.seats, 10)
                        self.assertEquals(p.currency_serial, 1)
                self.assertEquals(count, packet.tables)
                found = True
        self.assertEquals(found, True)

        return (client, packet)
    # ------------------------------------------------------------------------
    def test26_listTables(self):
        """Test for table listing."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.listTables, 0)
        return d
    # ------------------------------------------------------------------------
    def getPlayerInfoError(self, (client, packet), id):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerGetPlayerInfo())
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ERROR:
                self.assertEquals(packet.code, PacketPokerGetPlayerInfo.NOT_LOGGED)
                self.assertEquals(packet.message, "Not logged in")
                self.assertEquals(packet.other_type, PACKET_POKER_GET_PLAYER_INFO)
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test27_playerInfoNotLoggedIn(self):
        """Test for getting player info before login has occurred."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.getPlayerInfoError, 0)
        return d
    # ------------------------------------------------------------------------
    def setPokerPlayerInfo(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerPlayerInfo(serial= client.getSerial(),
                                                       name = "The Naked Guy",
                                                       outfit = "Naked",
                                                       url = "http://example.org"))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_PLAYER_INFO:
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.name, "The Naked Guy")
                self.assertEquals(packet.outfit, "Naked")
                self.assertEquals(packet.url, "http://example.org")
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test28_setPokerPlayerInfo(self):
        """Test for setting poker player info."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.setPokerPlayerInfo, 0)
        return d
    # ------------------------------------------------------------------------
    def errorSetPokerPlayerInfo(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        def forceFalse(player_info):
            return False
        originalFunction = avatar.service.setPlayerInfo
        avatar.service.setPlayerInfo = forceFalse

        avatar.handlePacketLogic(PacketPokerPlayerInfo(serial= client.getSerial(),
                                                       name = "The Naked Guy",
                                                       outfit = "Naked",
                                                       url = "http://example.org"))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ERROR:
                self.assertEquals(packet.other_type, PACKET_POKER_PLAYER_INFO)
                self.assertEquals(packet.code, PACKET_POKER_PLAYER_INFO)
                self.assertEquals(packet.message, "Failed to save set player information")
                found = True
        self.assertEquals(found, True)
        avatar.service.setPlayerInfo = originalFunction
        return (client, packet)
    # ------------------------------------------------------------------------
    def test29_errorSetPokerPlayerInfo(self):
        """Test for errors when setting poker player info."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.errorSetPokerPlayerInfo, 0)
        return d
    # ------------------------------------------------------------------------
    def setPokerPlayerImage(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerPlayerImage(serial= client.getSerial(),
                                                        image = "naked.png",
                                                        image_type = "image/gif"))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ACK:
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def errorSetPokerPlayerImage(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        def forceFalse(player_info):
            return False
        originalFunction = avatar.service.setPlayerImage
        avatar.service.setPlayerImage = forceFalse
        avatar.handlePacketLogic(PacketPokerPlayerImage(serial= client.getSerial(),
                                                        image = "naked.png",
                                                        image_type = "image/gif"))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ERROR:
                self.assertEquals(packet.other_type, PACKET_POKER_PLAYER_IMAGE)
                self.assertEquals(packet.code, PACKET_POKER_PLAYER_IMAGE)
                self.assertEquals(packet.message, "Failed to save set player image")
                found = True
        self.assertEquals(found, True)
        avatar.service.setPlayerImage = originalFunction
        return (client, packet)
    # ------------------------------------------------------------------------
    def test30_setPlayerImage(self):
        """Test for setting the player image."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.setPokerPlayerImage, 0)
        return d
    # ------------------------------------------------------------------------
    def test31_errorSetPlayerImage(self):
        """Test for setting the player image."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.errorSetPokerPlayerImage, 0)
        return d
    # ------------------------------------------------------------------------
    calledCashIn = False
    def cashIn(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        PokerAvatarTestCase.calledCashIn = False
        def fakeCashIn(packet):
            PokerAvatarTestCase.calledCashIn = True
        self.originalFunction = avatar.service.cashIn
        avatar.service.cashIn = fakeCashIn
        avatar.handlePacketLogic(PacketPokerCashIn(serial= client.getSerial(),
                                                   currency = "http://fake",
                                                   bserial = 0, value = 10))
        return (client, packet)
    # ------------------------------------------------------------------------
    def checkCashIn(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        self.assertEquals(PokerAvatarTestCase.calledCashIn, True)
        avatar.service.cashIn = self.originalFunction
    # ------------------------------------------------------------------------
    def test32_cashIn(self):
        """Test for doing a cash in operation."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.cashIn, 0)
        d.addCallback(self.checkCashIn, 0)
        return d
    # ------------------------------------------------------------------------
    def cashQuery(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerCashQuery(application_data =
                                                      "THIS_WILL_NOT_BE_FOUND_AS_VALID_AT_ALL"))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ERROR:
                self.assertEquals(packet.other_type, PACKET_POKER_CASH_QUERY)
                self.assertEquals(packet.code, PacketPokerCashQuery.DOES_NOT_EXIST)
                self.assertEquals(packet.message, "No record with application_data = 'THIS_WILL_NOT_BE_FOUND_AS_VALID_AT_ALL'")
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test33_cashQuery(self):
        """Test for a cash query operation; it's designed to fail and get a packet error."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.cashQuery, 0)
        return d
    # ------------------------------------------------------------------------
    def setPokerAccount(self, (client, packet), id, packetType ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        if packetType == PACKET_POKER_CREATE_ACCOUNT:
            avatar.handlePacketLogic(PacketPokerCreateAccount(serial= client.getSerial()))
        else:
            avatar.handlePacketLogic(PacketPokerSetAccount(serial= client.getSerial()))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ERROR:
                self.assertEquals(packet.other_type, packetType)
                self.assertEquals(packet.code, PacketPokerSetAccount.PASSWORD_TOO_SHORT)
                self.assertEquals(packet.message, "password must be at least 5 characters long")
        return (client, packet)
    # ------------------------------------------------------------------------
    def test34_setPokerAccount(self):
        """Test sending the set poker account packet."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.setPokerAccount, 0, PACKET_POKER_CREATE_ACCOUNT)
        d.addCallback(self.setPokerAccount, 0, PACKET_POKER_SET_ACCOUNT)
        return d
    # ------------------------------------------------------------------------
    def tourneySelect(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTourneySelect(string = ""))
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_TOURNEY_LIST:
                count = 0
                for p in packet.packets:
                    assert p.name.find("sitngo") >= 0 or  p.name.find("egular")
                    assert p.name.find("registering") >= 0 or  p.name.find("announced")
                    count += 1
                self.assertEquals(count, 25)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test35_tourneys(self):
        """Test sending the set poker account packet."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.tourneySelect, 0)
        return d
    # ------------------------------------------------------------------------
    calledCashOut = False
    def cashOut(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        PokerAvatarTestCase.calledCashOut = False
        def fakeCashOut(packet):
            PokerAvatarTestCase.calledCashOut = True
        self.originalFunction = avatar.service.cashOut
        avatar.service.cashOut = fakeCashOut
        avatar.handlePacketLogic(PacketPokerCashOut(serial= client.getSerial(),
                                                   currency = "http://fake",
                                                   bserial = 0, value = 10))
        return (client, packet)
    # ------------------------------------------------------------------------
    def checkCashOut(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        self.assertEquals(PokerAvatarTestCase.calledCashOut, True)
        avatar.service.cashOut = self.originalFunction
    # ------------------------------------------------------------------------
    def test36_cashOut(self):
        """Test for doing a cash out operation."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.cashOut, 0)
        return d
    # ------------------------------------------------------------------------
    calledCashOutCommit = False
    def cashOutCommit(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        PokerAvatarTestCase.calledCashOutCommit = False
        def fakeCashOutCommit(packet):
            PokerAvatarTestCase.calledCashOutCommit = True
        self.originalFunction = avatar.service.cashOutCommit
        avatar.service.cashOutCommit = fakeCashOutCommit
        avatar.handlePacketLogic(PacketPokerCashOutCommit(transaction_id = 0))
        return (client, packet)
    # ------------------------------------------------------------------------
    def checkCashOutCommit(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        self.assertEquals(PokerAvatarTestCase.calledCashOutCommit, True)
        avatar.service.cashOutCommit = self.originalFunction
    # ------------------------------------------------------------------------
    def test37_cashOutCommit(self):
        """Test for doing a cash out commit operation."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.cashOutCommit, 0)
        return d
    # ------------------------------------------------------------------------
    def tourneyPlayerList(self, (client, packet), id, gameId ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTourneyRequestPlayersList(game_id = gameId))
        for packet in avatar.resetPacketsQueue():
            count = 0
            if packet.type == PACKET_POKER_TOURNEY_PLAYERS_LIST:
                self.assertEquals(packet.serial, 1)
                self.assertEquals(packet.game_id, 0)
                count += 1
            self.assertEquals(count, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test38_tourneyPlayerList(self):
        """Test for listing players in a tourney."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.tourneyPlayerList, 0, 1)
        return d
    # ------------------------------------------------------------------------
    def listPlayers(self, (client, packet), id, gameId ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTableRequestPlayersList(serial = client.getSerial(),
                                                                    game_id = gameId))
        for packet in avatar.resetPacketsQueue():
            count = 0
            if packet.type == PACKET_POKER_PLAYERS_LIST:
                self.assertEquals(packet.players, [('user0', 1000, 0), ('user1', 1000, 0)])
                count += 1
            self.assertEquals(count, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test39_tablePlayerList(self):
        """Test for listing players in at a table."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 101, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 101)
        d.addCallback(self.buyInTable, 0, 101, 1000)
        d.addCallback(self.autoBlindAnte, 0, 101)
        d.addCallback(self.sitTable, 0, 101)
        d.addCallback(self.readyToPlay, 0, 101)
        d2 = self.client_factory[1].established_deferred
        d2.addCallback(self.sendExplain)
        d2.addCallback(self.login, 1)
        d2.addCallback(self.joinTable, 1, 101, 'Table2', '2-4-limit')
        d2.addCallback(self.seatTable, 1, 101)
        d2.addCallback(self.buyInTable, 1, 101, 1000)
        d2.addCallback(self.sitTable, 1, 101)
        d2.addCallback(self.readyToPlay, 1, 101)
        d2.addCallback(self.listPlayers, 1, 101)
        return defer.DeferredList((d, d2))
        return d
    # ------------------------------------------------------------------------
    def CORRECTEDtourneyRegister(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTourneyRegister(serial = client.getSerial(),
                                                            game_id = 1101134))
        for packet in avatar.resetPacketsQueue():
            count = 0
            if packet.type == PACKET_ERROR:
                self.assertEquals(packet.other_type, PACKET_POKER_TOURNEY_REGISTER)
                self.assertEquals(packet.code, PacketPokerTourneyRegister.DOES_NOT_EXIST)
                count += 1
            self.assertEquals(count, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def tourneyRegister(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        # I do not actually believe that pokerservice.tourneyRegister should be throwing
        #      exceptions.TypeError: cannot concatenate 'str' and 'PacketError' objects.

        # In other words, the above tourneyRegister should work.  This bug
        # is described https://gna.org/bugs/?11148

        try:
            avatar.handlePacketLogic(PacketPokerTourneyRegister(serial = client.getSerial(),
                                                                game_id = 1101134))
            self.assertEquals("", "If this is reached, then maybe you should switch to CORRECTEDtourneyRegister")
        except TypeError, te:
            self.assertEquals(te[0], "cannot concatenate 'str' and 'PacketError' objects")
        return (client, packet)
    # ------------------------------------------------------------------------
    def test40_tourneyRegister(self):
        """Test for registering a players in a tourney."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.tourneyRegister, 0)
        return d
    # ------------------------------------------------------------------------
    def tourneyUnregister(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTourneyUnregister(serial = client.getSerial(),
                                                            game_id = 1101134))
        count = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ERROR:
                self.assertEquals(packet.other_type, PACKET_POKER_TOURNEY_UNREGISTER)
                self.assertEquals(packet.code, PacketPokerTourneyUnregister.DOES_NOT_EXIST)
                count += 1
        self.assertEquals(count, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test41_tourneyUnregister(self):
        """Test for unregistering players from a tourney."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.tourneyUnregister, 0)
        return d
    # ------------------------------------------------------------------------
    def tinyFunctions(self, (client, packet), id):
        avatar = self.service.avatars[id]
        self.assertEquals(avatar.getUrl(), "random")
        self.assertEquals(avatar.getOutfit(), "random")
    # ------------------------------------------------------------------------
    def test99_testTinyFunctions(self):
        """Test a few small functions that are not otherwise called"""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.tinyFunctions, 0)
        return d
    # ------------------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test41"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerAvatarTestCase))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
#                              tracebackFormat='verbose',
                              tracebackFormat='default',
                              ).run(suite)

# ------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokeravatar.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokeravatar.py ../pokernetwork/pokertable.py ../pokernetwork/pokerservice.py ../pokernetwork/pokerclient.py  ../pokernetwork/pokerserver.py' TESTS='coverage-reset test-pokeravatar.py coverage-report' check )"
# End:
