#!@PYTHON@
# -*- mode: python -*-
#
# Copyright (C) 2006, 2007 Loic Dachary <loic@dachary.org>
# Copyright (C) 2008       Bradley M. Kuhn <bkuhn@ebb.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.
#
import sys, os
sys.path.insert(0, "@srcdir@/../..")
sys.path.insert(0, "..")

import libxml2
from pprint import pprint
from string import split
import time

from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor, defer

twisted.internet.base.DelayedCall.debug = True

from tests.testmessages import silence_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from pokerengine import pokertournament
from pokernetwork import pokertable, pokernetworkconfig
from pokernetwork.pokerpackets import *
from pokernetwork.pokeravatar import DEFAULT_PLAYER_USER_DATA
from pokerengine.pokercards import PokerCards

settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="3" autodeal="yes" >
  <delays autodeal="2" autodeal_max="2" autodeal_check="0" round="0" position="0" showdown="0" finish="0" />

  <path>@POKER_ENGINE_PKGSYSCONFDIR@ @POKER_NETWORK_PKGSYSCONFDIR@</path>
  <users temporary="BOT"/>
</server>
"""
settings_stripped_deck_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="3" autodeal="yes" >
  <delays autodeal="2" autodeal_max="2" autodeal_check="0" round="0" position="0" showdown="0" finish="0" />

  <decks>
    <deck>9c 9d 9h Ts Tc Td Th Ts Jc Jd Jh Js Qc Qd Qh Qs Kc Kd Kh Ks Ac Ad Ah As</deck>
  </decks>

  <path>@POKER_ENGINE_PKGSYSCONFDIR@ @POKER_NETWORK_PKGSYSCONFDIR@</path>
  <users temporary="BOT"/>
</server>
"""

class MockService:

    def __init__(self, settings):
        self.settings = settings
        self.verbose = settings.headerGetInt("/server/@verbose")
        self.dirs = split(settings.headerGet("/server/path"))
        self.simultaneous = 4
        self.shutting_down = False
        self.hand_serial = 0
        self.chat = False
        self.players = {}
        self.table1 = None
        self.table2 = None

    def getTable(self, gameId):
        if gameId == self.table1.game.id:
            return self.table1
        elif gameId == self.table2.game.id:
            return self.table2
        else:
            self.error("Unknown game requested: " + gameId)
            return None

    def message(self, message):
        if self.verbose >= 0:
            print "MockService " + message
        
    def getName(self, serial):
        return "MockServiceName%d" % serial

    def getPlayerInfo(self, serial):
        class Dummy:
            def __init__(self):
                self.name = "MockServicePlayerInfo"
        return Dummy()

    def error(self, message):
        self.message("error " + message)

    def movePlayer(self, serial, fromGameId, toGameId):
        return 0

    def seatPlayer(self, serial, table_id, amount):
        if self.players.has_key(serial):
            self.error("Player is already seated at table, ." % table_id)
            return False
        else:
            self.players[serial] = { 'table_id' : table_id, 'amount' : amount }
            return True

    def buyInPlayer(self, serial, game_id, currency_serial, amount):
        return amount

    def getHandSerial(self):
        self.hand_serial += 1
        return self.hand_serial

    def tableMoneyAndBet(self, table_id):
        return (0, 0)

    def leavePlayer(self, serial, table_id, currency_serial):
        if self.players.has_key(serial):
            del self.players[serial]
            return True
        else:
            self.error("Player is already seated at table, ." % table_id)
            return False

    def deleteTable(self, x):
        pass

    def destroyTable(self, x):
        pass

    def loadHand(self, handId):
        # Only ever return the one hand; the only one this mock game ever had...
        #  ... but only if they give a positive integer as a handId.
        if handId <= 0:
            return None
        else:
            board = PokerCards() 
            hand1 = PokerCards(['Qd', 'Ts'])
            hand2 = PokerCards(['Kh', 'Kc'])
            flop  = PokerCards(['Jd', 'Js', "Jc"])
            turn  = PokerCards(['Tc', 'Js', 'Jc', 'Tc'])
            river  = PokerCards(['Tc', 'Js', 'Jc', 'Tc', 'Ad'])
            return  [ \
                        ('game', 1, 777, 3, time.time(), 'variant','betting_structure', [1, 2], 7, { 1 : 7890, 2 : 1234}), \
                        ('wait_for', 1, 'first_round'), \
                        ('player_list', [1, 2]), \
                        ('round', 'round1', board, { 1 : hand1, 2 : hand2}), \
                        ('round', 'round2', flop, { 1 : hand1, 2 : hand2}), \
                        ('round', 'round3', turn, { 1 : hand1, 2 : hand2}), \
                        ('round', 'round4', river, { 1 : hand1, 2 : hand2}), \
                        ('showdown', river, {1 : hand1, 2 : hand2}), \
                        ('position', 1), \
                        ('blind_request', 1, 222, 735, 'big_and_dead'), \
                        ('wait_blind', 1), \
                        ('blind', 1, 222, 0), \
                        ('ante_request', 1, 111), \
                        ('ante', 1, 111), \
                        ('all-in', 1), \
                        ('call', 1, 411), \
                        ('check', 1), \
                        ('fold', 1), \
                        ('raise', 1, 888), \
                        ('canceled', 1, 10), \
                        ('rake', 7, { 1 : 7}), \
                        ('end', [1], [{ 'serial2share': { 1: 500 } }]), \
                        ('sitOut', 1), \
                        ('leave', [(1, 2), (2, 7)]), \
                        ('finish', 1), \
                        ('muck', (1,2)), \
                        ('rebuy', 1, 9999), \
                        ('unknown',) ]
class MockClient:
    def __init__(self, serial):
        self.verbose = int(os.environ.get('VERBOSE_T', '-1'))
        self.serial = serial
        self.deferred = None
        self.raise_if_packet = None
        self.type = None
        self.tables = {}
        self.packets = []

    def __str__(self):
        return "MockClient of Player%d" % self.serial

    def waitFor(self, type):
        self.deferred = defer.Deferred()
        self.type = type
        return self.deferred

    def raiseIfPacket(self, type):
        self.raise_if_packet = type

    def lookForPacket(self, type):
        for packet in self.packets:
            if packet.type == type:
                return packet
        return False

    def message(self, message):
        if self.verbose >= 0:
            print "MockClient " + message
        
    def error(self, message):
        self.message("error " + message)

    def join(self, table):
        pass

    # Loic indicates that it's the job of the Client to pass along a few
    # things, including "player removes", and various clients settings, to
    # the game class.  These next few functions do that to be consistent
    # with what the pokertable API expects.

    def removePlayer(self, table, serial):
        if not self.tables.has_key(table.game.id):
            self.error("Table with game number %d does not occur exactly once for this player." % table.game.id)
        return table.game.removePlayer(serial)

    def autoBlindAnte(self, table, serial, auto):
        table.game.getPlayer(serial).auto_blind_ante = auto

    def sitPlayer(self, table, serial):
        table.game.sit(serial)

    def addPlayer(self, table, seat):
        self.tables[table.game.id] = table
        if table.game.addPlayer(self.serial, seat):
            player = table.game.getPlayer(self.serial)
            player.setUserData(DEFAULT_PLAYER_USER_DATA.copy())
        return True

    def sitOutPlayer(self, table, serial):
        table.game.sitOutNextTurn(serial)

    def sendPacket(self, packet):
        self.message("sendPacket: " + str(packet))
        self.packets.append(packet)
        if self.deferred:
            if self.raise_if_packet and packet.type == self.raise_if_packet:
                reactor.callLater(0, lambda: self.deferred.errback(packet))
            elif self.type == packet.type:
                reactor.callLater(0, lambda: self.deferred.callback(packet))

    def sendPacketVerbose(self, packet):
        self.sendPacket(packet)

    def getSerial(self):
        return self.serial

    def setMoney(self, table, amount):
        return table.game.payBuyIn(self.serial, amount)

    def getName(self):
        return "Player%d" % self.serial

    def getPlayerInfo(self):
        class MockPlayerInfo:
            def __init__(self, player):
                self.player = player
                self.name = self.player.getName()
                self.url = "http://fake"
                self.outfit = None
        return MockPlayerInfo(self)
# --------------------------------------------------------------------------------
class MockClientWithTableDict(MockClient):
    def __init__(self, serial):
        self.tables = {}
        MockClient.__init__(self, serial)

    def addPlayer(self, table, seat):
        MockClient.addPlayer(self, table, seat)
        self.tables[table.game.id] = seat

# --------------------------------------------------------------------------------
class MockClientWithRemoveTable(MockClient):
    def removeTable(self, gameId):
        return True
# --------------------------------------------------------------------------------
class PokerTableTestCase(unittest.TestCase):
    # -------------------------------------------------------------------
    def setUp(self, settingsXmlStr=settings_xml):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settingsXmlStr, len(settingsXmlStr))
        settings.header = settings.doc.xpathNewContext()
        service = MockService(settings)
        self.table = pokertable.PokerTable(service, 101, 
                                           { 'name': "table1",
                                             'variant': "holdem",
                                             'betting_structure': "2-4-limit",
                                             'seats': 4,
                                             'player_timeout' : 6, 
                                             'muck_timeout' : 1,
                                             'currency_serial': 0
                                             })
        self.table2 = pokertable.PokerTable(service, 202, 
                                           { 'name': "table2",
                                             'variant': "holdem",
                                             'betting_structure': "2-4-limit",
                                             'seats': 4,
                                             'player_timeout' : 6, 
                                             'muck_timeout' : 1,
                                             'currency_serial': 0
                                             })
        service.table1 = self.table
        service.table2 = self.table2
        self.clients = {}
    # -------------------------------------------------------------------
    def tearDown(self):
        self.table.cancelDealTimeout()
        self.table.cancelPlayerTimers()
        del self.table

    def createPlayer(self, serial, getReadyToPlay=True, clientClass=MockClient, table=None):
        if table == None:
            table = self.table
        client = clientClass(serial)
        self.clients[serial] = client
        if getReadyToPlay:
            self.assertEqual(True, table.joinPlayer(client, serial))
            self.assertEqual(True, table.seatPlayer(client, serial, -1))
            self.assertEqual(True, table.buyInPlayer(client, self.table.game.maxBuyIn()))
            self.table.sitPlayer(client, serial)
        return client

    # -------------------------------------------------------------------
    def test01_autodeal(self):
        self.createPlayer(1)
        self.createPlayer(2)
        self.table.scheduleAutoDeal()
        return defer.DeferredList((self.clients[1].waitFor(PACKET_POKER_START),
                                   self.clients[2].waitFor(PACKET_POKER_START)))
    # -------------------------------------------------------------------
    def test02_autodeal_check(self):
        self.createPlayer(1)
        self.table.processingHand(1)
        self.table.game_delay["delay"] = 2
        self.table.game_delay["start"] = time.time()
        self.createPlayer(2)
        self.table.scheduleAutoDeal()
        return self.clients[2].waitFor(PACKET_POKER_MESSAGE)
    # -------------------------------------------------------------------
    def test06_duplicate_buyin(self):
        """ Buy in requested twice for a given player """
        self.createPlayer(1)
        client = self.clients[1]
        self.assertEqual(False, self.table.buyInPlayer(client, self.table.game.maxBuyIn()))
    # -------------------------------------------------------------------
    def test07_break_message(self):
        """ Tournament break issue a message to all players """
        class Tournament:
            def __init__(self):
                self.state = pokertournament.TOURNAMENT_STATE_BREAK_WAIT
                
        self.createPlayer(1)
        self.createPlayer(2)
        self.table.transient = True
        self.table.tourney = Tournament()
        self.table.game.isTournament = lambda: True
        self.table.scheduleAutoDeal()
        self.failUnless(self.clients[1].lookForPacket(PACKET_POKER_GAME_MESSAGE))
        self.failUnless(self.clients[2].lookForPacket(PACKET_POKER_GAME_MESSAGE))
    # -------------------------------------------------------------------
    def test08_player_has_trouble_joining(self):
        """Test for when the table is full and a player is trying hard to join"""
        # Do not use serials of 0's here -- pokerengine will hate that. :)
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
        player[5] = self.createPlayer(5, False)

        # player5 can't sit because the table is full of 1-4...
        self.assertEqual(False, self.table.seatPlayer(player[5], 5, -1))

        self.assertEqual(True, self.table.joinPlayer(player[5], 5))
        #  ... but player5 decides to set all sorts of things that she can't
        #      because she's still just an observer.
        self.assertEqual(False, self.table.muckAccept(player[5], 5))
        self.assertEqual(False, self.table.muckDeny(player[5], 5))
        self.assertEqual(False, self.table.autoBlindAnte(player[5], 5, True))
        self.assertEqual(False, self.table.buyInPlayer(player[5], 0))
        self.assertEqual(False, self.table.rebuyPlayerRequest(player[5], 30))

        # player5 cannot sit out either because she isn't joined yet.
        self.assertEqual(False, self.table.sitOutPlayer(player[5], 5))

        # player1 leaves on his own...
        self.assertEqual(True, self.table.leavePlayer(player[1], 1))

        # ... which allows player5 to finally join legitimately and change
        # her settings.  However, she tries to sit in everyone else's
        # seat, she tries to sit out before getting the seat, rebuy before
        # even buying, and then buys in for nothing, and thus must rebuy

        for p in self.table.game.playersAll():
            self.assertEqual(False, self.table.seatPlayer(player[5], 5, p.seat))

        self.assertEqual(False, self.table.sitPlayer(player[5], 5))

        self.assertEqual(True, self.table.seatPlayer(player[5], 5, -1))
        self.assertEqual(False, self.table.rebuyPlayerRequest(player[5], 2))

        self.assertEqual(True, self.table.buyInPlayer(player[5], 0))

        # ... but cannot sit down again
        self.assertEqual(False, self.table.seatPlayer(player[5], 5, -1))

        # I wonder if these should really return True rather than None?  -- bkuhn
        self.assertEqual(None, self.table.muckAccept(player[5], 5))
        self.assertEqual(None, self.table.muckDeny(player[5], 5))
        self.assertEqual(None, self.table.autoBlindAnte(player[5], 5, True))

        self.assertEqual(True, self.table.rebuyPlayerRequest(player[5], \
                                              self.table.game.maxBuyIn()))
    # -------------------------------------------------------------------
    def test08_2_brokenSeatFactory(self):
        player = self.createPlayer(1)
        self.table.factory.seatPlayer = lambda (a, b, c): False
        self.assertEqual(False, self.table.seatPlayer(player, 1, -1))

    # -------------------------------------------------------------------
    def test08_5_kick(self):
        """Test that kick works correctly"""
        player = self.createPlayer(2)

        self.assertEqual(None, self.table.kickPlayer(2))
        # Test to make sure it's ok if we kick him twice.
        try:
            self.assertEqual(None, self.table.kickPlayer(2))
        except KeyError, ke:
            self.assertEqual(2, ke[0])
    # -------------------------------------------------------------------
    def test08_7_sitout(self):
        """Test that sitOut works correctly"""
        player = self.createPlayer(4)

        # player4 sits out but tries it twice.  (Guess he clicked too much
        # on the button)
        self.assertEqual(True, self.table.sitOutPlayer(player, 4))
        self.assertEqual(True, self.table.sitOutPlayer(player, 4))
    # -------------------------------------------------------------------
    def test08_8_buyinOverMax(self):
        """Test that buyins over the maximum are refused"""
        player = self.createPlayer(1)

        self.assertEqual(False, self.table.rebuyPlayerRequest(player, 1))
        self.assertEqual(False, self.table.rebuyPlayerRequest(player, 2))
    # -------------------------------------------------------------------
    def test09_list_players(self):
        """Test to make sure the list of players given by pokertable is right"""
        d = {}
        for ii in [1, 2, 3, 4]:
            d['Player%d' % ii] = self.createPlayer(ii)
        for x in self.table.listPlayers():
            del d[x[0]]
        self.assertEqual({}, d)
    # -------------------------------------------------------------------
    def test10_info_and_chat(self):
        """Test player discussions and info"""
        for ii in [1, 2, 3, 4]:
            self.createPlayer(ii)
        d = self.table.getPlayerInfo(2)
        self.failUnlessSubstring("Player2", d.name)
        self.table.chatPlayer(self.clients[1], 1, "Hi, I am the One.")
    # -------------------------------------------------------------------
    def test11_packet(self):
        """Test toPacket"""
        packetStr = "%s" % self.table.toPacket()
        for str in [ 'id = 101', 'name = table1', 'variant = holdem', \
                     'betting_structure = 2-4-limit', 'seats = 4', \
                     'average_pot = 0', 'hands_per_hour = 0', \
                     'percent_flop = 0', 'players = 0', 'observers = 0', \
                     'waiting = 0', 'player_timeout = 6', 'muck_timeout = 1', \
                     'currency_serial = 0', 'skin = default' ]:
            self.failUnlessSubstring(str, packetStr)
    # -------------------------------------------------------------------
    def test12_everyone_timeout(self):
        """Test if all players fall through timeout"""
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
        self.table.update()
        return defer.DeferredList((player[1].waitFor(PACKET_POKER_TIMEOUT_NOTICE),
                                   player[2].waitFor(PACKET_POKER_TIMEOUT_NOTICE),
                                   player[3].waitFor(PACKET_POKER_TIMEOUT_NOTICE),
                                   player[4].waitFor(PACKET_POKER_TIMEOUT_NOTICE)))
    # -------------------------------------------------------------------
    def test13_disconnect(self):
        """Test a disconnected player"""
        p1 = self.createPlayer(1, clientClass=MockClientWithTableDict)
        self.table.disconnectPlayer(p1, 1)
    # -------------------------------------------------------------------
    def test13altForNewClientAPI_disconnect(self):
        """Test player disconnection once the client API has a removeTable method
           This is currently turned off because the change has not been
           made.  See the FIXME around line 1218 of pokertable.py in
           pokertable.destroyPlayer
        """
        # This is disabled until the API changes
        return True
        p1 = self.createPlayer(1, clientClass=MockClientWithRemoveTable)
        self.table.disconnectPlayer(p1, 1)
    # -------------------------------------------------------------------
    def test14_closed_games(self):
        """Do typical operations act as expected when the game is closed?"""
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
        self.table.game.close()
        self.table.quitPlayer(player[1], 1)

        # Leaving a closed table generates an error.  player[2] is going
        # to leave, we wait for the error packet to come back, and make
        # sure that they other_type indicates it's a response to our leave
        # request.
        deferredLeaveErrorWait = player[2].waitFor(PACKET_POKER_ERROR)
        def checkReturnPacket(packet):
            self.assertEqual(PACKET_POKER_PLAYER_LEAVE, packet.other_type)
            self.failUnlessSubstring("annot leave", packet.message)
        deferredLeaveErrorWait.addCallback(checkReturnPacket)

        self.table.leavePlayer(player[2], 2)
        return deferredLeaveErrorWait
    # -------------------------------------------------------------------
    def test15_moveTo(self):
        """Make sure a player can move from one place to another"""
        player = self.createPlayer(1)
        otherTablePlayer = self.createPlayer(2, table=self.table2)

        expectPlayerDeferred = otherTablePlayer.waitFor(PACKET_POKER_PLAYER_ARRIVE)
        def checkReturnPacket(packet):
            self.assertEqual(packet.name, "Player1")
            self.assertEqual(packet.game_id, 202)
        expectPlayerDeferred.addCallback(checkReturnPacket)

        self.table.movePlayer(player, 1, self.table2.game.id)

        return expectPlayerDeferred
    # -------------------------------------------------------------------
    def test16_autoMuckTimeoutPolicy(self):
        """Make sure other timeout policies function properly"""
        player = self.createPlayer(1)
        player2 = self.createPlayer(2)
        # Sit out policy is the default
        self.assertEqual(self.table.timeout_policy,  "sitOut")
        self.table.timeout_policy =  "fold"

        expectPlayerAutoFold = player2.waitFor(PACKET_POKER_AUTO_FOLD)
        def checkReturnPacket(packet):
            # Don't assert which serial we get here, as it could be from
            # either player
            self.assertEqual(packet.game_id, 101)
        expectPlayerAutoFold.addCallback(checkReturnPacket)

        self.table.update()

        return expectPlayerAutoFold
    # -------------------------------------------------------------------
    def test17_bogusTimeoutPolicy(self):
        self.table.timeout_policy =  "muck"
        player = self.createPlayer(1)
        player2 = self.createPlayer(2)
        self.table.update()
        return player.waitFor(PACKET_POKER_TIMEOUT_NOTICE)
    # -------------------------------------------------------------------
    def test17a_resetTimeoutPolicy(self):
        """Set timeout policy back to the default"""
        self.table.timeout_policy = "sitOut"
    # -------------------------------------------------------------------
    def test18_handReplay(self):
        """Test replay of hand from pokertable"""
        player = self.createPlayer(1)

        # First try a hand that doesn't exist
        self.assertEqual(None, self.table.handReplay(player, 0))

        def checkHandSerial(packet):
            self.assertEqual(packet.hand_serial, 777)
        def checkAmount(amount, value):
            self.assertEqual(amount, value)
        def checkAnteAmount(packet):
            checkAmount(packet.amount, 111)
        def checkBlindAmount(packet):
            checkAmount(packet.amount, 222)
        def checkCallAmount(packet):
            checkAmount(packet.amount, 411)
        def checkRaiseAmount(packet):
            checkAmount(packet.amount, 888)
        def checkRebuyAmount(packet):
            checkAmount(packet.amount, 9999)
        def checkCanceledAmount(packet):
            checkAmount(packet.amount, 10)
        def checkRakeAmount(packet):
            self.assertEqual(packet.value, 7)
        def checkPosition(packet):
            self.assertEqual(packet.position, 1)
        def checkBlindRequest(packet):
            self.assertEqual(packet.state, "big_and_dead")
            checkBlindAmount(packet)
        def checkPlayerMoney(packet):
            self.assertEqual(True, packet.serial == 1 or packet.serial == 2)
            if packet.serial == 1:
                self.assertEqual(packet.amount, 7890)
            else:
                self.assertEqual(packet.amount, 1234)
        def checkPlayerCards(packet):
            self.assertEqual(True, packet.serial == 1 or packet.serial == 2)
            if packet.serial == 1:
                self.assertEqual(packet.cards, [23, 47])
            else:
                self.assertEqual(packet.cards, [11, 37])
        def checkMuckSerials(packet):
            self.assertEqual(packet.muckable_serials, (1, 2))

        self.table.handReplay(player, 777)

        checkHandSerial(player.lookForPacket(PACKET_POKER_START))
        checkPlayerCards(player.lookForPacket(PACKET_POKER_PLAYER_CARDS))
        checkPlayerCards(player.lookForPacket(PACKET_POKER_PLAYER_CARDS))
        checkPosition(player.lookForPacket(PACKET_POKER_POSITION))
        checkBlindRequest(player.lookForPacket(PACKET_POKER_BLIND_REQUEST))
        checkBlindAmount(player.lookForPacket(PACKET_POKER_BLIND))
        checkAnteAmount(player.lookForPacket(PACKET_POKER_ANTE_REQUEST))
        checkAnteAmount(player.lookForPacket(PACKET_POKER_ANTE))
        checkRebuyAmount(player.lookForPacket(PACKET_POKER_REBUY))
        player.lookForPacket(PACKET_POKER_CALL)
        player.lookForPacket(PACKET_POKER_CHECK)
        player.lookForPacket(PACKET_POKER_FOLD)
        checkRaiseAmount(player.lookForPacket(PACKET_POKER_RAISE))
        checkCanceledAmount(player.lookForPacket(PACKET_POKER_CANCELED))
        checkRakeAmount(player.lookForPacket(PACKET_POKER_RAKE))
        player.lookForPacket(PACKET_POKER_SIT_OUT)
        checkMuckSerials(player.lookForPacket(PACKET_POKER_MUCK_REQUEST))
        checkRebuyAmount(player.lookForPacket(PACKET_POKER_REBUY))
    # -------------------------------------------------------------------
    def test19_serial2clientEmpty(self):
        """Test replay of hand from pokertable"""
        self.assertEqual("MockServiceName1", self.table.getName(1))
        d = self.table.getPlayerInfo(1)
        self.failUnlessSubstring("MockServicePlayerInfo", d.name)
    # -------------------------------------------------------------------
    def test99_destroy_table(self):
        """Test table destruction"""
        p1 = self.createPlayer(1, clientClass=MockClientWithTableDict)
        d = p1.waitFor(PACKET_POKER_TABLE_DESTROY)
        self.table.destroy()
        return d
    # -------------------------------------------------------------------
    def test99altForNewClientAPI_destroy_table(self):
        """Test table destruction once the client API has a removeTable method
           This is currently turned off because the change has not been made.
           See the FIXME around line 117 of pokertable.py in pokertable.destroy
        """
        # This is disabled until the API changes
        return True
        p1 = self.createPlayer(1, clientClass=MockClientWithRemoveTable)
        d = p1.waitFor(PACKET_POKER_TABLE_DESTROY)
        self.table.destroy()
        return d
# -------------------------------------------------------------------

# I seriously considered not having *all* the same tests run with
# predifined decks because it was not needed to get coverage.  A simple
# setup test would have worked.  However, I think it's good leaving it
# this way because if predifined decks are later used extensively, we
# would want all the tests to run and when additional use of predefined
# decks is added.  -- bkuhn, 2008-01-21

class PokerTableTestCaseWithPredefinedDecks(PokerTableTestCase):
    def setUp(self, settingsXmlStr=settings_stripped_deck_xml):
        PokerTableTestCase.setUp(self, settingsXmlStr)

# -------------------------------------------------------------------

# This class tests the same operations as PokerTableTestCase but for tables that
#  are transient.  Note the outcome of various operations are quite different
#  when the table is transient.
class PokerTableTestCaseTransient(PokerTableTestCase):
    def setUp(self, settingsXmlStr=settings_xml):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settingsXmlStr, len(settingsXmlStr))
        settings.header = settings.doc.xpathNewContext()
        service = MockService(settings)
        self.table = pokertable.PokerTable(service, 101, 
                                           { 'name': "table1",
                                             'variant': "holdem",
                                             'betting_structure': "2-4-limit",
                                             'seats': 4,
                                             'player_timeout' : 6, 
                                             'muck_timeout' : 1,
                                             'transient' : True,
                                             'currency_serial': 0
                                             })
        self.table2 = pokertable.PokerTable(service, 202, 
                                           { 'name': "table2",
                                             'variant': "holdem",
                                             'betting_structure': "2-4-limit",
                                             'seats': 4,
                                             'player_timeout' : 6, 
                                             'muck_timeout' : 1,
                                             'transient' : True,
                                             'currency_serial': 0
                                             })
        service.table1 = self.table
        service.table2 = self.table2
        self.clients = {}

    def createPlayer(self, serial, getReadyToPlay=True, clientClass=MockClient, table=None):
        if table == None:
            table = self.table
        client = clientClass(serial)
        self.clients[serial] = client
        table.joinPlayer(client, serial)
        if getReadyToPlay:
            self.assertEqual(True, table.seatPlayer(client, serial, -1))
            table.sitPlayer(client, serial)
        return client

    # -------------------------------------------------------------------
    def test01_autodeal(self):
        """ Transient tables hand deal has a minimum duration if all players are in auto mode """
        self.createPlayer(1)
        self.table.game.autoPlayer(1)
        self.createPlayer(2)
        self.table.game.autoPlayer(2)
        self.table.game_delay["start"] = time.time()
        self.table.scheduleAutoDeal()
        return self.clients[2].waitFor(PACKET_POKER_MESSAGE)
    # -------------------------------------------------------------------
    def test02_autodeal_check(self):
        self.createPlayer(1)
        self.table.processingHand(1)
        self.table.game_delay["delay"] = 2
        self.table.game_delay["start"] = time.time()
        self.createPlayer(2)
        self.table.scheduleAutoDeal()
        return self.clients[2].waitFor(PACKET_POKER_MESSAGE)
    # -------------------------------------------------------------------
    def test04_autodeal_transient_now(self):
        """ Transient tables hand deal has no minium duration if all players are in auto mode but the hand lasted more than the required minium """
        self.createPlayer(1)
        self.table.game.autoPlayer(1)
        self.createPlayer(2)
        self.table.game.autoPlayer(2)
        self.table.game_delay["start"] = time.time() - 300
        self.table.scheduleAutoDeal()
        self.clients[2].raiseIfPacket(PACKET_POKER_MESSAGE)
        return self.clients[2].waitFor(PACKET_POKER_START)
    # -------------------------------------------------------------------
    def test05_autodeal_transient_normal(self):
        """ Transient tables hand deal normaly if at least one player is not in auto mode """
        self.createPlayer(1)
        self.createPlayer(2)
        self.table.scheduleAutoDeal()
        self.clients[2].raiseIfPacket(PACKET_POKER_MESSAGE)
        return self.clients[2].waitFor(PACKET_POKER_START)

    def test08_player_has_trouble_joining(self):
        """Test for when the table is full and a player is trying hard to join"""
        # Do not use serials of 0's here -- pokerengine will hate that. :)
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
        player[5] = self.createPlayer(5, False)

        # player5 can't sit because the table is full of 1-4...
        self.assertEqual(False, self.table.seatPlayer(player[5], 5, -1))

        #  ... but player5 decides to set all sorts of things that she can't
        #      because she's still just an observer.
        self.assertEqual(False, self.table.muckAccept(player[5], 5))
        self.assertEqual(False, self.table.muckDeny(player[5], 5))
        self.assertEqual(False, self.table.autoBlindAnte(player[5], 5, True))
        self.assertEqual(False, self.table.rebuyPlayerRequest(player[5], 30))

        # player5 cannot sit out either because she isn't joined yet.
        self.assertEqual(False, self.table.sitOutPlayer(player[5], 5))

        # player1 leaves on his own...
        self.assertEqual(True, self.table.leavePlayer(player[1], 1))

        # ... which allows player5 to finally join legitimately and change
        # her settings.  However, she tries to sit out before getting the
        # seat, rebuy before even buying, and then buys in for nothing,
        # and thus must rebuy

        self.assertEqual(True, self.table.seatPlayer(player[5], 5, -1))
        self.assertEqual(False, self.table.rebuyPlayerRequest(player[5], 2))

        # this table is transient, so no one can buy in.
        self.assertEqual(False, self.table.buyInPlayer(player[5], 0))

        # I wonder if these should really return True rather than None?  -- bkuhn
        self.assertEqual(None, self.table.muckAccept(player[5], 5))
        self.assertEqual(None, self.table.muckDeny(player[5], 5))
        self.assertEqual(None, self.table.autoBlindAnte(player[5], 5, True))

        self.assertEqual(False, self.table.rebuyPlayerRequest(player[5], \
                                              self.table.game.maxBuyIn()))

        # player2 tries to rebuy but is already at the max, and besides,
        # in transient mode, this doesn't work anyway

        self.assertEqual(False, self.table.rebuyPlayerRequest(player[2], 1))
# -------------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test20"
    os.environ['VERBOSE_T'] = '3'
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerTableTestCase))
    suite.addTest(loader.loadClass(PokerTableTestCaseWithPredefinedDecks))
    suite.addTest(loader.loadClass(PokerTableTestCaseTransient))
    return runner.TrialRunner(reporter.VerboseTextReporter,
#                              tracebackFormat='verbose',
                              tracebackFormat='default',
                              ).run(suite)
# ------------------------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokertable.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokertable.py' TESTS='coverage-reset test-pokertable.py coverage-report' check )"
# End:
