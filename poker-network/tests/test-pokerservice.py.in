#!@PYTHON@
# -*- mode: python -*-
#
# Copyright (C) 2007, 2008 Loic Dachary <loic@dachary.org>
# Copyright (C) 2006 Mekensleep
#
# Mekensleep
# 24 rue vieille du temple
# 75004 Paris
#       licensing@mekensleep.com
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Authors:
#  Loic Dachary <loic@gnu.org>
#  Cedric Pinson <cpinson@freesheep.org>
#
import sys, os
sys.path.insert(0, "@srcdir@/..")
sys.path.insert(0, "..")

from string import split
import libxml2
import random
import sets
from _mysql_exceptions import IntegrityError
from pprint import pprint

from tests import testclock

from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor, defer

twisted.internet.base.DelayedCall.debug = True

from tests.testmessages import silence_all_messages, search_output
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from pokerengine import pokertournament, pokergame
from pokernetwork import pokerservice, pokernetworkconfig, user
from pokernetwork import currencyclient
from pokernetwork import pokerdatabase
currencyclient.CurrencyClient = currencyclient.FakeCurrencyClient
from pokernetwork.pokerpackets import *
from pokernetwork.packets import PacketError

from MySQLdb.cursors import DictCursor

class ConstantDeckShuffler:
    def shuffle(self, what):
        what[:] = [40, 13, 32, 9, 19, 31, 15, 14, 50, 34, 20, 6, 43, 44, 28, 29, 48, 3, 21, 45, 23, 37, 35, 11, 5, 22, 24, 30, 27, 39, 46, 33, 0, 8, 1, 42, 36, 16, 49, 2, 10, 26, 4, 18, 7, 41, 47, 17]

from pokerengine import pokergame
pokergame.shuffler = ConstantDeckShuffler()

class ConstantPlayerShuffler:
    def shuffle(self, what):
        what.sort()

from pokerengine import pokertournament
pokertournament.shuffler = ConstantPlayerShuffler()

settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19480" />

  <refill serial="1" amount="10000000" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="@MYSQL_TEST_DBHOST@" user="pokernetworktest" password="pokernetwork"
            root_user="@MYSQL_TEST_DBROOT@" root_password="@MYSQL_TEST_DBROOT_PASSWORD@" schema="@srcdir@/../../database/schema.sql" command="@MYSQL@" />
  <path>@POKER_ENGINE_PKGSYSCONFDIR@ @POKER_NETWORK_PKGSYSCONFDIR@</path>
  <users temporary="BOT"/>
</server>
"""

def fun_name():
    try:
        raise ZeroDivisionError
    except ZeroDivisionError:
        return sys.exc_info()[2].tb_frame.f_back.f_code.co_name
        
class PokerServiceTestCaseBase(unittest.TestCase):

    def destroyDb(self):
        if len("@MYSQL_TEST_DBROOT_PASSWORD@") > 0:
            os.system("@MYSQL@ -u @MYSQL_TEST_DBROOT@ --password='@MYSQL_TEST_DBROOT_PASSWORD@' -h '@MYSQL_TEST_DBHOST@' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("@MYSQL@ -u @MYSQL_TEST_DBROOT@ -h '@MYSQL_TEST_DBHOST@' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        
    # ----------------------------------------------------------------
    def setUp(self):
        testclock._seconds_reset()        
        self.destroyDb()
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        settings.header = settings.doc.xpathNewContext()
        self.db = pokerdatabase.PokerDatabase(settings)
        self.service = pokerservice.PokerService(settings)
        self.default_money = 10000000
#        self.service.verbose = 0
#        self.service.verbose = 4

    # ----------------------------------------------------------------
    def tearDown(self):
        d = self.service.stopService()
#        d.addCallback(lambda x: self.destroyDb())
        return d

    # ----------------------------------------------------------------
    def createUsers(self):
        cursor = self.db.cursor()
        for user_number in (1, 2, 3):
            cursor.execute("INSERT INTO users (name, password, created) VALUES ('user%d', 'password%d', 0)" % ( user_number, user_number ))
            self.assertEqual(1, cursor.rowcount)

        ( (self.user1_serial, name, privilege), message ) = self.service.auth("user1", "password1", "role1")
        ( (self.user2_serial, name, privilege), message ) = self.service.auth("user2", "password2", "role1")
        ( (self.user3_serial, name, privilege), message ) = self.service.auth("user3", "password3", "role1")

        for user_number in (self.user1_serial, self.user2_serial, self.user3_serial):
            if self.default_money > 0 and user_number == self.user3_serial:
                cursor.execute("INSERT INTO user2money (user_serial, currency_serial, amount) VALUES (%d, 2, %d)" % ( user_number, self.default_money ) )
                self.assertEqual(1, cursor.rowcount)

        cursor.close()

class MonitorTestCase(PokerServiceTestCaseBase):

    # ----------------------------------------------------------------
    def test01_monitor(self):
        self.service.startService()
        test = self
        class Avatar:
            protocol = True
            def sendPacketVerbose(self, packet):
                test.assertEquals(PACKET_POKER_MONITOR_EVENT, packet.type)
                test.assertEquals(1, packet.event)
                test.assertEquals(2, packet.param1)
                test.assertEquals(3, packet.param2)
                self.sent = True
        avatar = Avatar()
        self.assertEquals(PACKET_ACK, self.service.monitor(avatar).type)
        self.service.databaseEvent(event = 1, param1 = 2, param2 = 3)
        self.failUnless(avatar.sent)
        cursor = self.db.cursor()
        cursor.execute("SELECT COUNT(*) FROM monitor WHERE event = 1")
        self.assertEquals(1, cursor.rowcount)

class PokerServiceTestCase(PokerServiceTestCaseBase):

    # ----------------------------------------------------------------
    def test01_auth(self):
        self.service.startService()
        ( (serial, name, privilege), message ) = self.service.auth("user1", "password1", "role1")
        self.assertEquals(None, message)
        self.assertEquals(4, serial)
        self.assertEquals("user1", name)
        self.assertEquals(user.User.REGULAR, privilege)

    # ----------------------------------------------------------------
    def test01_auth_invalid_login(self):
        self.service.startService()
        self.service.poker_auth.auto_create_account = False
        ( status, message ) = self.service.auth("user1", "password1", sets.Set("role1"))
        self.assertEquals("Invalid login or password", message)
        self.assertEquals(False, status)

    # ----------------------------------------------------------------
    def test01_auth_already_logged(self):
        class Client:
            def __init__(self):
                self.roles = sets.Set('role1')
            def getName(self):
                return "user1"

        self.service.startService()
        ( (serial, name, privilege), message ) = self.service.auth("user1", "password1", sets.Set('role1'))
        self.service.serial2client[serial] = Client()
        ( status, message ) = self.service.auth("user1", "password1", sets.Set('role1'))
        self.assertEquals('Already logged in from somewhere else', message)
        self.assertEquals(False, status)
            
    # ----------------------------------------------------------------
    def cashIn(self):

        self.currency1_serial = 1
        note1 = self.service.cashier.currency_client._buildNote("ONE", 100)
        packet1 = PacketPokerCashIn(serial = self.user1_serial,
                                    url = note1[0],
                                    bserial = note1[1],
                                    name = note1[2],
                                    value = note1[3])
        d1 = self.service.cashIn(packet1)

        note2 = self.service.cashier.currency_client._buildNote("ONE", 100)
        packet2 = PacketPokerCashIn(serial = self.user2_serial,
                                    url = note2[0],
                                    bserial = note2[1],
                                    name = note2[2],
                                    value = note2[3])
        d2 = self.service.cashIn(packet2)

        self.currency2_serial = 2
        note3 = self.service.cashier.currency_client._buildNote("TWO", 200)
        packet3 = PacketPokerCashIn(serial = self.user2_serial,
                                    url = note3[0],
                                    bserial = note3[1],
                                    name = note3[2],
                                    value = note3[3])
        d3 = self.service.cashIn(packet3)

        return defer.DeferredList((d1, d2, d3), fireOnOneErrback = True)

    # ----------------------------------------------------------------
    def test04_getUserInfo(self):
        self.service.startService()
        self.service.refill = None

        self.default_money = 0
        self.createUsers()
        #
        # No cash in means no money
        #
        info = self.service.getUserInfo(self.user1_serial)
        self.assertEqual(0, len(info.money))

        def step2(result):
            self.assertEquals([ (True, PacketAck()), (True, PacketAck()), (True, PacketAck()) ], result)
            info = self.service.getUserInfo(self.user2_serial)
            self.assertEquals({1: (100, 0, 0), 2: (200, 0, 0)}, info.money)

            #
            # Some money is on a table
            #
            table_serial = self.service.tables[0].game.id
            buy_in = 50
            currency_serial = 1
            self.assertEquals(currency_serial, self.service.tables[0].currency_serial)
            self.service.seatPlayer(self.user2_serial, table_serial, 0)
            self.service.buyInPlayer(self.user2_serial, table_serial, currency_serial, buy_in)
            info = self.service.getUserInfo(self.user2_serial)
            self.assertEquals({1: (50, 50, 0), 2: (200, 0, 0)}, info.money)
            #
            # The other player only has one currency
            #
            self.service.seatPlayer(self.user1_serial, table_serial, 0)
            self.service.buyInPlayer(self.user1_serial, table_serial, currency_serial, buy_in)
            info = self.service.getUserInfo(self.user1_serial)
            self.assertEquals({1: (50, 50, 0)}, info.money)

            return result
            
        d = self.cashIn()
        d.addCallback(step2)
        return d
    test04_getUserInfo.timeout = 500
    
    # ----------------------------------------------------------------
    def test05_getPersonalInfo(self):
        self.service.startService()

        self.createUsers()
        info = self.service.getPersonalInfo(self.user1_serial)
        self.assertEquals(self.user1_serial, info.serial)
        
    def cashOutCommit(self, packet):
        packet = PacketPokerCashOutCommit(transaction_id = packet.name)
        self.assertEquals(PacketAck(), self.service.cashOutCommit(packet))
        return 1
    
    def cashOut(self, result):
        self.assertEquals([ (True, PacketAck()), (True, PacketAck()), (True, PacketAck()) ], result)
        packet = PacketPokerCashOut(serial = self.user1_serial,
                                    url = "ONE",
                                    value = 30)
        def validate(packet):
            self.assertEquals("ONE", packet.url)
            self.assertEquals(30, packet.value)
            return packet
        
        d = self.service.cashOut(packet)
        d.addCallback(validate)
        d.addCallback(self.cashOutCommit)
        return d
                
    # ----------------------------------------------------------------
    def test07_cashOut(self):
        self.service.startService()

        self.createUsers()
        d = self.cashIn()
        d.addCallback(self.cashOut)
        return d

    # ----------------------------------------------------------------

    class ClientMockup:
        def __init__(self):
            self.packet_end_tournament = None
        def sendPacketVerbose(self, packet):
            self.packet_end_tournament = packet
            
    class TableMockup:
        def __init__(self):
            self.serial = None
        def kickPlayer(self, serial):
            self.kick_player = serial

    class TourneyMockup:
        def __init__(self):
            self.call_rank = None
            self.serial = 10
            self.schedule_serial = 1
            self.players = [0, 2, 4]
            self.prize = [10,20,30]
            self.rank = 10
        def getRank(self, serial):
            return self.rank
        
        def prizes(self):
            return self.prize
        

    def test09_endOfTournamentsNotInPlayers(self):
        self.service.startService()
        self.createUsers()
        
        table = self.TableMockup()
        kickplayer = None
        def getTableMockup( game_id):
            return table

        tourney = self.TourneyMockup()
        self.service.client = self.ClientMockup()
        self.service.getTable = getTableMockup
        self.service.tourneyRemovePlayer(tourney, 0, self.user1_serial)
        self.assertEquals(self.service.client.packet_end_tournament == None, True)

    def test10_endOfTournamentsNoPrize(self):
        self.service.startService()
        self.createUsers()
        
        table = self.TableMockup()
        kickplayer = None
        def getTableMockup( game_id):
            return table

        tourney = self.TourneyMockup()
        tourney.players = [2, self.user1_serial, 10]
        client = self.ClientMockup()
        self.service.serial2client[self.user1_serial] = client
        self.service.getTable = getTableMockup
        self.service.tourneyRemovePlayer(tourney, 0, self.user1_serial)
        self.assertEquals(client.packet_end_tournament != None, True)
        self.assertEquals(client.packet_end_tournament.serial == tourney.serial, True)
        self.assertEquals(client.packet_end_tournament.money == 0, True)
        self.assertEquals(client.packet_end_tournament.rank == 10, True)
        self.assertEquals(client.packet_end_tournament.players == 3, True)

    def test11_endOfTournamentsPrize(self):
        self.service.startService()
        self.createUsers()
        
        table = self.TableMockup()
        kickplayer = None
        def getTableMockup( game_id):
            return table

        tourney = self.TourneyMockup()
        tourney.rank = 2
        client = self.ClientMockup()
        self.service.serial2client[self.user1_serial] = client
        self.service.getTable = getTableMockup
        self.service.tourneyRemovePlayer(tourney, 0, self.user1_serial)
        self.assertEquals(client.packet_end_tournament != None, True)
        self.assertEquals(client.packet_end_tournament.serial == tourney.serial, True)
        self.assertEquals(client.packet_end_tournament.money == 20, True)
        self.assertEquals(client.packet_end_tournament.rank == 2, True)
        self.assertEquals(client.packet_end_tournament.players == 3, True)


    # ----------------------------------------------------------------
    def test12_playerImage(self):
        self.service.startService()

        self.createUsers()
        player_image1 = PacketPokerPlayerImage(serial = self.user1_serial,
                                               image = "12345")
        self.assertEquals(True, self.service.setPlayerImage(player_image1))
        player_image2 = self.service.getPlayerImage(self.user1_serial)
        self.assertEquals(player_image1.image, player_image2.image)
        player_image2 = self.service.getPlayerImage(self.user2_serial)
        self.assertEquals("", player_image2.image)
        
    # ----------------------------------------------------------------
    def test13_checkTourneysSchedule_spawn_regular(self):
        pokerservice.UPDATE_TOURNEYS_SCHEDULE_DELAY = 1
        pokerservice.CHECK_TOURNEYS_SCHEDULE_DELAY = 0.5

        #
        # A regular tournament starts registration now
        #
        cursor = self.db.cursor()
        cursor.execute("UPDATE tourneys_schedule SET register_time = UNIX_TIMESTAMP(NOW() + INTERVAL 1 SECOND) WHERE name = 'regular1'")
        self.assertEqual(1, cursor.rowcount)
        cursor.close()

        self.service.startService()
        d = defer.Deferred()
        def checkTourneys(status):
            self.failUnless(filter(lambda tourney: tourney.sit_n_go == 'n', self.service.tourneys.values()))
            self.failUnless(filter(lambda tourney: tourney.name == 'regular1', self.service.tourneys.values()))
        d.addCallback(checkTourneys)
        reactor.callLater(3, lambda: d.callback(True))

        return d
        
    # ----------------------------------------------------------------
    def test14_checkTourneysSchedule_cancel_regular(self):
        pokerservice.DELETE_OLD_TOURNEYS_DELAY = 0
        pokerservice.UPDATE_TOURNEYS_SCHEDULE_DELAY = 1
        pokerservice.CHECK_TOURNEYS_SCHEDULE_DELAY = 0.1

        #
        # A regular tournament starts registration now
        #
        cursor = self.db.cursor()
        cursor.execute("UPDATE tourneys_schedule " + 
                       " SET register_time = " + str(testclock._seconds_value) + ", " +
                       "     start_time = " + str(testclock._seconds_value + 10) + ", " + 
                       "     respawn = 'n' " + 
                       " WHERE name = 'regular1'")
        self.assertEqual(1, cursor.rowcount)
        cursor.close()

        self.service.startService()
        self.createUsers()

        #
        # Register a user who will be re-imbursed when the tournament is canceled
        #
        d1 = defer.Deferred()
        def registerPlayer(status):
            (regular,) = filter(lambda tourney: tourney.name == 'regular1', self.service.tourneys.values())
            self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                    game_id = regular.serial))
            self.assertEquals(self.default_money - regular.buy_in - regular.rake, self.service.getMoney(self.user1_serial, 1))
            self.assertEquals([ self.user1_serial ], regular.players)
            
        d1.addCallback(registerPlayer)
        reactor.callLater(5, lambda: d1.callback(True))

        d2 = defer.Deferred()
        def checkTourneys(status):
            self.assertEquals([], filter(lambda tourney: tourney['name'] == 'regular1', self.service.tourneys_schedule.values()))
            self.assertEquals([], filter(lambda tourney: tourney.name == 'regular1', self.service.tourneys.values()))
            self.assertEquals(self.default_money, self.service.getMoney(self.user1_serial, 1))
        d2.addCallback(checkTourneys)
        reactor.callLater(15, lambda: d2.callback(True))

        return defer.DeferredList((d1, d2), fireOnOneErrback = True)
        
    # ----------------------------------------------------------------
    def test15_runTourney(self):
        pokerservice.UPDATE_TOURNEYS_SCHEDULE_DELAY = 1
        pokerservice.CHECK_TOURNEYS_SCHEDULE_DELAY = 0.1

        self.service.startService()
        self.createUsers()

        (heads_up,) = filter(lambda tourney: tourney.name == 'sitngo2', self.service.tourneys.values())
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = heads_up.serial))
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user2_serial,
                                                                game_id = heads_up.serial))
                                     
        d = defer.Deferred()
        def checkTourneys(status):
            self.assertEquals(pokertournament.TOURNAMENT_STATE_RUNNING, heads_up.state)
            game = heads_up.games[0]
            in_position = game.getSerialInPosition()
            game.callNraise(in_position, game.maxBuyIn())
            in_position = game.getSerialInPosition()
            game.call(in_position)
            self.service.tables[2].update() # two tables already in settings
            
        d.addCallback(checkTourneys)
        reactor.callLater(3, lambda: d.callback(True))

        return d

    # ----------------------------------------------------------------
    def test16_runTourney_freeroll(self):
        return self.runTourney_freeroll(True)

    # ----------------------------------------------------------------
    def test17_runTourney_freeroll(self):
        return self.runTourney_freeroll(False)

    # ----------------------------------------------------------------
    def runTourney_freeroll(self, has_bailor):
        pokerservice.UPDATE_TOURNEYS_SCHEDULE_DELAY = 1
        pokerservice.CHECK_TOURNEYS_SCHEDULE_DELAY = 0.1

        #
        # A regular tournament starts registration now
        #
        cursor = self.db.cursor()
        prize = 100
        cursor.execute("UPDATE tourneys_schedule SET currency_serial = 2, buy_in = 0, prize_min = %d WHERE name = 'sitngo2'" % prize )
        self.assertEqual(1, cursor.rowcount)
        cursor.close()

        self.service.startService()
        self.createUsers()

        (heads_up,) = filter(lambda tourney: tourney.name == 'sitngo2', self.service.tourneys.values())
        if has_bailor:
            heads_up.bailor_serial = self.user3_serial 
        else:
            heads_up.bailor_serial = 42

        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = heads_up.serial))
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user2_serial,
                                                                game_id = heads_up.serial))
                                     
        d = defer.Deferred()
        def checkTourneys(status):
            self.assertEquals(pokertournament.TOURNAMENT_STATE_RUNNING, heads_up.state)
            game = heads_up.games[0]
            in_position = game.getSerialInPosition()
            game.callNraise(in_position, game.maxBuyIn())
            in_position = game.getSerialInPosition()
            game.call(in_position)
            self.service.tables[2].update() # two tables already in settings
            if has_bailor:
                self.assertEquals(0, self.service.getMoney(self.user1_serial, 2), "bailor user1")
                self.assertEquals(prize, self.service.getMoney(self.user2_serial, 2), "bailor user2")
                self.assertEquals(self.default_money - prize, self.service.getMoney(self.user3_serial, 2), "bailor user3")
            else:
                self.assertEquals(0, self.service.getMoney(self.user1_serial, 2))
                self.assertEquals(0, self.service.getMoney(self.user2_serial, 2))
                self.assertEquals(self.default_money, self.service.getMoney(self.user3_serial, 2))
            
        d.addCallback(checkTourneys)
        reactor.callLater(3, lambda: d.callback(True))

        return d
        
    # ----------------------------------------------------------------
    def test18_cleanupTourneys_registering(self):
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO tourneys (serial, name, start_time) VALUES (4000, 'regular3', " + str(testclock._seconds_value + 120) + ")")
        cursor.execute("INSERT INTO user2tourney VALUES (1, 4000, 0, -1)")
        cursor.execute("INSERT INTO user2tourney VALUES (2, 4000, 0, -1)")
        cursor.execute("INSERT INTO user2tourney VALUES (3, 4000, 0, -1)")
        cursor.close()
        self.service.db = self.db
        self.service.dirs = ['@POKER_ENGINE_PKGSYSCONFDIR@']
        self.service.cleanupTourneys()
        tourney = self.service.tourneys[4000]
        self.assertEqual([1, 2, 3], tourney.players)

class RefillTestCase(unittest.TestCase):

    def destroyDb(self):
        if len("@MYSQL_TEST_DBROOT_PASSWORD@") > 0:
            os.system("@MYSQL@ -u @MYSQL_TEST_DBROOT@ --password='@MYSQL_TEST_DBROOT_PASSWORD@' -h '@MYSQL_TEST_DBHOST@' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("@MYSQL@ -u @MYSQL_TEST_DBROOT@ -h '@MYSQL_TEST_DBHOST@' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        
    def setUp(self):
        settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
        <server verbose="3">
        <listen tcp="19480" />
        <refill serial="1" amount="10000" />
        <delays />
        <path>@POKER_ENGINE_PKGSYSCONFDIR@ @POKER_NETWORK_PKGSYSCONFDIR@</path>
        <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
        <database name="pokernetworktest" host="@MYSQL_TEST_DBHOST@" user="pokernetworktest" password="pokernetwork"
            root_user="@MYSQL_TEST_DBROOT@" root_password="@MYSQL_TEST_DBROOT_PASSWORD@" schema="@srcdir@/../../database/schema.sql" command="@MYSQL@" />
        </server>
        """
        testclock._seconds_reset()        
        self.destroyDb()
        self.service = pokerservice.PokerService(settings_xml)

    def tearDown(self):
        d = self.service.stopService()
        d.addCallback(lambda x: self.destroyDb())
        return d

    def test_refill(self):
        self.service.startService()
        refill = 10000
        ( (serial, name, privilege), message ) = self.service.auth("user1", "password1", "role1")
        self.assertEquals(0, self.service.autorefill(serial))
        table_money = 1000
        table_serial = 200
        self.service.db.db.query("INSERT INTO user2table VALUES (" + str(serial) + ", " + str(table_serial) + ", " + str(table_money) + ", 0)")
        self.service.db.db.query("INSERT INTO pokertables VALUES (" + str(table_serial) + ", 'foo', 1, 0)")
        money_left = 100
        self.service.db.db.query("UPDATE user2money SET amount = " + str(money_left) + " WHERE user_serial = " + str(serial))
        self.assertEquals(refill - table_money, self.service.autorefill(serial))
    
class TimerTestCase(unittest.TestCase):

    def test_cancelTimers(self):
        settings = """<?xml version="1.0" encoding="ISO-8859-1"?>
        <server verbose="3">
        <delays />
        </server>
        """
        service = pokerservice.PokerService(settings)
        class Timer:
            def active(self):
                return False
        service.timer['foo_1'] = Timer()
        service.timer['foo_2'] = Timer()
        service.cancelTimers('foo')
        self.assertEqual([], service.timer.keys())
    
class TourneyUnregisterTestCase(PokerServiceTestCaseBase):

    def test_ok(self):
        tourney_serial = 100
        self.service.startService()
        self.createUsers()
        user_serial = self.user1_serial
        tourney = pokertournament.PokerTournament(serial = tourney_serial,
                                                  dirs = ['@POKER_ENGINE_PKGSYSCONFDIR@'])
        tourney.currency_serial = 1
        self.service.tourneys[tourney_serial] = tourney
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = tourney_serial))
        packet = PacketPokerId(serial = user_serial,
                               game_id = tourney_serial)
        return_packet = self.service.tourneyUnregister(packet)
        self.assertEqual(packet, return_packet)
        
    def test_does_not_exist(self):
        tourney_serial = 100
        user_serial = 1
        self.service.startService()
        p = self.service.tourneyUnregister(PacketPokerId(serial = user_serial,
                                                         game_id = tourney_serial))
        self.assertEqual(PacketPokerTourneyUnregister.DOES_NOT_EXIST, p.code)
        
    def test_not_registered(self):
        tourney_serial = 100
        user_serial = 1
        self.service.startService()
        tourney = pokertournament.PokerTournament(serial = tourney_serial,
                                                  dirs = ['@POKER_ENGINE_PKGSYSCONFDIR@'])
        self.service.tourneys[tourney_serial] = tourney
        p = self.service.tourneyUnregister(PacketPokerId(serial = user_serial,
                                                         game_id = tourney_serial))
        self.assertEqual(PacketPokerTourneyUnregister.NOT_REGISTERED, p.code)
        
    def test_too_late(self):
        tourney_serial = 100
        user_serial = 1
        self.service.startService()
        tourney = pokertournament.PokerTournament(serial = tourney_serial,
                                                  dirs = ['@POKER_ENGINE_PKGSYSCONFDIR@'])
        tourney.register(user_serial)
        tourney.currency_serial = 1
        tourney.state = pokertournament.TOURNAMENT_STATE_RUNNING
        self.service.tourneys[tourney_serial] = tourney
        p = self.service.tourneyUnregister(PacketPokerId(serial = user_serial,
                                                         game_id = tourney_serial))
        self.assertEqual(PacketPokerTourneyUnregister.TOO_LATE, p.code)
        
    def test_no_user2money(self):
        tourney_serial = 100
        user_serial = 1
        self.service.startService()
        tourney = pokertournament.PokerTournament(serial = tourney_serial,
                                                  dirs = ['@POKER_ENGINE_PKGSYSCONFDIR@'])
        tourney.register(user_serial)
        tourney.currency_serial = 1
        tourney.buy_in = 1000
        self.service.tourneys[tourney_serial] = tourney
        p = self.service.tourneyUnregister(PacketPokerId(serial = user_serial,
                                                         game_id = tourney_serial))
        self.assertEqual(PacketPokerTourneyUnregister.SERVER_ERROR, p.code)
        self.assertTrue("not in user2money" in p.message)
        
    def test_no_user2tourney(self):
        tourney_serial = 100
        self.service.startService()
        self.createUsers()
        user_serial = self.user1_serial
        tourney = pokertournament.PokerTournament(serial = tourney_serial,
                                                  dirs = ['@POKER_ENGINE_PKGSYSCONFDIR@'])
        tourney.register(user_serial)
        tourney.currency_serial = 1
        self.service.tourneys[tourney_serial] = tourney
        p = self.service.tourneyUnregister(PacketPokerId(serial = user_serial,
                                                         game_id = tourney_serial))
        self.assertEqual(PacketPokerTourneyUnregister.SERVER_ERROR, p.code)
        self.assertTrue("not in user2tourney" in p.message)
        
class TourneyCancelTestCase(PokerServiceTestCaseBase):
    def test_ok(self):
        class Tournament:
            def __init__(self):
                self.players = [1]
                self.serial = 1

        self.service.tourneys = {}
        self.service.tourneyCancel(Tournament())
        if verbose < 0:
            self.assertTrue(search_output('tourneyCancel:'))

class TourneyManagerTestCase(PokerServiceTestCaseBase):

    def test_no_rank(self):
        self.service.startService()
        self.createUsers()
        user_serial = self.user1_serial
        table_serial = 606
        table_money = 140
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        self.service.spawnTourney(schedule)
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = tourney_serial))
        self.service.db.db.query("INSERT INTO user2table VALUES (" + str(self.user1_serial) + ", " + str(table_serial) + ", " + str(table_money) + ", 0)")
        self.service.db.db.query("UPDATE user2tourney SET table_serial = " + str(table_serial))
        self.service.tourneys[tourney_serial].can_register = False
        packet = self.service.tourneyManager(tourney_serial)
        self.assertEqual(tourney_serial, packet.tourney['serial'])        
        self.assertNotEqual(None, packet.tourney['rank2prize'])
        self.assertEqual(1, packet.tourney['registered'])
        self.assertEqual({'4' : {'rank': -1,
                                 'table_serial': table_serial,
                                 'name' : 'user1',
                                 'money': table_money}}, packet.user2properties)
        print Packet.JSON.encode(packet.__dict__)

    def test_no_money_no_table(self):
        self.service.startService()
        self.createUsers()
        user_serial = self.user1_serial
        table_serial = 606
        table_money = 140
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        self.service.spawnTourney(schedule)
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = tourney_serial))
        packet = self.service.tourneyManager(tourney_serial)
        self.assertEqual(tourney_serial, packet.tourney['serial'])
        self.assertEqual(1, packet.tourney['registered'])
        self.assertEqual({'4' : {'rank': -1,
                                 'table_serial': None,
                                 'name' : 'user1',
                                 'money': -1}}, packet.user2properties)
        print Packet.JSON.encode(packet.__dict__)

class TourneyMovePlayerTestCase(PokerServiceTestCaseBase):

    tourney_serial = 10

    class Tournament:
        def __init__(self):
            self.serial = TourneyMovePlayerTestCase.tourney_serial

    class Table:
        def __init__(self):
            self.serial2client = {}
            
        def movePlayer(self, client, serial, to_game_id):
            pass

    def test_ok(self):
        self.service.startService()
        self.service.getTable = lambda from_game_id: TourneyMovePlayerTestCase.Table()
        user_serial = 1
        table_serial = 100
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO user2tourney (user_serial, tourney_serial, table_serial) VALUES (%d, %d, %d)" % ( user_serial, TourneyMovePlayerTestCase.tourney_serial, table_serial ))
        self.assertTrue(self.service.tourneyMovePlayer(TourneyMovePlayerTestCase.Tournament(), table_serial, 200, user_serial))
        cursor.close()

    def test_missing_db_record(self):
        self.service.startService()
        self.service.getTable = lambda from_game_id: TourneyMovePlayerTestCase.Table()
        user_serial = 1
        table_serial = 100
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO user2tourney (user_serial, tourney_serial, table_serial) VALUES (%d, %d, %d)" % ( user_serial, TourneyMovePlayerTestCase.tourney_serial, table_serial ))
        wrong_user_serial = 2
        self.assertFalse(self.service.tourneyMovePlayer(TourneyMovePlayerTestCase.Tournament(), table_serial, 200, wrong_user_serial))
        cursor.close()
        
class ListHandsTestCase(PokerServiceTestCaseBase):

    def test_ok(self):
        self.service.startService()
        ( total, hands ) = self.service.listHands("SELECT '1'", "SELECT '2'")
        self.assertEqual(["1"], hands)
        self.assertEqual("2", total)

class SetAccountTestCase(PokerServiceTestCaseBase):

    def test_insert_ok(self):
        self.service.startService()
        affiliate = 3
        info = self.service.setAccount(PacketPokerSetAccount(name = 'test08_1',
                                                             password = 'PASSWORD',
                                                             email = 'test08_1@HOME.COM',
                                                             affiliate = affiliate,
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        self.assertEquals(affiliate, info.affiliate)
        packed = info.pack()
        other_info = PacketPokerPersonalInfo()
        other_info.unpack(packed)
        self.assertEquals('1980-01-01', other_info.birthdate)

    def test_update_ok(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                             password = 'password1',
                                                             email = 'a@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        serial = info.serial
        info = self.service.setAccount(PacketPokerSetAccount(serial = serial,
                                                             name = 'user1',
                                                             password = 'password2',
                                                             email = 'a@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)

    def test_setPersonalInfo_fail(self):
        self.service.startService()
        self.service.setPersonalInfo = lambda x: False
        info = self.service.setAccount(PacketPokerSetAccount(name = 'test08_1',
                                                             password = 'PASSWORD',
                                                             email = 'test08_1@HOME.COM',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals("unable to set personal information", info.message)
        self.assertEquals(PacketPokerSetAccount.SERVER_ERROR, info.code)

    def test_name_already_exists(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                             password = 'password1',
                                                             email = 'a@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        serial = info.serial
        info = self.service.setAccount(PacketPokerSetAccount(serial = 10001,
                                                             email = 'a@b.c',
                                                             name = 'user1'))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.NAME_ALREADY_EXISTS, info.code)

    def test_email_already_exists(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                             password = 'password1',
                                                             email = '1@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        serial = info.serial
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user2',
                                                             password = 'password2',
                                                             email = '2@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        info = self.service.setAccount(PacketPokerSetAccount(serial = serial,
                                                             name = 'user1',
                                                             email = '2@b.c'))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.EMAIL_ALREADY_EXISTS, info.code)

    def test_update_duplicate_serial(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                             password = 'password1',
                                                             email = 'a@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        serial = info.serial
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user2',
                                                             password = 'password2',
                                                             email = '2@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        cursor = self.db.cursor()
        cursor.execute('ALTER TABLE users CHANGE COLUMN serial s1 INT UNSIGNED NOT NULL AUTO_INCREMENT')
        cursor.execute('ALTER TABLE users ADD COLUMN serial INT UNSIGNED NOT NULL')
        cursor.execute('DROP INDEX name_idx ON users')
        cursor.execute('DROP INDEX email_idx ON users')
        cursor.execute('UPDATE users SET serial = %d' % serial)
        info = self.service.setAccount(PacketPokerSetAccount(serial = serial,
                                                             name = 'user1',
                                                             password = 'password4',
                                                             email = 'a@b.c'))
        self.assertEquals(info.type, PACKET_ERROR)
        self.assertEquals(PacketPokerSetAccount.SERVER_ERROR, info.code)
        
    def test_name_error(self):
        info = self.service.setAccount(PacketPokerSetAccount(name = 'ab'))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.NAME_TOO_SHORT, info.code)
        
    def test_password_error(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'abcdef',
                                                             password = ''))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.PASSWORD_TOO_SHORT, info.code)
        
    def test_email_error(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'abcdef',
                                                             password = 'ABCDEF',
                                                             email = ''))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.INVALID_EMAIL, info.code)
        
    def test_email_duplicate(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                             password = 'password1',
                                                             email = 'a@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user2',
                                                             password = 'password2',
                                                             email = 'a@b.c'))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.EMAIL_ALREADY_EXISTS, info.code)
        
    def test_user_private_duplicate(self):
        self.service.startService()
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO users_private (serial) VALUES (4)")
        cursor.close()
        raised = False
        try:
            info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                                 password = 'password1',
                                                                 email = 'a@b.c',
                                                                 birthdate = '1980/01/01'))
        except IntegrityError:
            raised = True
        self.assertTrue(raised)
        
class ShutdownCheckTestCase(PokerServiceTestCaseBase):

    class PokerGame:
        def isEndOrNull(self):
            return not self.playing
    
    class PokerTable:
        def __init__(self):
            self.game = ShutdownCheckTestCase.PokerGame()
                

    def tearDown(self):
        pass
    
    def test_down(self):
        self.deferred_called = False
        def c(x):
            self.deferred_called = True
        d = defer.Deferred()
        d.addCallback(c)
        self.service.shutdown_deferred = d
        self.service.down = True
        self.service.shutdownCheck()
        self.assertTrue(self.deferred_called)
        del self.deferred_called

    def test_ok(self):
        table = ShutdownCheckTestCase.PokerTable()
        table.game.playing = True
        self.service.tables = [ table ]
        self.service.down = False
        d = defer.Deferred()
        self.service.shutdown_deferred = d
        self.service.shutdownCheck()
        self.assertEqual(d, self.service.shutdown_deferred)
        table.game.playing = False
        def f(status):
            self.assertTrue(self.service.down)
            return status
        d.addCallback(f)
        return d
    
class TourneyFinishedTestCase(PokerServiceTestCaseBase):

    def test_ok(self):
        class Tournament:
            def __init__(self):
                self.prize_min = 10
                self.buy_in = 0
                self.registered = 2
                self.currency_serial = 1
                self.serial = 1
                
            def prizes(self):
                return [self.prize_min]
        self.service.startService()
        self.createUsers()
        tournament = Tournament()
        winner_serial = 10
        tournament.winners = [ winner_serial ]
        tournament.bailor_serial = self.user2_serial
        self.service.tourneyFinished(tournament)
        cursor = self.db.cursor()
        cursor.execute("SELECT amount FROM user2money WHERE user_serial = %d" % winner_serial)
        (amount,) = cursor.fetchone()
        self.assertEqual(tournament.prize_min, amount)
        cursor.close()
        
    def test_no_bailor(self):
        class Tournament:
            def __init__(self):
                self.prize_min = 10
                self.buy_in = 0
                self.registered = 2
                self.currency_serial = 1
                self.serial = 1
                
            def prizes(self):
                return [self.prize_min]
        self.service.startService()
        self.createUsers()
        tournament = Tournament()
        winner_serial = 10
        tournament.winners = [ winner_serial ]
        tournament.bailor_serial = 2000
        self.assertEqual(False, self.service.tourneyFinished(tournament))
        if verbose < 0:
            self.assertTrue(search_output("bailor failed to provide requested money"))
        
class BreakTestCase(PokerServiceTestCaseBase):

    def test_tourneyNewState(self):
        class Database:

            class Cursor:
                def execute(self, sql):
                    self.sql = sql
                    self.rowcount = 1

                def close(self):
                    pass

            def cursor(self):
                self._cursor = Database.Cursor()
                return self._cursor

            def close(self):
                pass

        class Tournament:
            def __init__(self):
                self.serial = 1
                self.start_time = 1
            
        def ok(tourney):
            pass

        def notok(tourney):
            self.failIf(1)

        self.service.db = Database()
        self.service.tourneyBreakCheck = notok
        self.service.tourneyDeal = notok
        self.service.tourneyBreakWait = notok
        self.service.tourneyBreakResume = notok

        self.service.tourneyBreakCheck = ok
        self.service.tourneyNewState(Tournament(), pokertournament.TOURNAMENT_STATE_RUNNING, pokertournament.TOURNAMENT_STATE_BREAK)
        self.service.tourneyBreakCheck = notok

        self.service.tourneyDeal = ok
        self.service.tourneyNewState(Tournament(), pokertournament.TOURNAMENT_STATE_REGISTERING, pokertournament.TOURNAMENT_STATE_RUNNING)
        self.service.tourneyDeal = notok

        self.service.tourneyBreakWait = ok
        self.service.tourneyNewState(Tournament(), pokertournament.TOURNAMENT_STATE_RUNNING, pokertournament.TOURNAMENT_STATE_BREAK_WAIT)
        self.service.tourneyBreakWait = notok

        self.service.tourneyBreakResume = ok
        self.service.tourneyDeal = ok
        self.service.tourneyNewState(Tournament(), pokertournament.TOURNAMENT_STATE_BREAK, pokertournament.TOURNAMENT_STATE_RUNNING)
        self.service.tourneyDeal = notok
        self.service.tourneyBreakResume = notok
        
    def test_tourneyDeal(self):
        class Game:
            
            def __init__(self):
                self.id = 1

        class Tournament:
            def __init__(self):
                self.games = [ Game() ]
                self.serial = 1
                
        class Table:
            def scheduleAutoDeal(self):
                self.autodeal = 1

        tourney = Tournament()
        table = Table()
        table.game = tourney.games[0]
        self.service.tables = [ table ]
        self.service.tourneyDeal(tourney)
        self.failUnless(hasattr(table, 'autodeal'))

    def test_tourneyBreakWait(self):
        class Game:
            
            def __init__(self):
                self.id = 1
                self.running = False

            def isRunning(self):
                return self.running

        class Tournament:
            def __init__(self):
                self.games = [ Game() ]
                self.serial = 1
                
        class Table:
            def __init__(self):
                self.message = None
                
            def broadcastMessage(self, type, message):
                self.message = message

        tourney = Tournament()
        table = Table()
        table.game = tourney.games[0]
        self.service.tables = [ table ]
        tourney.games[0].running = True
        self.service.tourneyBreakWait(tourney)
        self.failUnless("at the end of the hand" in table.message)
        tourney.games[0].running = False
        self.service.tourneyBreakWait(tourney)
        self.failUnless("finish their hand" in table.message)

    def test_tourneyBreakResume(self):
        class Game:
            
            def __init__(self):
                self.id = 1

        class Tournament:
            def __init__(self):
                self.games = [ Game() ]
                self.serial = 1
                
        class Table:
            def __init__(self):
                self.message = None
                
            def broadcastMessage(self, type, message):
                self.message = message

        tourney = Tournament()
        table = Table()
        table.game = tourney.games[0]
        self.service.tables = [ table ]
        self.service.tourneyBreakResume(tourney)
        self.failUnless("Tournament resumes" in table.message)

    def test_tourneyBreakCheck(self):

        class Game:
            
            def __init__(self):
                self.id = 1
                
        class Tournament:
            
            def __init__(self):
                self.state = pokertournament.TOURNAMENT_STATE_RUNNING
                self.remaining = 0
                self.games = [ Game() ]
                self.serial = 1

            def remainingBreakSeconds(self):
                return self.remaining

            def updateBreak(self):
                pass

        class Table:
            def __init__(self):
                self.message = None
                
            def broadcastMessage(self, type, message):
                self.message = message

        tourney = Tournament()
        table = Table()
        table.game = tourney.games[0]
        self.service.tables = [ table ]
        self.service.tourneyBreakCheck(tourney)
        self.failIf(table.message)
        tourney.state = pokertournament.TOURNAMENT_STATE_BREAK
        self.service.tourneyBreakCheck(tourney)
        self.failUnless("less than a minute" in table.message)
        tourney.remaining = 60
        self.service.tourneyBreakCheck(tourney)
        self.failUnless("one minute" in table.message)
        tourney.remaining = 120
        self.service.tourneyBreakCheck(tourney)
        self.failUnless("2 minute" in table.message)
        
class UpdatePlayerRakeTestCase(PokerServiceTestCaseBase):

    def test_updatePlayerRake(self):
        self.service.startService()
        self.service.db = self.db
        cursor = self.db.cursor(DictCursor)
        cursor.execute("INSERT INTO user2money (user_serial, currency_serial, amount, points, rake) VALUES (101, 1, 10, 10, 10)")
        self.assertEqual(True, self.service.updatePlayerRake(1, 101, 5))
        cursor.execute("SELECT * FROM user2money WHERE user_serial = 101 AND currency_serial = 1")
        row = cursor.fetchone()
        self.assertEqual(15, row['rake'])
        self.assertEqual(15, row['points'])
        cursor.close()

# ----------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test17"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerServiceTestCase))
    suite.addTest(loader.loadClass(RefillTestCase))
    suite.addTest(loader.loadClass(TimerTestCase))
    suite.addTest(loader.loadClass(BreakTestCase))
    suite.addTest(loader.loadClass(TourneyFinishedTestCase))
    suite.addTest(loader.loadClass(TourneyUnregisterTestCase))
    suite.addTest(loader.loadClass(TourneyMovePlayerTestCase))
    suite.addTest(loader.loadClass(TourneyCancelTestCase))
    suite.addTest(loader.loadClass(TourneyManagerTestCase))
    suite.addTest(loader.loadClass(ShutdownCheckTestCase))
    suite.addTest(loader.loadClass(ListHandsTestCase))
    suite.addTest(loader.loadClass(SetAccountTestCase))
    suite.addTest(loader.loadClass(UpdatePlayerRakeTestCase))
    suite.addTest(loader.loadClass(MonitorTestCase))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
#       reporter.TextReporter,
#	tracebackFormat='verbose',
        tracebackFormat='default',
        ).run(suite)

# ----------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerservice.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokerservice.py' TESTS='coverage-reset test-pokerservice.py coverage-report' check )"
# End:

