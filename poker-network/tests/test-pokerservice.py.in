#!@PYTHON@
# -*- mode: python; coding: iso-8859-1 -*-
# more information about the above line at http://www.python.org/dev/peps/pep-0263/
#
# Copyright (C) 2007, 2008 Loic Dachary <loic@dachary.org>
# Copyright (C)       2008 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C)       2006 Mekensleep <licensing@mekensleep.com>
#                          24 rue vieille du temple 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propogate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@gnu.org>
#  Bradley M. Kuhn <bkuhn@ebb.org>
#  Cedric Pinson <cpinson@freesheep.org>
#
import sys, os
sys.path.insert(0, "@srcdir@/..")
sys.path.insert(0, "..")

import time

from string import split
import libxml2
import random
import locale
import sets
from _mysql_exceptions import IntegrityError
from pprint import pprint
from datetime import date

from tests import testclock

from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor, defer

twisted.internet.base.DelayedCall.debug = True

from tests.testmessages import silence_all_messages, search_output, clear_all_messages, get_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
silence_all_messages()

from pokerengine import pokertournament, pokergame
from pokernetwork import pokerservice, pokernetworkconfig, user
from pokernetwork import currencyclient
from pokernetwork import pokerdatabase
currencyclient.CurrencyClient = currencyclient.FakeCurrencyClient
from pokernetwork.pokerpackets import *
from pokernetwork.packets import PacketError
from pokernetwork.userstats import UserStatsRankPercentileLookup
from pokernetwork.tourneyattrs import TourneyAttrsSponsoredPrizesLookup
from pokernetwork.attrpack  import AttrsLookup
from MySQLdb.cursors import DictCursor

class ConstantDeckShuffler:
    def shuffle(self, what):
        what[:] = [40, 13, 32, 9, 19, 31, 15, 14, 50, 34, 20, 6, 43, 44, 28, 29, 48, 3, 21, 45, 23, 37, 35, 11, 5, 22, 24, 30, 27, 39, 46, 33, 0, 8, 1, 42, 36, 16, 49, 2, 10, 26, 4, 18, 7, 41, 47, 17]

from pokerengine import pokergame
pokergame.shuffler = ConstantDeckShuffler()

class ConstantPlayerShuffler:
    def shuffle(self, what):
        what.sort()

from pokerengine import pokertournament
pokertournament.shuffler = ConstantPlayerShuffler()

TABLE1 = 1
TABLE2 = 2
TABLE3 = 3

# Note that we use the locale fr_FR.ISO-8859-1 here for testing.  This must be
# a valid locale on the system!  Important tests are skipped otherwise!!!

localLocale = locale.getlocale(locale.LC_ALL)
FRENCH_LOCALE_MISSING = False
MESSAGE_WHEN_FRENCH_LOCALE_MISSING = "WARNING: Locale fr_FR.ISO-8859-1 missing, so certain tests will be SKIPPED and coverage will be INCOMPLETE! FAIL!  fail!"
try:
    locale.setlocale(locale.LC_ALL, "fr_FR.ISO-8859-1")
except locale.Error, le:
    print MESSAGE_WHEN_FRENCH_LOCALE_MISSING
    FRENCH_LOCALE_MISSING = True

locale.setlocale(locale.LC_ALL, localLocale)


settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" max_joined="1000" simultaneous="4" chat="yes" remove_completed="1" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19480" />

  <language value="en_US.ISO-8859-1"/>
  <language value="fr_FR.ISO-8859-1"/>
  <language value="fr_FX.ISO-8859-1"/>
  <language value="de_DE.ISO-8859-1"/>
  <language value="en_GB.ISO-8859-1"/>
  <language value="es_ES.ISO-8859-1"/>
  <language value="nl_NL.ISO-8859-1"/>
  <language value="fr_BE.ISO-8859-1"/>
  <language value="en_CA.ISO-8859-1"/>
  <language value="fr_CA.ISO-8859-1"/>
  <language value="it_IT.ISO-8859-1"/>
  <language value="pt_PT.ISO-8859-1"/>
  <language value="da_DK.ISO-8859-1"/>
  <language value="fi_FI.ISO-8859-1"/>
  <language value="nb_NO.ISO-8859-1"/>
  <language value="sv_SE.ISO-8859-1"/>
  <language value="this_locale_does_not_exist"/>

  <stats type="RankPercentile"/>

  <tourney_attrs type="SponsoredPrizes"/>

  <refill serial="1" amount="10000000" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="@MYSQL_TEST_DBHOST@" user="pokernetworktest" password="pokernetwork"
            root_user="@MYSQL_TEST_DBROOT@" root_password="@MYSQL_TEST_DBROOT_PASSWORD@" schema="@srcdir@/../../database/schema.sql" command="@MYSQL@" />
  <path>@POKER_ENGINE_PKGSYSCONFDIR@ @POKER_NETWORK_PKGSYSCONFDIR@</path>
  <users temporary="BOT"/>
</server>
"""

def fun_name():
    try:
        raise ZeroDivisionError
    except ZeroDivisionError:
        return sys.exc_info()[2].tb_frame.f_back.f_code.co_name

class PokerServiceTestCaseBase(unittest.TestCase):

    def destroyDb(self):
        if len("@MYSQL_TEST_DBROOT_PASSWORD@") > 0:
            os.system("@MYSQL@ -u @MYSQL_TEST_DBROOT@ --password='@MYSQL_TEST_DBROOT_PASSWORD@' -h '@MYSQL_TEST_DBHOST@' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("@MYSQL@ -u @MYSQL_TEST_DBROOT@ -h '@MYSQL_TEST_DBHOST@' -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    # ----------------------------------------------------------------
    def setUp(self):
        testclock._seconds_reset()
        self.destroyDb()
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        settings.header = settings.doc.xpathNewContext()
        self.db = pokerdatabase.PokerDatabase(settings)
        self.service = pokerservice.PokerService(settings)
        self.default_money = 10000000
#        self.service.verbose = 0
#        self.service.verbose = 4

    # ----------------------------------------------------------------
    def tearDown(self):
        d = self.service.stopService()
        d.addCallback(lambda x: self.destroyDb())
        return d

    # ----------------------------------------------------------------
    def createUsers(self):
        cursor = self.db.cursor()
        for user_number in (1, 2, 3):
            cursor.execute("INSERT INTO users (name, password, created) VALUES ('user%d', 'password%d', 0)" % ( user_number, user_number ))
            self.assertEqual(1, cursor.rowcount)

        ( (self.user1_serial, name, privilege), message ) = self.service.auth("user1", "password1", "role1")
        ( (self.user2_serial, name, privilege), message ) = self.service.auth("user2", "password2", "role1")
        ( (self.user3_serial, name, privilege), message ) = self.service.auth("user3", "password3", "role1")

        for user_number in (self.user1_serial, self.user2_serial, self.user3_serial):
            if self.default_money > 0 and user_number == self.user3_serial:
                cursor.execute("INSERT INTO user2money (user_serial, currency_serial, amount) VALUES (%d, 2, %d)" % ( user_number, self.default_money ) )
                self.assertEqual(1, cursor.rowcount)

        cursor.close()

monitor_settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" max_joined="1000" simultaneous="4" chat="yes" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <listen tcp="19480" />

  <monitor>../@srcdir@/monitorplugin.py</monitor>
  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="@MYSQL_TEST_DBHOST@" user="pokernetworktest" password="pokernetwork"
            root_user="@MYSQL_TEST_DBROOT@" root_password="@MYSQL_TEST_DBROOT_PASSWORD@" schema="@srcdir@/../../database/schema.sql" command="@MYSQL@" />
  <path>@POKER_ENGINE_PKGSYSCONFDIR@ @POKER_NETWORK_PKGSYSCONFDIR@</path>
  <users temporary="BOT"/>
</server>
"""

class MonitorTestCase(unittest.TestCase):

    def destroyDb(self):
        if len("@MYSQL_TEST_DBROOT_PASSWORD@") > 0:
            os.system("@MYSQL@ -u @MYSQL_TEST_DBROOT@ --password='@MYSQL_TEST_DBROOT_PASSWORD@' -h '@MYSQL_TEST_DBHOST@' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("@MYSQL@ -u @MYSQL_TEST_DBROOT@ -h '@MYSQL_TEST_DBHOST@' -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    # ----------------------------------------------------------------
    def setUp(self):
        testclock._seconds_reset()
        self.destroyDb()
        settings = pokernetworkconfig.Config([])
        settings.loadFromString(monitor_settings_xml)
        self.db = pokerdatabase.PokerDatabase(settings)
        self.service = pokerservice.PokerService(settings)

    # ----------------------------------------------------------------
    def tearDown(self):
        d = self.service.stopService()
        d.addCallback(lambda x: self.destroyDb())
        return d

    # ----------------------------------------------------------------
    def test01_monitor(self):
        self.service.startService()
        test = self
        class Avatar:
            protocol = True
            def sendPacketVerbose(self, packet):
                test.assertEquals(PACKET_POKER_MONITOR_EVENT, packet.type)
                test.assertEquals(1, packet.event)
                test.assertEquals(2, packet.param1)
                test.assertEquals(3, packet.param2)
                self.sent = True
        avatar = Avatar()
        self.assertEquals(PACKET_ACK, self.service.monitor(avatar).type)
        self.service.databaseEvent(event = 1, param1 = 2, param2 = 3)
        self.failUnless(avatar.sent)
        self.failUnless(hasattr(self.service, 'HERE'))
        cursor = self.db.cursor()
        cursor.execute("SELECT COUNT(*) FROM monitor WHERE event = 1")
        self.assertEquals(1, cursor.rowcount)

class CleanUpTestCase(PokerServiceTestCaseBase):

    # ----------------------------------------------------------------
    def test01_cleanUp(self):
        self.service.startService()
        db = self.service.db
        cursor = db.cursor()
        cursor.execute("INSERT INTO users (serial, name, password, created) VALUES (43, 'BOTAA', 'passwordAA', 0)")
        cursor.execute("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (43, 1, 200)")
        cursor.execute("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (44, 1, 200)")
        self.service.cleanUp('BOT')
        cursor.execute("SELECT COUNT(*) FROM users WHERE name like 'BOT%'")
        self.assertEqual(0, cursor.fetchone()[0])
        #
        # Bot removed from tourney
        #
        cursor.execute("SELECT COUNT(*) FROM user2tourney WHERE user_serial = 43")
        self.assertEqual(0, cursor.fetchone()[0])
        #
        # Non bot not removed from tourney
        #
        cursor.execute("SELECT COUNT(*) FROM user2tourney WHERE user_serial = 44")
        self.assertEqual(1, cursor.fetchone()[0])
        cursor.close()

class ListTablesTestCase(PokerServiceTestCaseBase):

    # ----------------------------------------------------------------
    def test01_my(self):
        self.service.startService()
        db = self.service.db
        serial = 44
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE1))
        tables = self.service.listTables('my', serial)
        self.assertEqual(1, len(tables))
        self.assertEqual(tables[0]['serial'], TABLE1)

    # ----------------------------------------------------------------
    def test02_currency(self):
        self.service.startService()
        tables = self.service.listTables('50', 0)
        self.assertEqual(0, len(tables))
        currency_serial = '1'
        tables = self.service.listTables(currency_serial, 0)
        self.assertEqual(2, len(tables))

    # ----------------------------------------------------------------
    def test03_currency_and_variant(self):
        self.service.startService()
        tables = self.service.listTables('1\tfakevariant', 0)
        self.assertEqual(0, len(tables))
        tables = self.service.listTables('1\tholdem', 0)
        self.assertEqual(2, len(tables))

    # ----------------------------------------------------------------
    def test04_variant(self):
        self.service.startService()
        tables = self.service.listTables('\tfakevariant', 0)
        self.assertEqual(0, len(tables))
        tables = self.service.listTables('\tholdem', 0)
        self.assertEqual(2, len(tables))

    # ----------------------------------------------------------------
    def test05_all(self):
        self.service.startService()
        tables = self.service.listTables('', 0)
        self.assertEqual(2, len(tables))
        tables = self.service.listTables('all', 0)
        self.assertEqual(2, len(tables))

    # ----------------------------------------------------------------
    def test06_name(self):
        self.service.startService()
        tables = self.service.listTables('fakename', 0)
        self.assertEqual(0, len(tables))
        tables = self.service.listTables('Table1', 0)
        self.assertEqual(1, len(tables))

class TourneySelectTestCase(PokerServiceTestCaseBase):

    def test00_all(self):
        self.service.startService()
        tourneys = self.service.tourneySelect('')
        self.assertEqual(2, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual('regular1', tourneys[1]['name'])

    def test01_sit_n_go(self):
        self.service.startService()
        tourneys = self.service.tourneySelect('\tsit_n_go')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])

    def test02_regular(self):
        self.service.startService()
        tourneys = self.service.tourneySelect('\tregular')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('regular1', tourneys[0]['name'])

    def test02_currency_serial(self):
        self.service.startService()
        tourneys = self.service.tourneySelect('1\tregular')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('regular1', tourneys[0]['name'])
        tourneys = self.service.tourneySelect('44\tregular')
        self.assertEqual(0, len(tourneys))

    def test03_name(self):
        self.service.startService()
        tourneys = self.service.tourneySelect('regular1')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('regular1', tourneys[0]['name'])

    def test04_registered(self):
        self.service.startService()
        self.createUsers()
        (heads_up,) = filter(lambda tourney: tourney.name == 'sitngo2', self.service.tourneys.values())
        tourneys = self.service.tourneySelect('')
        self.assertEqual(2, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual(heads_up.serial, tourneys[0]['serial'])
        self.assertEqual(0, tourneys[0]['registered'])
        tourneys = self.service.tourneySelect('sitngo2')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual(heads_up.serial, tourneys[0]['serial'])
        self.assertEqual(0, tourneys[0]['registered'])
        tourneys = self.service.tourneySelect('\tsit_n_go')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual(heads_up.serial, tourneys[0]['serial'])
        self.assertEqual(0, tourneys[0]['registered'])
        tourneys = self.service.tourneySelect('1\tsit_n_go')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual(heads_up.serial, tourneys[0]['serial'])
        self.assertEqual(0, tourneys[0]['registered'])
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user2_serial,
                                                                game_id = heads_up.serial))
        tourneys = self.service.tourneySelect('')
        self.assertEqual(2, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual(heads_up.serial, tourneys[0]['serial'])
        self.assertEqual(1, tourneys[0]['registered'])
        tourneys = self.service.tourneySelect('sitngo2')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual(heads_up.serial, tourneys[0]['serial'])
        self.assertEqual(1, tourneys[0]['registered'])
        tourneys = self.service.tourneySelect('\tsit_n_go')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual(heads_up.serial, tourneys[0]['serial'])
        self.assertEqual(1, tourneys[0]['registered'])
        tourneys = self.service.tourneySelect('1\tsit_n_go')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual(heads_up.serial, tourneys[0]['serial'])
        self.assertEqual(1, tourneys[0]['registered'])

    def test04_with_old_completed(self):
        self.service.startService()
        self.createUsers()
        tourneys = self.service.tourneySelect('')
        self.assertEquals(len(tourneys),2)
        db = self.service.db
        db.db.query("UPDATE tourneys SET finish_time = UNIX_TIMESTAMP(NOW() - INTERVAL 2 HOUR), state = 'complete' WHERE name = 'regular1'")
        self.assertEquals(self.service.remove_completed, 1)
        tourneys = self.service.tourneySelect('')
        self.assertEquals(len(tourneys),1)
        self.assertEquals(tourneys[0]["name"], "sitngo2")

class PlayerPlacesTestCase(PokerServiceTestCaseBase):

    def test00_not_anywhere(self):
        self.service.startService()
        serial = 888
        places = self.service.getPlayerPlaces(serial)
        self.assertEqual(0, len(places.tables))
        self.assertEqual(0, len(places.tourneys))
        self.assertEqual(serial, places.serial)

    def test01_tables_and_tourneys(self):
        self.service.startService()
        db = self.service.db
        serial = 888
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE1))
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE2))
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE3))
        tourney_serial = 999
        db.db.query("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, %d)" % (serial, tourney_serial))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial, 'registering'))
        places = self.service.getPlayerPlaces(serial)
        self.assertEqual([TABLE1, TABLE2, TABLE3], places.tables)
        self.assertEqual([tourney_serial], places.tourneys)
        self.assertEqual(serial, places.serial)

    def test02_tables_and_tourneys_by_name(self):
        self.service.startService()
        db = self.service.db
        serial = 888
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE1))
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE2))
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE3))
        tourney_serial = 999
        db.db.query("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, %d)" % (serial, tourney_serial))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial, 'registering'))
        name = 'testuser'
        db.db.query("INSERT INTO users (serial, name) VALUES (%d, '%s')" % (serial, name))
        places = self.service.getPlayerPlacesByName(name)
        self.assertEqual([TABLE1, TABLE2, TABLE3], places.tables)
        self.assertEqual([tourney_serial], places.tourneys)
        self.assertEqual(serial, places.serial)

    def test02_tables_and_tourneys_by_name_error(self):
        self.service.startService()
        db = self.service.db
        serial = 888
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE1))
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE2))
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE3))
        tourney_serial = 999
        db.db.query("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, %d)" % (serial, tourney_serial))
        name = 'testuser1'
        db.db.query("INSERT INTO users (serial, name) VALUES (%d, '%s')" % (serial, name))
        result = self.service.getPlayerPlacesByName('testuser2')
        self.assertEqual(PACKET_POKER_PLAYER_PLACES, result.other_type)

    def test03_list_tourneys_in_registering_running_break_break_wait_state(self):
        self.service.startService()
        db = self.service.db
        serial = 888
        tourney_serial = 999
        db.db.query("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, %d)" % (serial, tourney_serial+1))
        db.db.query("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, %d)" % (serial, tourney_serial+2))
        db.db.query("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, %d)" % (serial, tourney_serial+3))
        db.db.query("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, %d)" % (serial, tourney_serial+4))
        db.db.query("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, %d)" % (serial, tourney_serial+5))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial, 'announced'))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial+1, 'registering'))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial+2, 'running'))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial+3, 'breakwait'))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial+4, 'break'))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial+5, 'complete'))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial+6, 'canceled'))
        places = self.service.getPlayerPlaces(serial)
        self.assertEqual([], places.tables)
        self.assertEqual([tourney_serial+1, tourney_serial+2, tourney_serial+3, tourney_serial+4], places.tourneys)
        self.assertEqual(serial, places.serial)

class ResthostTestCase(unittest.TestCase):

    def destroyDb(self):
        if len("@MYSQL_TEST_DBROOT_PASSWORD@") > 0:
            os.system("@MYSQL@ -u @MYSQL_TEST_DBROOT@ --password='@MYSQL_TEST_DBROOT_PASSWORD@' -h '@MYSQL_TEST_DBHOST@' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("@MYSQL@ -u @MYSQL_TEST_DBROOT@ -h '@MYSQL_TEST_DBHOST@' -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    def setUp(self):
        self.destroyDb()
        xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" max_joined="1000" simultaneous="4" chat="yes" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19480" />

  <resthost host="HOST" port="7777" path="/PATH" />
  <refill serial="1" amount="10000000" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="@MYSQL_TEST_DBHOST@" user="pokernetworktest" password="pokernetwork"
            root_user="@MYSQL_TEST_DBROOT@" root_password="@MYSQL_TEST_DBROOT_PASSWORD@" schema="@srcdir@/../../database/schema.sql" command="@MYSQL@" />
  <path>@POKER_ENGINE_PKGSYSCONFDIR@ @POKER_NETWORK_PKGSYSCONFDIR@</path>
  <users temporary="BOT"/>
</server>
"""
        settings = pokernetworkconfig.Config([])
        settings.loadFromString(xml)
        self.service = pokerservice.PokerService(settings)

    def tearDown(self):
        d = self.service.stopService()
        d.addCallback(lambda x: self.destroyDb())
        return d

    def test00_init(self):
        """ setupResthost twice with the same information gives the same serial """
        self.service.startService()
        self.assertEqual(1, self.service.resthost_serial)
        self.service.resthost_serial = 0
        self.service.setupResthost()
        self.assertEqual(1, self.service.resthost_serial)

    def test01_packet2resthost(self):
        self.service.startService()
        #
        # ping is never routed
        #
        resthost = self.service.packet2resthost(PacketPing())
        self.assertEqual(None, resthost)
        #
        # poll (or any packet with a valid game_id) is routed
        #
        resthost = self.service.packet2resthost(PacketPokerPoll(game_id = 1))
        self.assertEqual('HOST', resthost[0])
        #
        # poll to an unknown game_id is not routed
        #
        resthost = self.service.packet2resthost(PacketPokerPoll(game_id = 888))
        self.assertEqual(None, resthost)
        #
        # poll is routed
        #
        db = self.service.db
        db.db.query("INSERT INTO route VALUES (0, 484, 1, 1)")
        resthost = self.service.packet2resthost(PacketPokerPoll(tourney_serial = 484))
        self.assertEqual('HOST', resthost[0])
        #
        # poll to an unknown tourney_serial is not routed
        #
        resthost = self.service.packet2resthost(PacketPokerPoll(tourney_serial = 999))
        self.assertEqual(None, resthost)
        #
        # PACKET_POKER_TOURNEY_REGISTER
        #
        resthost = self.service.packet2resthost(PacketPokerTourneyRegister(game_id = 484))
        self.assertEqual('HOST', resthost[0])
        #
        # packet with a game_id
        #
        resthost = self.service.packet2resthost(PacketPokerCall(game_id = 1))
        self.assertEqual('HOST', resthost[0])

class PokerServiceTestCase(PokerServiceTestCaseBase):

    # ----------------------------------------------------------------
    def configValues(self, settings_data, joined_max, missed_round_max=10, delaysValue=-1, queuedPacketMax = 500, statsLookupType = UserStatsRankPercentileLookup, statsError = "", tourneyAttrsLookupType = TourneyAttrsSponsoredPrizesLookup, tourneyAttrsError = ""):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_data, len(settings_data))
        settings.header = settings.doc.xpathNewContext()
        self.service = pokerservice.PokerService(settings)

        for (key, value) in ( ('position', '60'), ('autodeal', '18'),
                              ('showdown', '30'), ('round', '12'), ('finish', '18')):
            self.assertEquals(self.service.delays[key], value)
        for (key, value) in ( ('serial', '1'), ('amount', '10000000')):
            self.assertEquals(self.service.refill[key], value)

        self.assertEquals(self.service.verbose, 6)

        self.assertEquals(joined_max, self.service.joined_max)
        self.assertEquals(missed_round_max, self.service.missed_round_max)
        self.assertEquals(missed_round_max, self.service.getMissedRoundMax())
        self.assertEquals(queuedPacketMax, self.service.client_queued_packet_max)
        self.assertEquals(queuedPacketMax, self.service.getClientQueuedPacketMax())

        # Check that statsLookupType is correct
        self.failUnless(isinstance(self.service.lookups['stats'], statsLookupType))
        self.assertEquals(self.service.lookups['stats'], self.service.getUserStatsLookup())

        if isinstance(self.service.lookups['stats'], UserStatsRankPercentileLookup):
            self.assertEquals(self.service.getUserStatsLookup().service, self.service)
        else:
            self.failUnless(isinstance(self.service.lookups['stats'], AttrsLookup))
        if statsError != "":
            self.failUnless(search_output(statsError))

        self.failUnless(isinstance(self.service.lookups['tourney_attrs'], tourneyAttrsLookupType))
        self.assertEquals(self.service.lookups['tourney_attrs'], self.service.getTourneyAttrsLookup())
        if not isinstance(self.service.lookups['tourney_attrs'], TourneyAttrsSponsoredPrizesLookup):
            self.failUnless(isinstance(self.service.lookups['tourney_attrs'], AttrsLookup))
        if tourneyAttrsError != "":
            self.failUnless(search_output(statsError))

        startedOnlyVars = [ ('joined_count', 0),
                            ('tables', 2), ('tourney_table_serial', 1),
                            ('shutting_down', False), ('avatars', []),
                            ('serial2client', {}), ('simultaneous', 4),
                            ('monitors', []), ('gettextFuncs', 17) ]
        for (instanceVar, val) in startedOnlyVars:
            self.assertEquals(self.service.__dict__.has_key(instanceVar), False)

        clear_all_messages()
        self.service.startService()
        self.failUnless(search_output('*ERROR* Unable to find codeset string in language value: this_locale_does_not_exist'))
        self.failUnless(search_output("*ERROR* No translation for language this_locale_does_not_exist for this_locale_does_not_exist in poker-engine; locale ignored: [Errno 2] No translation file found for domain: 'poker-engine'"))
        self.failUnless(search_output('*ERROR* Translation setup for this_locale_does_not_exist failed.  Strings for clients requesting this_locale_does_not_exist will likely always be in English'))
        for (instanceVar, val) in startedOnlyVars:
            self.assertEquals(self.service.__dict__.has_key(instanceVar), True)
            if instanceVar == "tables":
                self.assertEquals(len(self.service.__dict__[instanceVar]), val)

        for ii in ('this_locale_does_not_exist', 'en_US.ISO-8859-1', 'fr_FR.ISO-8859-1'):
            self.assertEquals(self.service.gettextFuncs.has_key(ii), True)
            self.assertEquals(callable(self.service.locale2translationFunc(ii)), True)
        for ii in ('this_locale_does_not_exist', 'en_US.ISO-8859-1'):
            self.assertEquals(self.service.gettextFuncs[ii]("Aces"), "Aces")
        self.assertEquals(self.service.gettextFuncs['fr_FR.ISO-8859-1']("Aces"), "d'As")

        for ii in ('nothing', 'unknown'):
            self.assertEquals(self.service.locale2translationFunc(ii), None)

        # If delaysValue is negative, that means in the context of this
        # test that we want to assume they weren't given in the settings
        # file and therefore service.delays() should not have them as keys.

        for str in ('extra_wait_tourney_break', 'extra_wait_tourney_start', 'extra_wait_tourney_finish'):
            if delaysValue < 0:
                self.assertEquals(self.service.delays.has_key(str), False)
            else:
                self.assertEquals(int(self.service.delays[str]), delaysValue)

    def test00_01_configValues(self):
        self.configValues(settings_xml, 1000)

    def test00_02_configValues(self):
        self.configValues(settings_xml.replace('max_joined="1000"', ""), 4000)

    def test00_03_configValues(self):
        self.configValues(settings_xml.replace('max_joined="1000"',
                                               'max_missed_round="5" max_queued_client_packets="100"'),
                          4000, 5, queuedPacketMax=100)

    def test00_4_badLocaleObject(self):
        """test00_4_badLocaleObject
        Check the case where the imported locale object's setlocal
        function does not work and causes errors in configuration."""

        def badSetLocale(a, b):
            raise locale.Error("testing bad setlocale")

        myLocale = locale.getlocale(locale.LC_ALL)
        saveLocale = locale.setlocale
        locale.setlocale = badSetLocale

        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        settings.header = settings.doc.xpathNewContext()
        self.service = pokerservice.PokerService(settings)
        clear_all_messages()
        self.service.startService()
        self.assertEquals(len(self.service.gettextFuncs), 17)
        self.failUnless(search_output('*ERROR* Unable to find codeset string in language value: this_locale_does_not_exist'))
        self.failUnless(search_output("*ERROR* No translation for language this_locale_does_not_exist for this_locale_does_not_exist in poker-engine; locale ignored: [Errno 2] No translation file found for domain: 'poker-engine'"))
        for ii in ('en_US.ISO-8859-1', 'fr_FR.ISO-8859-1'):
            self.assertEquals(self.service.gettextFuncs.has_key(ii), True)
        self.assertEquals(self.service.gettextFuncs['en_US.ISO-8859-1']("Aces"), "Aces")
        self.assertEquals(self.service.gettextFuncs['fr_FR.ISO-8859-1']("Aces"), "d'As")
        self.assertEquals(search_output("*ERROR* Unable to restore original locale: testing bad setlocale"), True)
        locale.setlocale = saveLocale

    def test00_05_configValues(self):
        self.configValues(settings_xml.replace('delays',
                                               'delays extra_wait_tourney_break="60" extra_wait_tourney_start="60" extra_wait_tourney_finish="60"'), 1000, delaysValue=60)

    def test00_06_configValues(self):
        self.configValues(settings_xml.replace('<stats type="RankPercentile"/>',
                                               '<stats type="RankPercentile"/> <stats type="Ignored"/>'), 1000, statsError = "*ERROR* settings include multiple <stats> tags; using first one only")
    def test00_07_configValues(self):
        self.configValues(settings_xml.replace('<stats type="RankPercentile"/>',
                                               '<stats type="Missing"/>'), 1000, statsLookupType = AttrsLookup, statsError = "ERROR 'module' object has no attribute 'UserStatsMissingLookup'")
    def test00_08_configValues(self):
        self.configValues(settings_xml.replace('<stats type="RankPercentile"/>', ''), 1000,
                          statsLookupType = AttrsLookup)

    def test00_09_configValues(self):
        self.configValues(settings_xml.replace('<tourney_attrs type="SponsoredPrizes"/>',
                                               '<tourney_attrs type="SponsoredPrizes"/> <tourney_attrs type="Ignored"/>'), 1000, tourneyAttrsError = "*ERROR* settings include multiple <tourney_attrs> tags; using first one only")
    def test00_10_configValues(self):
        self.configValues(settings_xml.replace('<tourney_attrs type="SponsoredPrizes"/>',
                                               '<tourney_attrs type="Missing"/>'), 1000, tourneyAttrsLookupType = AttrsLookup, tourneyAttrsError = "ERROR 'module' object has no attribute 'TourneyAttrsMissingLookup'")
    def test00_11_configValues(self):
        self.configValues(settings_xml.replace('<tourney_attrs type="SponsoredPrizes"/>', ''), 1000,
                          tourneyAttrsLookupType = AttrsLookup)
    def test00_12_badEncoding(self):
        """test00_12_badEncoding
        Check the case where an error occurs due to an encoding requested
        for a config language value has an unknown encoding."""

        new_settings_xml = settings_xml.replace('<language value="fr_FR.ISO-8859-1"/>',
                                                '<language value="fr_FR.MAGIC-PIXIE-DUST"/>')

        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(new_settings_xml, len(new_settings_xml))
        settings.header = settings.doc.xpathNewContext()
        self.service = pokerservice.PokerService(settings)
        clear_all_messages()
        self.service.startService()
        self.assertEquals(len(self.service.gettextFuncs), 17)
        self.failUnless(search_output('*ERROR* Unsupported codeset MAGIC-PIXIE-DUST for fr_FR.MAGIC-PIXIE-DUST in poker-engine; locale ignored: unknown encoding: MAGIC-PIXIE-DUST'))
        self.failUnless(search_output('*ERROR* Unable to find codeset string in language value: this_locale_does_not_exist'))
        self.failUnless(search_output("*ERROR* No translation for language this_locale_does_not_exist for this_locale_does_not_exist in poker-engine; locale ignored: [Errno 2] No translation file found for domain: 'poker-engine'"))
        for ii in ('en_US.ISO-8859-1', 'fr_FR.MAGIC-PIXIE-DUST'):
            self.assertEquals(self.service.gettextFuncs.has_key(ii), True)
            self.assertEquals(self.service.gettextFuncs[ii]("Aces"), "Aces")

    # ----------------------------------------------------------------
    def test01_auth(self):
        self.service.startService()
        ( (serial, name, privilege), message ) = self.service.auth("user1", "password1", "role1")
        self.assertEquals(None, message)
        self.assertEquals(4, serial)
        self.assertEquals("user1", name)
        self.assertEquals(user.User.REGULAR, privilege)

    # ----------------------------------------------------------------
    def test01_auth_invalid_login(self):
        self.service.startService()
        self.service.poker_auth.auto_create_account = False
        ( status, message ) = self.service.auth("user1", "password1", sets.Set("role1"))
        self.assertEquals("Invalid login or password", message)
        self.assertEquals(False, status)

    # ----------------------------------------------------------------
    def test01_auth_already_logged(self):
        class Client:
            def __init__(self):
                self.roles = sets.Set('role1')
            def getName(self):
                return "user1"

        self.service.startService()
        ( (serial, name, privilege), message ) = self.service.auth("user1", "password1", sets.Set('role1'))
        self.service.serial2client[serial] = Client()
        ( status, message ) = self.service.auth("user1", "password1", sets.Set('role1'))
        self.assertEquals('Already logged in from somewhere else', message)
        self.assertEquals(False, status)

    # ----------------------------------------------------------------
    def cashIn(self):

        self.currency1_serial = 1
        note1 = self.service.cashier.currency_client._buildNote("ONE", 100)
        packet1 = PacketPokerCashIn(serial = self.user1_serial,
                                    url = note1[0],
                                    bserial = note1[1],
                                    name = note1[2],
                                    value = note1[3])
        d1 = self.service.cashIn(packet1)

        note2 = self.service.cashier.currency_client._buildNote("ONE", 100)
        packet2 = PacketPokerCashIn(serial = self.user2_serial,
                                    url = note2[0],
                                    bserial = note2[1],
                                    name = note2[2],
                                    value = note2[3])
        d2 = self.service.cashIn(packet2)

        self.currency2_serial = 2
        note3 = self.service.cashier.currency_client._buildNote("TWO", 200)
        packet3 = PacketPokerCashIn(serial = self.user2_serial,
                                    url = note3[0],
                                    bserial = note3[1],
                                    name = note3[2],
                                    value = note3[3])
        d3 = self.service.cashIn(packet3)

        return defer.DeferredList((d1, d2, d3), fireOnOneErrback = True)

    # ----------------------------------------------------------------
    def test04_getUserInfo(self):
        self.service.startService()
        self.service.refill = None

        self.default_money = 0
        self.createUsers()
        #
        # No cash in means no money
        #
        info = self.service.getUserInfo(self.user1_serial)
        self.assertEqual(0, len(info.money))

        def step2(result):
            self.assertEquals([ (True, PacketAck()), (True, PacketAck()), (True, PacketAck()) ], result)
            info = self.service.getUserInfo(self.user2_serial)
            self.assertEquals({1: (100, 0, 0), 2: (200, 0, 0)}, info.money)

            #
            # Some money is on a table
            #
            table_serial = self.service.tables.values()[0].game.id
            buy_in = 50
            currency_serial = 1
            self.assertEquals(1, table_serial)
            self.assertEquals(currency_serial, self.service.tables.values()[0].currency_serial)
            self.service.seatPlayer(self.user2_serial, table_serial, 0)
            self.service.buyInPlayer(self.user2_serial, table_serial, currency_serial, buy_in)
            info = self.service.getUserInfo(self.user2_serial)
            self.assertEquals({1: (50, 50, 0), 2: (200, 0, 0)}, info.money)
            #
            # The other player only has one currency
            #
            self.service.seatPlayer(self.user1_serial, table_serial, 0)
            self.service.buyInPlayer(self.user1_serial, table_serial, currency_serial, buy_in)
            info = self.service.getUserInfo(self.user1_serial)
            self.assertEquals({1: (50, 50, 0)}, info.money)

            return result

        d = self.cashIn()
        d.addCallback(step2)
        return d
    test04_getUserInfo.timeout = 500

    # ----------------------------------------------------------------
    def test05_getPersonalInfo(self):
        self.service.startService()

        self.createUsers()
        info = self.service.getPersonalInfo(self.user1_serial)
        self.assertEquals(self.user1_serial, info.serial)

    def cashOutCommit(self, packet):
        packet = PacketPokerCashOutCommit(transaction_id = packet.name)
        self.assertEquals(PacketAck(), self.service.cashOutCommit(packet))
        return 1

    def cashOut(self, result):
        self.assertEquals([ (True, PacketAck()), (True, PacketAck()), (True, PacketAck()) ], result)
        packet = PacketPokerCashOut(serial = self.user1_serial,
                                    url = "ONE",
                                    value = 30)
        def validate(packet):
            self.assertEquals("ONE", packet.url)
            self.assertEquals(30, packet.value)
            return packet

        d = self.service.cashOut(packet)
        d.addCallback(validate)
        d.addCallback(self.cashOutCommit)
        return d

    # ----------------------------------------------------------------
    def test07_cashOut(self):
        self.service.startService()

        self.createUsers()
        d = self.cashIn()
        d.addCallback(self.cashOut)
        return d

    # ----------------------------------------------------------------

    class ClientMockup:
        def __init__(self, serial):
            self.serial = serial
            self.packet_end_tournament = None
            self.packets = []
            self.tables = {}
            self.joinedTables = []

        def sendPacketVerbose(self, packet):
            # packet_end_tournament was an expected field by some tests
            # when I got here so I left it as is but added my own packet
            # list for my own tests.
            self.packet_end_tournament = packet
            self.packets.append(packet)

        def join(self, table):
            self.joinedTables.append(table)
            self.tables[table.game.id] = table

        def getSerial(self):
            return self.serial

        def sendPacket(self, packet):
            self.packets.append(packet)


    class TableMockup:
        def __init__(self):
            self.serial = None
        def kickPlayer(self, serial):
            self.kick_player = serial

    class TourneyMockup:
        def __init__(self):
            self.call_rank = None
            self.serial = 10
            self.schedule_serial = 1
            self.players = [0, 2, 4]
            self.prize = [10,20,30]
            self.rank = 10
        def getRank(self, serial):
            return self.rank

        def prizes(self):
            return self.prize


    def test09_endOfTournamentsNotInPlayers(self):
        self.service.startService()
        self.createUsers()

        table = self.TableMockup()
        kickplayer = None
        def getTableMockup( game_id):
            return table

        tourney = self.TourneyMockup()
        self.service.client = self.ClientMockup(self.user1_serial)
        self.service.getTable = getTableMockup
        self.service.tourneyRemovePlayer(tourney, 0, self.user1_serial)
        self.assertEquals(self.service.client.packet_end_tournament == None, True)

    def test10_endOfTournamentsNoPrize(self):
        self.service.startService()
        self.createUsers()

        table = self.TableMockup()
        kickplayer = None
        def getTableMockup( game_id):
            return table

        tourney = self.TourneyMockup()
        tourney.players = [2, self.user1_serial, 10]
        client = self.ClientMockup(self.user1_serial)
        self.service.serial2client[self.user1_serial] = client
        self.service.getTable = getTableMockup
        self.service.tourneyRemovePlayer(tourney, 0, self.user1_serial)
        self.assertEquals(client.packet_end_tournament != None, True)
        self.assertEquals(client.packet_end_tournament.serial == tourney.serial, True)
        self.assertEquals(client.packet_end_tournament.money == 0, True)
        self.assertEquals(client.packet_end_tournament.rank == 10, True)
        self.assertEquals(client.packet_end_tournament.players == 3, True)

    def test11_endOfTournamentsPrize(self):
        self.service.startService()
        self.createUsers()

        table = self.TableMockup()
        kickplayer = None
        def getTableMockup( game_id):
            return table

        tourney = self.TourneyMockup()
        tourney.rank = 2
        client = self.ClientMockup(self.user1_serial)
        self.service.serial2client[self.user1_serial] = client
        self.service.getTable = getTableMockup
        self.service.tourneyRemovePlayer(tourney, 0, self.user1_serial)
        self.assertEquals(client.packet_end_tournament != None, True)
        self.assertEquals(client.packet_end_tournament.serial == tourney.serial, True)
        self.assertEquals(client.packet_end_tournament.money == 20, True)
        self.assertEquals(client.packet_end_tournament.rank == 2, True)
        self.assertEquals(client.packet_end_tournament.players == 3, True)


    # ----------------------------------------------------------------
    def test12_playerImage(self):
        self.service.startService()

        self.createUsers()
        player_image1 = PacketPokerPlayerImage(serial = self.user1_serial,
                                               image = "12345")
        self.assertEquals(True, self.service.setPlayerImage(player_image1))
        player_image2 = self.service.getPlayerImage(self.user1_serial)
        self.assertEquals(player_image1.image, player_image2.image)
        player_image2 = self.service.getPlayerImage(self.user2_serial)
        self.assertEquals("", player_image2.image)

    # ----------------------------------------------------------------
    def test13_checkTourneysSchedule_spawn_regular(self):
        pokerservice.UPDATE_TOURNEYS_SCHEDULE_DELAY = 1
        pokerservice.CHECK_TOURNEYS_SCHEDULE_DELAY = 0.5

        #
        # A regular tournament starts registration now
        #
        #  Note that we have to set a respawn here by default so that it
        #  gets created; the default schema doesn't respawn this tourney
        #  by default.
        cursor = self.db.cursor()
        cursor.execute("UPDATE tourneys_schedule SET respawn = 'y', register_time = UNIX_TIMESTAMP(NOW() + INTERVAL 1 SECOND) WHERE name = 'regular1'")
        self.assertEqual(1, cursor.rowcount)
        cursor.close()

        self.service.startService()
        d = defer.Deferred()
        def checkTourneys(status):
            t = self.service.tourneys.values()[0]
            self.failUnless(filter(lambda tourney: tourney.sit_n_go == 'n', self.service.tourneys.values()))
            self.failUnless(filter(lambda tourney: tourney.name == 'regular1', self.service.tourneys.values()))
        d.addCallback(checkTourneys)
        reactor.callLater(3, lambda: d.callback(True))

        return d

    # ----------------------------------------------------------------
    def test14_checkTourneysSchedule_cancel_regular(self):
        pokerservice.DELETE_OLD_TOURNEYS_DELAY = 0
        pokerservice.UPDATE_TOURNEYS_SCHEDULE_DELAY = 1
        pokerservice.CHECK_TOURNEYS_SCHEDULE_DELAY = 0.1

        #
        # A regular tournament starts registration now
        #
        cursor = self.db.cursor()
        cursor.execute("UPDATE tourneys_schedule " +
                       " SET register_time = " + str(testclock._seconds_value) + ", " +
                       "     start_time = " + str(testclock._seconds_value + 10) + ", " +
                       "     respawn = 'n' " +
                       " WHERE name = 'regular1'")
        self.assertEqual(1, cursor.rowcount)
        cursor.close()

        self.service.startService()
        self.createUsers()

        #
        # Register a user who will be re-imbursed when the tournament is canceled
        #
        d1 = defer.Deferred()
        def registerPlayer(status):
            (regular,) = filter(lambda tourney: tourney.name == 'regular1', self.service.tourneys.values())
            self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                    game_id = regular.serial))
            self.assertEquals(self.default_money - regular.buy_in - regular.rake, self.service.getMoney(self.user1_serial, 1))
            self.assertEquals([ self.user1_serial ], regular.players)

        d1.addCallback(registerPlayer)
        reactor.callLater(5, lambda: d1.callback(True))

        d2 = defer.Deferred()
        def checkTourneys(status):
            self.assertEquals([], filter(lambda tourney: tourney['name'] == 'regular1', self.service.tourneys_schedule.values()))
            self.assertEquals([], filter(lambda tourney: tourney.name == 'regular1', self.service.tourneys.values()))
            self.assertEquals(self.default_money, self.service.getMoney(self.user1_serial, 1))
        d2.addCallback(checkTourneys)
        reactor.callLater(15, lambda: d2.callback(True))

        return defer.DeferredList((d1, d2), fireOnOneErrback = True)

    # ----------------------------------------------------------------
    def test15_runTourney(self):
        pokerservice.UPDATE_TOURNEYS_SCHEDULE_DELAY = 1
        pokerservice.CHECK_TOURNEYS_SCHEDULE_DELAY = 0.1

        self.service.startService()
        self.createUsers()

        client1 = self.ClientMockup(self.user1_serial)
        self.service.serial2client[self.user1_serial] = client1

        (heads_up,) = filter(lambda tourney: tourney.name == 'sitngo2', self.service.tourneys.values())
        clear_all_messages()
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = heads_up.serial))
        self.assertEquals(get_messages(), ['tourneyRegister: UPDATE user2money SET amount = amount - 300000 WHERE user_serial = %d AND        currency_serial = 1 AND        amount >= 300000' % self.user1_serial,
'tourneyRegister: INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, 1)' % self.user1_serial])
        clear_all_messages()
        self.assertEquals(len(client1.packets), 1)
        self.assertEquals(client1.packets[0].type, PACKET_POKER_TOURNEY_REGISTER)
        self.assertEquals(client1.packets[0].serial, self.user1_serial)
        self.assertEquals(client1.packets[0].game_id, heads_up.serial)
        client1.packets = []
        self.assertEquals(self.service.joined_count, 0)

        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user2_serial,
                                                                game_id = heads_up.serial))

        d = defer.Deferred()
        def checkTourneys(status):
            # joined_count should now be one, as the tourneyGameFilled() should
            # have been called, and we only had one client connected.
            self.assertEquals(self.service.joined_count, 1)
            self.assertEquals(len(client1.packets), 14)
            for p in client1.packets:
                self.assertEquals(p.game_id, self.service.tables.values()[2].game.id)
            self.assertEquals(len(client1.tables), 1)
            self.assertEquals(client1.tables.has_key(self.service.tables.values()[2].game.id), True)
            self.assertEquals(client1.tables[self.service.tables.values()[2].game.id], self.service.tables.values()[2])

            self.assertEquals(pokertournament.TOURNAMENT_STATE_RUNNING, heads_up.state)
            game = heads_up.games[0]
            in_position = game.getSerialInPosition()
            game.callNraise(in_position, game.maxBuyIn())
            in_position = game.getSerialInPosition()
            game.call(in_position)
            self.service.tables.values()[2].update() # two tables already in settings

        d.addCallback(checkTourneys)
        reactor.callLater(3, lambda: d.callback(True))

        return d

    # ----------------------------------------------------------------
    def test16_runTourney_freeroll(self):
        return self.runTourney_freeroll(True)

    # ----------------------------------------------------------------
    def test17_runTourney_freeroll(self):
        return self.runTourney_freeroll(False)

    # ----------------------------------------------------------------
    def runTourney_freeroll(self, has_bailor):
        pokerservice.UPDATE_TOURNEYS_SCHEDULE_DELAY = 1
        pokerservice.CHECK_TOURNEYS_SCHEDULE_DELAY = 0.1

        #
        # A regular tournament starts registration now
        #
        cursor = self.db.cursor()
        prize = 100
        cursor.execute("UPDATE tourneys_schedule SET currency_serial = 2, buy_in = 0, prize_min = %d WHERE name = 'sitngo2'" % prize )
        self.assertEqual(1, cursor.rowcount)
        cursor.close()

        self.service.startService()
        self.createUsers()

        (heads_up,) = filter(lambda tourney: tourney.name == 'sitngo2', self.service.tourneys.values())
        if has_bailor:
            heads_up.bailor_serial = self.user3_serial
        else:
            heads_up.bailor_serial = 42

        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = heads_up.serial))
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user2_serial,
                                                                game_id = heads_up.serial))

        d = defer.Deferred()
        def checkTourneys(status):
            self.assertEquals(pokertournament.TOURNAMENT_STATE_RUNNING, heads_up.state)
            game = heads_up.games[0]
            in_position = game.getSerialInPosition()
            game.callNraise(in_position, game.maxBuyIn())
            in_position = game.getSerialInPosition()
            game.call(in_position)
            self.service.tables.values()[2].update() # two tables already in settings
            if has_bailor:
                self.assertEquals(0, self.service.getMoney(self.user1_serial, 2), "bailor user1")
                self.assertEquals(prize, self.service.getMoney(self.user2_serial, 2), "bailor user2")
                self.assertEquals(self.default_money - prize, self.service.getMoney(self.user3_serial, 2), "bailor user3")
            else:
                self.assertEquals(0, self.service.getMoney(self.user1_serial, 2))
                self.assertEquals(0, self.service.getMoney(self.user2_serial, 2))
                self.assertEquals(self.default_money, self.service.getMoney(self.user3_serial, 2))

        d.addCallback(checkTourneys)
        reactor.callLater(15, lambda: d.callback(True))

        return d

    # ----------------------------------------------------------------
    def test18_cleanupTourneys_registering(self):
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO tourneys (serial, sit_n_go, name, start_time) VALUES (4000, 'n', 'regular3', " + str(testclock._seconds_value + 120) + ")")
        cursor.execute("INSERT INTO user2tourney VALUES (1, 1, 4000, 0, -1)")
        cursor.execute("INSERT INTO user2tourney VALUES (2, 1, 4000, 0, -1)")
        cursor.execute("INSERT INTO user2tourney VALUES (3, 1, 4000, 0, -1)")
        cursor.close()
        self.service.db = self.db
        self.service.dirs = ['@POKER_ENGINE_PKGSYSCONFDIR@']
        self.service.cleanupTourneys()
        tourney = self.service.tourneys[4000]
        self.assertEqual([1, 2, 3], tourney.players)
    # ----------------------------------------------------------------
    def test19_testJoinCounter(self):
        expectedMax = 1000
        val = 0
        self.service.startService()
        while val < expectedMax + 100:
            self.assertEquals(self.service.joinedCountIncrease(5), val+5)
            self.assertEquals(self.service.joinedCountDecrease(4), val+1)
            val += 1
            self.assertEquals(self.service.joinedCountReachedMax(),
                              val >= expectedMax)
        self.service.stopService()
    # ----------------------------------------------------------------
    def test20_spawnTourneyCurrencySerialFromDateFormat(self):
        cursor = self.db.cursor()
        currency_serial_from_date_format = '%Y%m'
        cursor.execute("UPDATE tourneys_schedule SET currency_serial_from_date_format = '%s' WHERE name = 'sitngo2'" % currency_serial_from_date_format)
        self.assertEqual(1, cursor.rowcount)
        cursor.close()
        self.service.today = lambda: date(1970, 01, 01)
        currency_serial_from_date = 197001L
        self.service.startService()
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        self.assertEqual(currency_serial_from_date_format, schedule["currency_serial_from_date_format"])
        cursor = self.db.cursor()
        cursor.execute("SELECT currency_serial from tourneys WHERE name = '%s'" % 'sitngo2')
        self.assertEqual(1, cursor.rowcount)
        currency_serial = cursor.fetchone()[0]
        cursor.close()
        self.assertEqual(currency_serial_from_date, currency_serial)
        tourney = self.service.tourneys[tourney_serial]
        self.assertEqual(False, hasattr(tourney, currency_serial_from_date_format))
        self.assertEqual(currency_serial_from_date, tourney.currency_serial)
    # ----------------------------------------------------------------
    def test21_today(self):
        self.assertEqual(self.service.today(), date.today())
    # ----------------------------------------------------------------
    def test22_spawnTourneyBadCurrencySerialFromDateFormat(self):
        cursor = self.db.cursor()
        cursor.execute("UPDATE tourneys_schedule SET currency_serial_from_date_format = 'NaN666' WHERE name = 'sitngo2'")
        cursor.close()
        self.assertRaises(UserWarning, self.service.startService)
    # ----------------------------------------------------------------
    def test23_localeChecks(self):
        self.service.startService()
        for enlo in ('this_locale_does_not_exist', 'en_GB.ISO-8859-1',
                     'en_US.ISO-8859-1', 'en_CA.ISO-8859-1'):
            self.assertEquals(self.service.locale2translationFunc(enlo)("Aces"), "Aces")
        clear_all_messages()
        self.assertEquals(self.service.locale2translationFunc('fr_FR', 'UTF-8'),
                         None)
        self.assertEquals(get_messages(), ['Locale, "fr_FR.UTF-8" not available.  fr_FR.UTF-8 must not have been provide via <language/> tag in settings, or errors occured during loading.'])
        enc = 'ISO-8859-1'
        self.assertEquals(self.service.locale2translationFunc('da_DK', enc)("%(name)s mucks loosing hand"), "%(name)s mucker tabende h\xe5nd")
        self.assertEquals(self.service.locale2translationFunc('de_DE', enc)("%(name)s raises %(amount)s"), '%(name)s erh\xf6ht %(amount)s' )
        self.assertEquals(self.service.locale2translationFunc('fi_FI', enc)("Board: %(board)s"), 'P\xf6yt\xe4kortit: %(board)s')
        for fr in ('fr_FR', 'fr_FX', 'fr_BE', 'fr_CA'):
            self.assertEquals(self.service.locale2translationFunc(fr, enc)("%(name)s receives %(amount)s"), '%(name)s re\xe7oit %(amount)s')
        self.assertEquals(self.service.locale2translationFunc('it_IT', enc)("High card %(card)s"),'Carta pi\xf9 alta: %(card)s')
        self.assertEquals(self.service.locale2translationFunc('nb_NO', enc)("%(name)s mucks loosing hand"), '%(name)s skjuler tapende h\xe5nd')
        self.assertEquals(self.service.locale2translationFunc('nl_NL', enc)("Four of a kind %(card)s"), 'Carr\xe9 %(card)s')
        self.assertEquals(self.service.locale2translationFunc('pt_PT', enc)("Rake %(amount)s"), 'Comiss\xe3o %(amount)s')
        self.assertEquals(self.service.locale2translationFunc('sv_SE', enc)("winners share a pot of %(pot)s"), 'vinnarna delar p\xe5 potten %(pot)s')
##############################################################################
class RefillTestCase(unittest.TestCase):

    def destroyDb(self):
        if len("@MYSQL_TEST_DBROOT_PASSWORD@") > 0:
            os.system("@MYSQL@ -u @MYSQL_TEST_DBROOT@ --password='@MYSQL_TEST_DBROOT_PASSWORD@' -h '@MYSQL_TEST_DBHOST@' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("@MYSQL@ -u @MYSQL_TEST_DBROOT@ -h '@MYSQL_TEST_DBHOST@' -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    def setUp(self):
        settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
        <server verbose="3">
        <listen tcp="19480" />
        <refill serial="1" amount="10000" />
        <delays />
        <path>@POKER_ENGINE_PKGSYSCONFDIR@ @POKER_NETWORK_PKGSYSCONFDIR@</path>
        <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
        <database name="pokernetworktest" host="@MYSQL_TEST_DBHOST@" user="pokernetworktest" password="pokernetwork"
            root_user="@MYSQL_TEST_DBROOT@" root_password="@MYSQL_TEST_DBROOT_PASSWORD@" schema="@srcdir@/../../database/schema.sql" command="@MYSQL@" />
        </server>
        """
        testclock._seconds_reset()
        self.destroyDb()
        self.service = pokerservice.PokerService(settings_xml)

    def tearDown(self):
        d = self.service.stopService()
        d.addCallback(lambda x: self.destroyDb())
        return d

    def test_refill(self):
        self.service.startService()
        refill = 10000
        ( (serial, name, privilege), message ) = self.service.auth("user1", "password1", "role1")
        self.assertEquals(0, self.service.autorefill(serial))
        table_money = 1000
        table_serial = 200
        self.service.db.db.query("INSERT INTO user2table VALUES (" + str(serial) + ", " + str(table_serial) + ", " + str(table_money) + ", 0)")
        self.service.db.db.query("INSERT INTO pokertables (serial, name, currency_serial, tourney_serial) VALUES (" + str(table_serial) + ", 'foo', 1, 0)")
        money_left = 100
        self.service.db.db.query("UPDATE user2money SET amount = " + str(money_left) + " WHERE user_serial = " + str(serial))
        self.assertEquals(refill - table_money, self.service.autorefill(serial))

class TimerTestCase(unittest.TestCase):

    def test_cancelTimers(self):
        settings = """<?xml version="1.0" encoding="ISO-8859-1"?>
        <server verbose="3">
        <delays />
        </server>
        """
        service = pokerservice.PokerService(settings)
        class Timer:
            def active(self):
                return False
        service.timer['foo_1'] = Timer()
        service.timer['foo_2'] = Timer()
        service.cancelTimers('foo')
        self.assertEqual([], service.timer.keys())

class TourneyUnregisterTestCase(PokerServiceTestCaseBase):

    def test_ok(self):
        tourney_serial = 100
        self.service.startService()
        self.createUsers()
        user_serial = self.user1_serial
        tourney = pokertournament.PokerTournament(serial = tourney_serial,
                                                  dirs = ['@POKER_ENGINE_PKGSYSCONFDIR@'])
        tourney.currency_serial = 1
        self.service.tourneys[tourney_serial] = tourney
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = tourney_serial))
        packet = PacketPokerId(serial = user_serial,
                               game_id = tourney_serial)
        return_packet = self.service.tourneyUnregister(packet)
        self.assertEqual(packet, return_packet)

    def test_does_not_exist(self):
        tourney_serial = 100
        user_serial = 1
        self.service.startService()
        p = self.service.tourneyUnregister(PacketPokerId(serial = user_serial,
                                                         game_id = tourney_serial))
        self.assertEqual(PacketPokerTourneyUnregister.DOES_NOT_EXIST, p.code)

    def test_not_registered(self):
        tourney_serial = 100
        user_serial = 1
        self.service.startService()
        tourney = pokertournament.PokerTournament(serial = tourney_serial,
                                                  dirs = ['@POKER_ENGINE_PKGSYSCONFDIR@'])
        self.service.tourneys[tourney_serial] = tourney
        p = self.service.tourneyUnregister(PacketPokerId(serial = user_serial,
                                                         game_id = tourney_serial))
        self.assertEqual(PacketPokerTourneyUnregister.NOT_REGISTERED, p.code)

    def test_too_late(self):
        tourney_serial = 100
        user_serial = 1
        self.service.startService()
        tourney = pokertournament.PokerTournament(serial = tourney_serial,
                                                  dirs = ['@POKER_ENGINE_PKGSYSCONFDIR@'])
        tourney.register(user_serial)
        tourney.currency_serial = 1
        tourney.state = pokertournament.TOURNAMENT_STATE_RUNNING
        self.service.tourneys[tourney_serial] = tourney
        p = self.service.tourneyUnregister(PacketPokerId(serial = user_serial,
                                                         game_id = tourney_serial))
        self.assertEqual(PacketPokerTourneyUnregister.TOO_LATE, p.code)

    def test_no_user2money(self):
        tourney_serial = 100
        user_serial = 1
        self.service.startService()
        tourney = pokertournament.PokerTournament(serial = tourney_serial,
                                                  dirs = ['@POKER_ENGINE_PKGSYSCONFDIR@'])
        tourney.register(user_serial)
        tourney.currency_serial = 1
        tourney.buy_in = 1000
        self.service.tourneys[tourney_serial] = tourney
        p = self.service.tourneyUnregister(PacketPokerId(serial = user_serial,
                                                         game_id = tourney_serial))
        self.assertEqual(PacketPokerTourneyUnregister.SERVER_ERROR, p.code)
        self.assertTrue("not in user2money" in p.message)

    def test_no_user2tourney(self):
        tourney_serial = 100
        self.service.startService()
        self.createUsers()
        user_serial = self.user1_serial
        tourney = pokertournament.PokerTournament(serial = tourney_serial,
                                                  dirs = ['@POKER_ENGINE_PKGSYSCONFDIR@'])
        tourney.register(user_serial)
        tourney.currency_serial = 1
        self.service.tourneys[tourney_serial] = tourney
        p = self.service.tourneyUnregister(PacketPokerId(serial = user_serial,
                                                         game_id = tourney_serial))
        self.assertEqual(PacketPokerTourneyUnregister.SERVER_ERROR, p.code)
        self.assertTrue("not in user2tourney" in p.message)

class TourneyCancelTestCase(PokerServiceTestCaseBase):
    def test_ok(self):
        class Tournament:
            def __init__(self):
                self.players = [1]
                self.serial = 1

        self.service.tourneys = {}
        self.service.tourneyCancel(Tournament())
        if verbose < 0:
            self.assertTrue(search_output('tourneyCancel:'))

class TourneyManagerTestCase(PokerServiceTestCaseBase):

    class ClientMockup:
        def __init__(self, serial):
            self.serial = serial
            self.tableJoined = None
            self.packets = []

        def join(self, table):
            self.tableJoined = table

        def sendPacketVerbose(self, packet):
            self.packets.append(packet)

    def test01_no_rank(self):
        self.service.startService()
        self.service.verbose = 6
        self.createUsers()
        user_serial = self.user1_serial
        table_serial = 606
        table_money = 140
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        # One client (user1) has a Client logged in
        client1 = TourneyManagerTestCase.ClientMockup(self.user1_serial)
        self.service.serial2client[self.user1_serial] = client1
        self.service.spawnTourney(schedule)
        clear_all_messages()
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = tourney_serial))
        self.assertEquals(get_messages(), ['tourneyRegister: UPDATE user2money SET amount = amount - 300000 WHERE user_serial = 4 AND        currency_serial = 1 AND        amount >= 300000', 'tourneyRegister: INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (4, 1, 1)'])
        self.assertEquals(len(client1.packets), 1)
        self.assertEquals(client1.packets[0].type, PACKET_POKER_TOURNEY_REGISTER)
        self.assertEquals(client1.packets[0].serial, self.user1_serial)
        self.assertEquals(client1.packets[0].game_id, tourney_serial)
        client1.packets = []
        self.assertEquals(client1.tableJoined, None)
        self.service.db.db.query("INSERT INTO user2table VALUES (" + str(self.user1_serial) + ", " + str(table_serial) + ", " + str(table_money) + ", 0)")
        self.service.db.db.query("UPDATE user2tourney SET table_serial = " + str(table_serial))
        self.service.tourneys[tourney_serial].can_register = False
        clear_all_messages()
        packet = self.service.tourneyManager(tourney_serial)
        self.assertEquals(get_messages(), [])
        self.assertEqual(tourney_serial, packet.tourney['serial'])
        self.assertNotEqual(None, packet.tourney['rank2prize'])
        self.assertEqual(1, packet.tourney['registered'])
        self.assertEqual({'4' : {'rank': -1,
                                 'table_serial': table_serial,
                                 'name' : 'user1',
                                 'money': table_money}}, packet.user2properties)

    def test02_no_money_no_table(self):
        self.service.startService()
        self.createUsers()
        user_serial = self.user1_serial
        table_serial = 606
        table_money = 140
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        self.service.spawnTourney(schedule)
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = tourney_serial))
        packet = self.service.tourneyManager(tourney_serial)
        self.assertEqual(tourney_serial, packet.tourney['serial'])
        self.assertEqual(1, packet.tourney['registered'])
        self.assertEqual({'4' : {'rank': -1,
                                 'table_serial': None,
                                 'name' : 'user1',
                                 'money': -1}}, packet.user2properties)

    def test03_player_removed(self):
        self.service.startService()
        self.createUsers()
        user_serial = self.user1_serial
        table_serial = 606
        table_money = 140
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        self.service.spawnTourney(schedule)
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = tourney_serial))
        table_serial = -1
        self.service.db.db.query("UPDATE user2tourney SET table_serial = " + str(table_serial))
        packet = self.service.tourneyManager(tourney_serial)
        self.assertEqual(tourney_serial, packet.tourney['serial'])
        self.assertEqual(1, packet.tourney['registered'])
        self.assertEqual(0, len(packet.table2serials))

class TourneyMovePlayerTestCase(PokerServiceTestCaseBase):

    tourney_serial = 10

    class Tournament:
        def __init__(self):
            self.serial = TourneyMovePlayerTestCase.tourney_serial

    class Table:
        def __init__(self):
            self.serial2client = {}

        def movePlayer(self, client, serial, to_game_id):
            pass

    def test_ok(self):
        self.service.startService()
        self.service.getTable = lambda from_game_id: TourneyMovePlayerTestCase.Table()
        user_serial = 1
        table_serial = 100
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial, table_serial) VALUES (%d, %d, %d, %d)" % ( user_serial, 1, TourneyMovePlayerTestCase.tourney_serial, table_serial ))
        self.assertTrue(self.service.tourneyMovePlayer(TourneyMovePlayerTestCase.Tournament(), table_serial, 200, user_serial))
        cursor.close()

    def test_missing_db_record(self):
        self.service.startService()
        self.service.getTable = lambda from_game_id: TourneyMovePlayerTestCase.Table()
        user_serial = 1
        table_serial = 100
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial, table_serial) VALUES (%d, %d, %d, %d)" % ( user_serial, 1, TourneyMovePlayerTestCase.tourney_serial, table_serial ))
        wrong_user_serial = 2
        self.assertFalse(self.service.tourneyMovePlayer(TourneyMovePlayerTestCase.Tournament(), table_serial, 200, wrong_user_serial))
        cursor.close()

class ListHandsTestCase(PokerServiceTestCaseBase):

    def test_ok(self):
        self.service.startService()
        ( total, hands ) = self.service.listHands("SELECT '1'", "SELECT '2'")
        self.assertEqual(["1"], hands)
        self.assertEqual("2", total)

class SetAccountTestCase(PokerServiceTestCaseBase):

    def test_insert_ok(self):
        self.service.startService()
        affiliate = 3
        info = self.service.setAccount(PacketPokerSetAccount(name = 'test08_1',
                                                             password = 'PASSWORD',
                                                             email = 'test08_1@HOME.COM',
                                                             affiliate = affiliate,
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        self.assertEquals(affiliate, info.affiliate)
        packed = info.pack()
        other_info = PacketPokerPersonalInfo()
        other_info.unpack(packed)
        self.assertEquals('1980-01-01', other_info.birthdate)

    def test_update_ok(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                             password = 'password1',
                                                             email = 'a@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        serial = info.serial
        info = self.service.setAccount(PacketPokerSetAccount(serial = serial,
                                                             name = 'user1',
                                                             password = 'password2',
                                                             email = 'a@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)

    def test_setPersonalInfo_fail(self):
        self.service.startService()
        self.service.setPersonalInfo = lambda x: False
        info = self.service.setAccount(PacketPokerSetAccount(name = 'test08_1',
                                                             password = 'PASSWORD',
                                                             email = 'test08_1@HOME.COM',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals("unable to set personal information", info.message)
        self.assertEquals(PacketPokerSetAccount.SERVER_ERROR, info.code)

    def test_name_already_exists(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                             password = 'password1',
                                                             email = 'a@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        serial = info.serial
        info = self.service.setAccount(PacketPokerSetAccount(serial = 10001,
                                                             email = 'a@b.c',
                                                             name = 'user1'))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.NAME_ALREADY_EXISTS, info.code)

    def test_email_already_exists(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                             password = 'password1',
                                                             email = '1@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        serial = info.serial
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user2',
                                                             password = 'password2',
                                                             email = '2@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        info = self.service.setAccount(PacketPokerSetAccount(serial = serial,
                                                             name = 'user1',
                                                             email = '2@b.c'))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.EMAIL_ALREADY_EXISTS, info.code)

    def test_update_duplicate_serial(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                             password = 'password1',
                                                             email = 'a@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        serial = info.serial
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user2',
                                                             password = 'password2',
                                                             email = '2@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        cursor = self.db.cursor()
        cursor.execute('ALTER TABLE users CHANGE COLUMN serial s1 INT UNSIGNED NOT NULL AUTO_INCREMENT')
        cursor.execute('ALTER TABLE users ADD COLUMN serial INT UNSIGNED NOT NULL')
        cursor.execute('DROP INDEX name_idx ON users')
        cursor.execute('DROP INDEX email_idx ON users')
        cursor.execute('UPDATE users SET serial = %d' % serial)
        info = self.service.setAccount(PacketPokerSetAccount(serial = serial,
                                                             name = 'user1',
                                                             password = 'password4',
                                                             email = 'a@b.c'))
        self.assertEquals(info.type, PACKET_ERROR)
        self.assertEquals(PacketPokerSetAccount.SERVER_ERROR, info.code)

    def test_name_error(self):
        info = self.service.setAccount(PacketPokerSetAccount(name = 'ab'))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.NAME_TOO_SHORT, info.code)

    def test_password_error(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'abcdef',
                                                             password = ''))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.PASSWORD_TOO_SHORT, info.code)

    def test_email_error(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'abcdef',
                                                             password = 'ABCDEF',
                                                             email = ''))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.INVALID_EMAIL, info.code)

    def test_email_duplicate(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                             password = 'password1',
                                                             email = 'a@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user2',
                                                             password = 'password2',
                                                             email = 'a@b.c'))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.EMAIL_ALREADY_EXISTS, info.code)

    def test_user_private_duplicate(self):
        self.service.startService()
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO users_private (serial) VALUES (4)")
        cursor.close()
        raised = False
        try:
            info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                                 password = 'password1',
                                                                 email = 'a@b.c',
                                                                 birthdate = '1980/01/01'))
        except IntegrityError:
            raised = True
        self.assertTrue(raised)

class ShutdownCheckTestCase(PokerServiceTestCaseBase):

    class PokerGame:
        def isEndOrNull(self):
            return not self.playing

    class PokerTable:
        def __init__(self):
            self.game = ShutdownCheckTestCase.PokerGame()


    def tearDown(self):
        pass

    def test_down(self):
        self.deferred_called = False
        def c(x):
            self.deferred_called = True
        d = defer.Deferred()
        d.addCallback(c)
        self.service.shutdown_deferred = d
        self.service.down = True
        self.service.shutdownCheck()
        self.assertTrue(self.deferred_called)
        del self.deferred_called

    def test_ok(self):
        table = ShutdownCheckTestCase.PokerTable()
        table.game.playing = True
        self.service.tables = { 1: table }
        self.service.down = False
        d = defer.Deferred()
        self.service.shutdown_deferred = d
        self.service.shutdownCheck()
        self.assertEqual(d, self.service.shutdown_deferred)
        table.game.playing = False
        def f(status):
            self.assertTrue(self.service.down)
            return status
        d.addCallback(f)
        return d

class TourneyFinishedTestCase(PokerServiceTestCaseBase):

    class ClientMockup:
        def __init__(self, serial):
            self.serial = serial
#            self.tableJoined = None
            self.packets = []

        def join(self, table):
            self.tableJoined = table

        def sendPacketVerbose(self, packet):
            self.packets.append(packet)

    def test_ok(self):
        class Tournament:
            def __init__(self):
                self.prize_min = 10
                self.buy_in = 0
                self.registered = 2
                self.currency_serial = 1
                self.serial = 1

            def prizes(self):
                return [self.prize_min]
        self.service.startService()
        self.createUsers()
        client1 = self.ClientMockup(self.user1_serial)
        self.service.serial2client[self.user1_serial] = client1
        tournament = Tournament()
        winner_serial = self.user1_serial
        tournament.winners = [ winner_serial ]
        tournament.bailor_serial = self.user2_serial
        self.service.tourneyFinished(tournament)
        cursor = self.db.cursor()
        cursor.execute("SELECT amount FROM user2money WHERE user_serial = %d" % winner_serial)
        (amount,) = cursor.fetchone()
        self.assertEqual(self.default_money + tournament.prize_min, amount)
        cursor.close()

    def test_no_bailor(self):
        class Tournament:
            def __init__(self):
                self.prize_min = 10
                self.buy_in = 0
                self.registered = 2
                self.currency_serial = 1
                self.serial = 1

            def prizes(self):
                return [self.prize_min]
        self.service.startService()
        self.createUsers()
        tournament = Tournament()
        winner_serial = 10
        tournament.winners = [ winner_serial ]
        tournament.bailor_serial = 2000
        self.assertEqual(False, self.service.tourneyFinished(tournament))
        if verbose < 0:
            self.assertTrue(search_output("bailor failed to provide requested money"))

    def test_bailor_zero(self):
        class Tournament:
            def __init__(self):
                self.prize_min = 10
                self.buy_in = 0
                self.registered = 2
                self.currency_serial = 1
                self.serial = 1

            def prizes(self):
                return [self.prize_min]
        self.service.startService()
        self.createUsers()
        tournament = Tournament()
        winner_serial = 10
        tournament.winners = [ winner_serial ]
        tournament.bailor_serial = 0
        self.assertEqual(True, self.service.tourneyFinished(tournament))

    def test_tourney_finish(self):
        class Tournament:
            def __init__(self):
                self.prize_min = 10
                self.buy_in = 0
                self.registered = 2
                self.currency_serial = 1
                self.serial = 1
                self.finish_time = testclock._seconds_value

            def prizes(self):
                return [self.prize_min]
        self.service.startService()
        self.createUsers()
        client1 = self.ClientMockup(self.user1_serial)
        self.service.serial2client[self.user1_serial] = client1
        tournament = Tournament()
        winner_serial = self.user1_serial
        tournament.winners = [ winner_serial ]
        tournament.bailor_serial = self.user2_serial
        self.service.tourneyFinished(tournament)
        cursor = self.db.cursor()
        cursor.execute("SELECT finish_time FROM tourneys WHERE serial = %d" % tournament.serial)
        (finish_time,) = cursor.fetchone()
        self.failUnless(tournament.finish_time - finish_time < 1)
        cursor.close()

    def test_delete_route(self):
        class Tournament:
            def __init__(self):
                self.prize_min = 10
                self.buy_in = 0
                self.registered = 2
                self.currency_serial = 1
                self.serial = 1

            def prizes(self):
                return [self.prize_min]
        self.service.startService()
        self.createUsers()
        client1 = self.ClientMockup(self.user1_serial)
        self.service.serial2client[self.user1_serial] = client1
        tournament = Tournament()
        winner_serial = self.user1_serial
        tournament.winners = [ winner_serial ]
        tournament.bailor_serial = self.user2_serial
        self.service._ping_delay = 1
        d = defer.Deferred()
        d.addCallback(self.service.tourneyDeleteRouteActual)
        self.service.tourneyDeleteRouteActual = d.callback
        self.service.tourneyFinished(tournament)
        cursor = self.db.cursor()
        cursor.execute("SELECT tourney_serial FROM route WHERE tourney_serial = %s", tournament.serial)
        self.assertEqual(1, cursor.rowcount)
        (tournament_serial,) = cursor.fetchone()
        self.assertEqual(tournament.serial, tournament_serial)
        self.secondsStart = testclock._seconds_value
        def checkRoute(x):
            cursor.execute("SELECT tourney_serial FROM route WHERE tourney_serial = %s", tournament.serial)
            self.assertEqual(0, cursor.rowcount)
            self.assertEquals(testclock._seconds_value - self.secondsStart  >= self.service._ping_delay/1000.0, True)
            cursor.close()
        d.addCallback(checkRoute)
        return d

    def test_delete_route_table_delay(self):
        class Tournament:
            def __init__(self):
                self.prize_min = 10
                self.buy_in = 0
                self.registered = 2
                self.currency_serial = 1
                self.serial = 1

            def prizes(self):
                return [self.prize_min]
        self.service.startService()
        self.createUsers()
        client1 = self.ClientMockup(self.user1_serial)
        self.service.serial2client[self.user1_serial] = client1
        tournament = Tournament()
        winner_serial = self.user1_serial
        tournament.winners = [ winner_serial ]
        tournament.bailor_serial = self.user2_serial
        self.service._ping_delay = 1
        self.service.delays['extra_wait_tourney_finish'] = "40"
        d = defer.Deferred()
        d.addCallback(self.service.tourneyDeleteRouteActual)
        self.service.tourneyDeleteRouteActual = d.callback        
        self.service.tourneyFinished(tournament)
        cursor = self.db.cursor()
        cursor.execute("SELECT tourney_serial FROM route WHERE tourney_serial = %s", tournament.serial)
        self.assertEqual(1, cursor.rowcount)
        (tournament_serial,) = cursor.fetchone()
        self.assertEqual(tournament.serial, tournament_serial)
        self.secondsStart = testclock._seconds_value
        def checkRoute(x):
            cursor.execute("SELECT tourney_serial FROM route WHERE tourney_serial = %s", tournament.serial)
            self.assertEqual(0, cursor.rowcount)
            self.assertEquals(testclock._seconds_value - self.secondsStart  >= int(self.service.delays['extra_wait_tourney_finish']), True)
        d.addCallback(checkRoute)
        return d           

##############################################################################
class BreakTestCase(PokerServiceTestCaseBase):
    class Table:
        def __init__(self):
            self.message = None
            self.type = None
            self.destroyCalled = 0

        def broadcastMessage(self, type, message):
            self.type = type
            self.message = message

        def scheduleAutoDeal(self):
            self.autodeal = 1

    class Database:
        class Cursor:
            def execute(self, sql):
                self.sql = sql
                self.rowcount = 1

            def close(self):
                pass

        def cursor(self):
            self._cursor = BreakTestCase.Database.Cursor()
            return self._cursor

        def close(self):
            pass

    class Tournament:
        def __init__(self):
            self.serial = 1
            self.start_time = 1
    # ------------------------------------------------------------------------
    def test01_tourneyNewState_simpleTransitions(self):
        def ok(tourney):
            self.callCount += 1
        def notok(tourney):
            self.failIf(1)

        saveDb = self.service.db
        self.callCount = 0

        self.service.db = BreakTestCase.Database()
        self.service.tourneyBreakCheck = notok
        self.service.tourneyDeal = notok
        self.service.tourneyBreakWait = notok
        self.service.tourneyBreakResume = notok
        self.service.tourneyDestroyGame = notok

        self.service.tourneyBreakWait = ok
        self.service.tourneyNewState(BreakTestCase.Tournament(),
             pokertournament.TOURNAMENT_STATE_RUNNING, pokertournament.TOURNAMENT_STATE_BREAK_WAIT)
        self.assertEquals(self.callCount, 1)
        self.service.tourneyBreakWait = notok
        self.callCount = 0
        self.service.db = saveDb
    # ------------------------------------------------------------------------
    def tourneyNewState_tourneyResumeAndDeal(self, waitMin, waitMax):
        """Helper function for testing tourneyResumeAndDeal state change.
        The wait for the action must be between waitMin and waitMax"""

        self.service.startService()
        saveDb = self.service.db

        # First, Setup functions that should not be caled and force them
        # to fail

        def notok(tourney):
            self.failIf(1)

        self.service.db = BreakTestCase.Database()
        self.service.tourneyBreakCheck = notok
        self.service.tourneyDeal = notok
        self.service.tourneyBreakWait = notok
        self.service.tourneyBreakResume = notok
        self.service.tourneyDestroyGame = notok

        # Next, create deferreds that must be called.  Since the deferred
        # callbacks are in the function, we will get a reactor 120 second
        # timeout error if these functions are not called.  They also use
        # callCount to make sure they aren't called too often.

        tourneyBreakResumeDeferred = defer.Deferred()
        def confirmTourneyBreakResume(tourney):
            # Note that when asserts in here fail, it is just a reactor error
            self.assertEquals(testclock._seconds_value - self.secondsStart  >= waitMin, True)
            self.assertEquals(testclock._seconds_value - self.secondsStart  <= waitMax, True)
            self.assertEquals(self.callCount, 0)
            self.callCount += 1
            tourneyBreakResumeDeferred.callback(True)

        tourneyDealDeferred = defer.Deferred()
        def confirmTourneyDeal(tourney):
            self.assertEquals(self.callCount, 1)
            self.callCount += 1
            tourneyDealDeferred.callback(True)

        self.callCount = 0
        self.service.tourneyBreakResume = confirmTourneyBreakResume
        self.service.tourneyDeal = confirmTourneyDeal
        self.secondsStart = testclock._seconds_value

        self.service.tourneyNewState(BreakTestCase.Tournament(), pokertournament.TOURNAMENT_STATE_BREAK, pokertournament.TOURNAMENT_STATE_RUNNING)

        self.service.db = saveDb
        return defer.DeferredList((tourneyBreakResumeDeferred, tourneyDealDeferred), fireOnOneErrback = True)

    def test02_tourneyNewState_tourneyResumeAndDeal_nowait(self):
        return self.tourneyNewState_tourneyResumeAndDeal(0, 5)

    def test03_tourneyNewState_tourneyResumeAndDeal_withWait(self):
        self.service.delays['extra_wait_tourney_break'] = "40"
        return self.tourneyNewState_tourneyResumeAndDeal(40, 45)
    # ------------------------------------------------------------------------
    def tourneyNewState_tourneyStart(self, waitMin, waitMax):
        """Helper function for testing tourney starting state change.
        The wait for the action must be between waitMin and waitMax"""

        self.service.startService()
        saveDb = self.service.db

        # First, Setup functions that should not be caled and force them
        # to fail

        def notok(tourney):
            self.failIf(1)

        self.service.db = BreakTestCase.Database()
        self.service.tourneyBreakCheck = notok
        self.service.tourneyDeal = notok
        self.service.tourneyBreakWait = notok
        self.service.tourneyBreakResume = notok
        self.service.tourneyDestroyGame = notok

        # Next, create deferreds that must be called.  Since the deferred
        # callbacks are in the function, we will get a reactor 120 second
        # timeout error if these functions are not called.  They also use
        # callCount to make sure they aren't called too often.

        def confirmTourneyDeal(tourney):
            self.assertEquals(testclock._seconds_value - self.secondsStart  >= waitMin, True)
            self.assertEquals(testclock._seconds_value - self.secondsStart  <= waitMax, True)
            self.assertEquals(self.callCount, 0)
            self.callCount += 1
            tourneyDealDeferred.callback(True)

        tourneyDealDeferred = defer.Deferred()

        self.callCount = 0
        self.service.tourneyDeal = confirmTourneyDeal
        self.secondsStart = testclock._seconds_value

        self.service.tourneyNewState(BreakTestCase.Tournament(), pokertournament.TOURNAMENT_STATE_REGISTERING, pokertournament.TOURNAMENT_STATE_RUNNING)

        self.service.db = saveDb
        return tourneyDealDeferred

    def test04_tourneyNewState_tourneyStart_nowait(self):
        return self.tourneyNewState_tourneyStart(0, 5)

    def test05_tourneyNewState_tourneyStart_withWait(self):
        self.service.delays['extra_wait_tourney_start'] = "40"
        return self.tourneyNewState_tourneyStart(40, 45)
    # ------------------------------------------------------------------------
    def tourneyFinish(self, waitMin, waitMax):
        """Helper function for testing tourney Finish callback.
        The wait for the action must be between waitMin and waitMax"""

        self.service.startService()
        saveDb = self.service.db
        saveTables = self.service.tables

        # Create a deferred that our MockTable will call when it is
        # destroyed, since that is the last function called by
        # tourneyDestroyGameActual().  If the callback isn't done, we will
        # get a reactor 120 second timeout error, so we can thus confirm
        # that DestroyGameActual got called

        tableDestroyDeferred = defer.Deferred()
        class MockTable:
            def __init__(self):
                self.destroyCalled = 0
            def destroy(table):
                self.assertEquals(testclock._seconds_value - self.secondsStart  >= waitMin, True)
                self.assertEquals(testclock._seconds_value - self.secondsStart  <= waitMax, True)
                self.assertEquals(table.destroyCalled, 0)
                table.destroyCalled += 1
                tableDestroyDeferred.callback(True)
                self.service.tables = saveTables

        ourTable  = MockTable()
        class MockGame:
            def __init__(game):
                game.id = 1102

        ourTable.game = MockGame()
        self.service.tables = { 1102: ourTable }

        def notok(tourney):
            self.failIf(1)

        self.service.db = BreakTestCase.Database()
        self.service.tourneyBreakCheck = notok
        self.service.tourneyDeal = notok
        self.service.tourneyBreakWait = notok
        self.service.tourneyBreakResume = notok
        self.service.tourneyDeal =  notok

        self.secondsStart = testclock._seconds_value
        self.service.tourneyDestroyGame(None, ourTable.game)

        self.service.db = saveDb
        return tableDestroyDeferred

    def test06_tourneyFinish_nowait(self):
        return self.tourneyFinish(0, 5)

    def test07_tourneyFinish_withWait(self):
        self.service.delays['extra_wait_tourney_finish'] = "40"
        return self.tourneyFinish(40, 45)
    # ------------------------------------------------------------------------
    def test08_tourneyNewState_tourneyBreak(self):
        """test08_tourneyNewState_tourneyBreak

        This test is a bit more complicated than the previous, since when
        entering the break state, we need to check to see that broadcast
        packets were sent."""
        def ok(tourney): self.callCount += 1
        def notok(tourney): self.failIf(1)

        saveDb = self.service.db
        self.callCount = 0

        # The complexity of this test requires mock-ups of its own,
        # specifically to handle the making sure the seconds to resume are
        # computed correctly and the packets are sent to the tables as
        # needed.

        class Table(BreakTestCase.Table):
            def __init__(self):
                self.broadcastedPackets = []
                BreakTestCase.Table.__init__(self)

            def broadcast(self, packet):
                self.broadcastedPackets.append(packet)
        tables = {}
        tables[1] = Table()
        tables[2] = Table()
        #the following gives me syntax error
        #class  Game:
        class Game:
            def __init__(self, newId=0):
                self.id = newId
            def getTable(gameId):
                if gameId == 1: return tables[1]
                elif  gameId == 2: return tables[2]
                else: self.failIf(True)

        class Tournament(BreakTestCase.Tournament):
            def __init__(self, remainingSeconds = None):
                self.remaining_secs = remainingSeconds
                self.breaks_duration = 120
                self.games = [ Game(1), Game(2) ]
                BreakTestCase.Tournament.__init__(self)

            def remainingBreakSeconds(self):
                return self.remaining_secs

        self.service.db = BreakTestCase.Database()
        self.service.tables = { 1 : tables[1], 2 : tables[2] }
        self.service.tourneyBreakCheck = ok

        self.service.tourneyDeal = notok
        self.service.tourneyBreakWait = notok
        self.service.tourneyBreakResume = notok
        self.service.tourneyDestroyGame = notok

        # When we enter the break state, we should see Begin packets
        # sent.

        # First test here: see what happens when tourney.remaining_secs()
        # is None, thus yielding a return of None from
        # tourney.remainingBreakSeconds().  In this case, we should see
        # the resume_time as the current time, plus whatever
        # tourney.breaks_duration is.  Note that we also force a constant
        # resume_time by overriding time.time() to make sure it returns a
        # constant value.

        saveTime = time.time         # Time, time see what's become of me...
        time.time = lambda : 42
        self.service.tourneyNewState(Tournament(), pokertournament.TOURNAMENT_STATE_RUNNING, pokertournament.TOURNAMENT_STATE_BREAK)
        self.assertEquals(self.callCount, 1)
        for ii in [ 1, 2 ]:
            self.assertEquals(len(tables[ii].broadcastedPackets), 1)
            pp = tables[ii].broadcastedPackets[0]
            self.assertEquals(pp.game_id, ii)
            self.assertEquals(pp.type, PACKET_POKER_TABLE_TOURNEY_BREAK_BEGIN)
            self.assertEquals(pp.resume_time, 42 + 120)


        # Reset for next test below
        self.callCount = 0
        for ii in [ 1, 2 ]: tables[ii].broadcastedPackets = []

        # Second test here: see what happens when
        # tourney.remainingBreakSeconds() can return an actual integer
        # value.  This is forced by setting tourney.remaining_secs to 111
        # in __init__.  We should get a resume_time of the current time
        # plus the remaining seconds.

        time.time = lambda : 222
        self.service.tourneyNewState(Tournament(remainingSeconds = 111),
                                     pokertournament.TOURNAMENT_STATE_RUNNING, pokertournament.TOURNAMENT_STATE_BREAK)
        self.assertEquals(self.callCount, 1)
        for ii in [ 1, 2 ]:
            self.assertEquals(len(tables[ii].broadcastedPackets), 1)
            pp = tables[ii].broadcastedPackets[0]
            self.assertEquals(pp.game_id, ii)
            self.assertEquals(pp.type, PACKET_POKER_TABLE_TOURNEY_BREAK_BEGIN)
            self.assertEquals(pp.resume_time, 111+222)
        self.callCount = 0

        self.service.tourneyBreakCheck = notok
        self.service.db = saveDb
        time.time = saveTime
    # ------------------------------------------------------------------------
    def test_tourneyDeal(self):
        class Game:

            def __init__(self):
                self.id = 1

        class Tournament:
            def __init__(self):
                self.games = [ Game() ]
                self.serial = 1

        tourney = Tournament()
        table = BreakTestCase.Table()
        table.game = tourney.games[0]
        self.service.tables = { 1: table }
        self.service.tourneyDeal(tourney)
        self.failUnless(hasattr(table, 'autodeal'))

    def test_tourneyBreakWait(self):
        class Game:

            def __init__(self):
                self.id = 1
                self.running = False

            def isRunning(self):
                return self.running

        class Tournament:
            def __init__(self):
                self.games = [ Game() ]
                self.serial = 1

        tourney = Tournament()
        table = BreakTestCase.Table()
        table.game = tourney.games[0]
        self.service.tables = { 1: table }
        tourney.games[0].running = True
        self.service.tourneyBreakWait(tourney)
        self.failUnless("at the end of the hand" in table.message)
        tourney.games[0].running = False
        self.service.tourneyBreakWait(tourney)
        self.failUnless("finish their hand" in table.message)
    # ------------------------------------------------------------------------
    def test11_tourneyBreakResume(self):
        class Table(BreakTestCase.Table):
            def __init__(self):
                self.broadcastedPackets = []
                BreakTestCase.Table.__init__(self)
            def broadcast(self, packet):
                self.broadcastedPackets.append(packet)
        tables = {}
        tables[1] = Table()
        tables[2] = Table()
        #the following gives me a syntax error
        #class  Game:
        class Game:
            def __init__(self, newId=0):
                self.id = newId
            def getTable(gameId):
                if gameId == 1: return tables[1]
                elif  gameId == 2: return tables[2]
                else: self.failIf(True)
        class Tournament(BreakTestCase.Tournament):
            def __init__(self):
                self.games = [ Game(1), Game(2) ]
                BreakTestCase.Tournament.__init__(self)

        tourney = Tournament()
        self.service.tables = { 1: tables[1], 2: tables[2] }

        self.service.tourneyBreakResume(tourney)
        for ii in [ 1, 2 ]:
            self.assertEqual(tables[ii].message, "Tournament resumes")
            self.assertEqual(tables[ii].type, PacketPokerGameMessage)
            self.assertEquals(len(tables[ii].broadcastedPackets), 1)
            pp = tables[ii].broadcastedPackets[0]
            self.assertEquals(pp.game_id, ii)
            self.assertEquals(pp.type, PACKET_POKER_TABLE_TOURNEY_BREAK_DONE)

    # ------------------------------------------------------------------------
    def test_tourneyBreakCheck(self):

        class Game:

            def __init__(self):
                self.id = 1

        class Tournament:

            def __init__(self):
                self.state = pokertournament.TOURNAMENT_STATE_RUNNING
                self.remaining = 0
                self.games = [ Game() ]
                self.serial = 1

            def remainingBreakSeconds(self):
                return self.remaining

            def updateBreak(self):
                pass

        tourney = Tournament()
        table = BreakTestCase.Table()
        table.game = tourney.games[0]
        self.service.tables = { 1: table }
        self.service.tourneyBreakCheck(tourney)
        self.failIf(table.message)
        tourney.state = pokertournament.TOURNAMENT_STATE_BREAK
        self.service.tourneyBreakCheck(tourney)
        self.failUnless("less than a minute" in table.message)
        tourney.remaining = 60
        self.service.tourneyBreakCheck(tourney)
        self.failUnless("one minute" in table.message)
        tourney.remaining = 120
        self.service.tourneyBreakCheck(tourney)
        self.failUnless("2 minute" in table.message)

class UpdatePlayerRakeTestCase(PokerServiceTestCaseBase):

    def test_updatePlayerRake(self):
        self.service.startService()
        self.service.db = self.db
        cursor = self.db.cursor(DictCursor)
        cursor.execute("INSERT INTO user2money (user_serial, currency_serial, amount, points, rake) VALUES (101, 1, 10, 10, 10)")
        self.assertEqual(True, self.service.updatePlayerRake(1, 101, 5))
        cursor.execute("SELECT * FROM user2money WHERE user_serial = 101 AND currency_serial = 1")
        row = cursor.fetchone()
        self.assertEqual(15, row['rake'])
        self.assertEqual(15, row['points'])
        cursor.close()

##############################################################################
class PokerServiceCoverageTests(unittest.TestCase):
    # ----------------------------------------------------------------
    def setUp(self):
        testclock._seconds_reset()
        self.settings = pokernetworkconfig.Config([])
        self.settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        self.settings.header = self.settings.doc.xpathNewContext()
    # ----------------------------------------------------------------
    def tearDown(self):
        if hasattr(self, 'service'):
            d = self.service.stopService()
            return d
    # ----------------------------------------------------------------
    def test21_getPlayerInfo_validReturns(self):
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ "select locale,name,skin_url,skin_outfit"]
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                cursorSelf.rowcount = 1
                cursorSelf.row = ('ourlocal','ourname','ourskinurl',None)
                self.failUnless(found)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args): return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase()

        pack = self.service.getPlayerInfo(5)
        self.assertEquals(pack.locale, 'ourlocal')
        self.assertEquals(pack.name, 'ourname')
        self.assertEquals(pack.url, 'ourskinurl')
        self.assertEquals(pack.outfit, 'random')

        self.service.db = oldDb
# ----------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test00_02"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerServiceTestCase))
    suite.addTest(loader.loadClass(RefillTestCase))
    suite.addTest(loader.loadClass(TimerTestCase))
    suite.addTest(loader.loadClass(BreakTestCase))
    suite.addTest(loader.loadClass(TourneyFinishedTestCase))
    suite.addTest(loader.loadClass(TourneyUnregisterTestCase))
    suite.addTest(loader.loadClass(TourneyMovePlayerTestCase))
    suite.addTest(loader.loadClass(TourneyCancelTestCase))
    suite.addTest(loader.loadClass(TourneyManagerTestCase))
    suite.addTest(loader.loadClass(ShutdownCheckTestCase))
    suite.addTest(loader.loadClass(ListHandsTestCase))
    suite.addTest(loader.loadClass(SetAccountTestCase))
    suite.addTest(loader.loadClass(UpdatePlayerRakeTestCase))
    suite.addTest(loader.loadClass(MonitorTestCase))
    suite.addTest(loader.loadClass(ListTablesTestCase))
    suite.addTest(loader.loadClass(TourneySelectTestCase))
    suite.addTest(loader.loadClass(PlayerPlacesTestCase))
    suite.addTest(loader.loadClass(CleanUpTestCase))
    suite.addTest(loader.loadClass(ResthostTestCase))
    suite.addTest(loader.loadClass(PokerServiceCoverageTests))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
#       reporter.TextReporter,
#	tracebackFormat='verbose',
        tracebackFormat='default',
        ).run(suite)

# ----------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerservice.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokerservice.py' TESTS='coverage-reset test-pokerservice.py coverage-report' check )"
# End:

