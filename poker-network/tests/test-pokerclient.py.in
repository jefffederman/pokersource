#!@PYTHON@
# -*- py-indent-offset: 4; coding: iso-8859-1; mode: python -*-
#
# Copyright (C) 2007 Loic Dachary <loic@dachary.org>
# Copyright (C) 2006 Mekensleep
#
# Mekensleep
# 24 rue vieille du temple
# 75004 Paris
#       licensing@mekensleep.com
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Authors:
#  Loic Dachary <loic@gnu.org>
#

import sys, os
sys.path.insert(0, "@srcdir@/..")
sys.path.insert(0, "..")

import libxml2

#from pokerclient2d.poker2d import PokerClientFactory2D
import socket
import time
from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor, defer, error, base
from twisted.python import failure, runtime

from pokerengine import pokertournament

from pokernetwork import dispatch
twisted.internet.base.DelayedCall.debug = True

from pokerui import pokerinterface
from pokernetwork import pokerservice
from pokernetwork import pokernetworkconfig
from pokernetwork import pokerclient
from pokernetwork import currencyclient
currencyclient.CurrencyClient = currencyclient.FakeCurrencyClient
from pokernetwork.pokerclientpackets import *

#
# Tweak poker-engine & twisted to use a fake clock so that
# the tests are immune to the performances of the machine
# running the test, even when testing timeouts or other delays.
#
_seconds_value = time.time()
_seconds_original = _seconds_value
_seconds_verbose = int(os.environ.get('VERBOSE_T', '3'))
def _seconds_tick():
    global _seconds_value
    if _seconds_verbose > 3:
        print "tick: %.01f" % ( _seconds_value - _seconds_original )
    _seconds_value += 0.1
    return _seconds_value

base.seconds = _seconds_tick
#
# select timeout must return immediately, it makes no sense
# to wait while testing.
#
reactor.timeout = lambda: 0
runtime.seconds = _seconds_tick
pokertournament.tournament_seconds = _seconds_tick

class ConstantDeckShuffler:
    def shuffle(self, what):
        what[:] = [40, 13, 32, 9, 19, 31, 15, 14, 50, 34, 20, 6, 43, 44, 28, 29, 48, 3, 21, 45, 23, 37, 35, 11, 5, 22, 24, 30, 27, 39, 46, 33, 0, 8, 1, 42, 36, 16, 49, 2, 10, 26, 4, 18, 7, 41, 47, 17]

from pokerengine import pokergame
pokergame.shuffler = ConstantDeckShuffler()

class ConstantPlayerShuffler:
    def shuffle(self, what):
        what.sort()

pokertournament.shuffler = ConstantPlayerShuffler()

settings_xml_server = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="3" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="20" round="0" position="0" showdown="0" autodeal_max="1" finish="0" messages="60" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table3" variant="holdem" betting_structure="test18pokerclient" seats="10" player_timeout="600" muck_timeout="600" currency_serial="1" forced_dealer_seat="0" />

  <listen tcp="19480" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="@srcdir@/../../database/schema.sql" command="@MYSQL@" />
  <path>.. ../@srcdir@ @POKER_ENGINE_PKGSYSCONFDIR@ @POKER_NETWORK_PKGSYSCONFDIR@</path>
  <users temporary="BOT"/>
</server>
"""

settings_xml_client = """<?xml version="1.0" encoding="ISO-8859-1"?>
<settings display2d="yes" display3d="no" ping="15000" verbose="3" delays="true" tcptimeout="2000" upgrades="no">
   <delays blind_ante_position="0" position="0" begin_round="0" end_round="0" end_round_last="0" showdown="0" lag="60"/> 
  <screen fullscreen="no" width="1024" height="768"/>
  <name>user1</name>
  <passwd>password1</passwd>
  <remember>yes</remember>
  <muck>yes</muck>
  <auto_post>no</auto_post>
  <chat max_chars="40" line_length="20"/>
  <web browser="/usr/bin/firefox">http://localhost/poker-web/</web>
  <sound>yes</sound>
  <tournaments currency_serial="1" type="sit_n_go" sort="name"/>
  <lobby currency_serial="1" type="holdem" sort="name"/>
  <shadow>yes</shadow>
  <vprogram>yes</vprogram>
  
  <user path="~/.poker2d"/>
  <path>.. ../@srcdir@ @POKER_ENGINE_PKGSYSCONFDIR@ @POKER_NETWORK_PKGSYSCONFDIR@</path> 
  <rsync path="/usr/bin/rsync" dir="." source="rsync.pok3d.com::pok3d/linux-gnu" target="/tmp/installed" upgrades="share/poker-network/upgrades"/>
  <data path="data" sounds="data/sounds"/>
  <handlist start="0" count="10"/>
</settings>
"""

TABLE1 = 100
TABLE2 = 101
TABLE3 = 102

class PokerClientTestCase(unittest.TestCase):

    def destroyDb(self, arg = None):
        os.system("@MYSQL@ -u root -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    def setUpServer(self):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml_server, len(settings_xml_server))
        settings.header = settings.doc.xpathNewContext()
        #
        # Setup server
        #
        self.service = pokerservice.PokerService(settings)
        self.service.verbose = 3
        self.service.startService()
        factory = pokerservice.IPokerFactory(self.service)
        self.p = reactor.listenTCP(0, factory,
                                   interface="127.0.0.1")
        self.port = self.p.getHost().port

    def setUpClient(self, index):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml_client, len(settings_xml_client))
        settings.header = settings.doc.xpathNewContext()
        self.client_factory[index] = pokerclient.PokerClientFactory(settings = settings)
        def setUpProtocol(client):
            client._poll_frequency = 0.1
            return client
        d = self.client_factory[index].established_deferred
        d.addCallback(setUpProtocol)
        return d

    # ------------------------------------------------------
    def setUp(self):
        self.destroyDb()
        self.setUpServer()
        self.client_factory = [None, None]
        def connectClient1(client): 
            reactor.connectTCP('127.0.0.1', self.port, self.client_factory[1])
            return client

        d = self.setUpClient(0)
        d.addCallback(connectClient1)
        self.setUpClient(1)
        reactor.connectTCP('127.0.0.1', self.port, self.client_factory[0])

    def cleanSessions(self, arg):
        #
        # twisted Session code has leftovers : disable the hanging delayed call warnings
        # of trial by nuking all what's left.
        #
        pending = reactor.getDelayedCalls()
        if pending:
            for p in pending:
                if p.active():
#                    print "still pending:" + str(p)
                    p.cancel()
        return arg

    def tearDown(self):
        d = self.service.stopService()
        d.addCallback(lambda x: self.p.stopListening())
#        d.addCallback(self.destroyDb)
        d.addCallback(self.cleanSessions)
        return d

    def quit(self, args):
        client = args[0]
        print "quit " + str(client.getSerial())
        client.sendPacket(PacketQuit())
        if hasattr(client, "transport"):
            client.transport.loseConnection()
            return client.connection_lost_deferred
        else:
            raise UserWarning, "quit does not have transport %d" % client.getSerial()
        
    def ping(self, client):
        client.sendPacket(PacketPing())
        return (client,)

    def test01_ping(self):
        """ test01_ping """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.ping)
        d.addCallback(self.quit)
        return d

    def login(self, client, index):
        client.sendPacket(PacketPokerSetRole(roles = PacketPokerRoles.PLAY))
        client.sendPacket(PacketLogin(name = 'user%d' % index, password = 'password1'))
        return client.packetDeferred(True, PACKET_POKER_PLAYER_INFO)

    def test02_login(self):
        """ test02_login """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(self.quit)
        return d

    def cashIn(self, client, url, value):
        note = self.service.cashier.currency_client._buildNote(url, value)
        client.sendPacket(PacketPokerCashIn(serial = client.getSerial(), note = note))
        client._prefix = "[Client %d]" % client.getSerial()
        return client.packetDeferred(True, PACKET_ACK)

    def check_cashIn(self, (client, packet)):
        client.sendPacket(PacketPokerGetUserInfo(serial = client.getSerial()))
        d = client.packetDeferred(True, PACKET_POKER_USER_INFO)
        def validate((client, packet),):
            print "check_cashIn " + str(packet)
            self.assertEquals(PACKET_POKER_USER_INFO, packet.type)
            self.assertEquals(2, len(packet.money))
            self.assertEquals([1, 2], packet.money.keys())
            self.assertEquals(100, packet.money[1][0])
            self.assertEquals(200, packet.money[2][0])
            return (client, packet)
        d.addCallback(validate)
        return d
                                   
    def test03_cashIn(self):
        """ test03_cashIn """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(lambda (client, packet): self.cashIn(client, "ONE", 100))
        d.addCallback(lambda (client, packet): self.cashIn(client, "TWO", 200))
        d.addCallback(self.check_cashIn)
        d.addCallback(self.quit)
        return d

    def sit(self, (client, packet), game_id = TABLE1, seat = -1, auto_muck = pokergame.AUTO_MUCK_ALWAYS):
        client.sendPacket(PacketPokerTableJoin(serial = client.getSerial(),
                                               game_id = game_id))
        client.sendPacket(PacketPokerSeat(serial = client.getSerial(),
                                          game_id = game_id,
                                          seat = seat))
        client.sendPacket(PacketPokerAutoBlindAnte(serial = client.getSerial(),
                                                   game_id = game_id))
        client.sendPacket(PacketPokerBuyIn(serial = client.getSerial(),
                                           game_id = game_id,
                                           amount = 200000))
        if auto_muck != pokergame.AUTO_MUCK_ALWAYS:
            client.sendPacket(PacketPokerAutoMuck(serial = client.getSerial(),
                                                  game_id = game_id,
                                                  auto_muck = auto_muck))
        client.sendPacket(PacketPokerSit(serial = client.getSerial(),
                                         game_id = game_id))
        return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)
        
    def allIn(self, (client, packet), sit_out = True):
        self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
        self.assertEqual(client.getSerial(), packet.serial)
        if sit_out:
            client.sendPacket(PacketPokerSitOut(serial = packet.serial,
                                                game_id = packet.game_id))
        game = client.getGame(packet.game_id)
        player = game.getPlayer(packet.serial)
        if game.canRaise(player.serial):
            print "(A) ALLIN RAISE"
            client.sendPacket(PacketPokerRaise(serial = packet.serial,
                                               game_id = packet.game_id,
                                               amount = player.money))
        else:
            print "(A) ALLIN CALL"
            client.sendPacket(PacketPokerCall(serial = packet.serial,
                                              game_id = packet.game_id))

        return client.packetDeferred(True, PACKET_POKER_WIN)
        
    def check_or_call(self, (client, packet)):
        self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
        self.assertEqual(client.getSerial(), packet.serial)
        game = client.getGame(packet.game_id)
        player = game.getPlayer(packet.serial)
        if game.canCheck(player.serial):
            print "(A) CHECK"
            client.sendPacket(PacketPokerCheck(serial = packet.serial,
                                               game_id = packet.game_id))
        else:
            print "(A) CALL"
            client.sendPacket(PacketPokerCall(serial = packet.serial,
                                              game_id = packet.game_id))

        return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)
        
    def win(self, (client, packet), expect = None):
        print "(A) WIN " + str(packet)
        if expect:
            return client.packetDeferred(True, expect)
        else:
            return (client, packet)
        
    def test04_playHand(self):
        """ test04_playHand """
        d = [None, None]
        for index in (0,1):
            d[index] = self.client_factory[index].established_deferred
            d[index].addCallback(self.login, index)
            d[index].addCallback(lambda (client, packet): self.cashIn(client, "ONE", 200000))
            d[index].addCallback(self.sit)
            d[index].addCallback(self.allIn)
            d[index].addCallback(self.win)
            d[index].addCallback(self.quit)
        return defer.DeferredList(d)

    def getUserInfo(self, (client, packet)):
        print "getUserInfo " + str(packet)
        game = client.getGame(packet.game_id)
        self.assertEqual(False, game.isRunning())
        client.sendPacket(PacketPokerGetUserInfo(serial = client.getSerial()))
        return client.packetDeferred(True, PACKET_POKER_USER_INFO)

    def printUserInfo(self, (client, packet)):
        print "printUserInfo " + str(packet)
        self.assertEqual(PACKET_POKER_USER_INFO, packet.type)
        return (client, packet)
        
    def test05_userInfo(self):
        """ test05_userInfo """
        d = [None, None]
        for index in (0,1):
            d[index] = self.client_factory[index].established_deferred
            d[index].addCallback(self.login, index)
            d[index].addCallback(lambda (client, packet): self.cashIn(client, "ONE", 200000))
            d[index].addCallback(self.sit)
            d[index].addCallback(self.allIn)
            d[index].addCallback(self.getUserInfo)
            d[index].addCallback(self.printUserInfo)
            d[index].addCallback(self.quit)
        return defer.DeferredList(d)
    
    def test06_cannotGetSeat(self):
        """ test06_cannotGetSeat """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(lambda (client, packet): self.cashIn(client, "ONE", 200000))
        def wrongSeat((client, packet),):
            client.sendPacket(PacketPokerTableJoin(serial = client.getSerial(),
                                                   game_id = TABLE1))
            client.sendPacket(PacketPokerSeat(serial = client.getSerial(),
                                              game_id = TABLE1,
                                              seat = 42))
            return client.packetDeferred(True, PACKET_POKER_SEAT)
        d.addCallback(wrongSeat)
        def checkWrongSeat((client, packet),):
            self.assertEqual(PACKET_POKER_SEAT, packet.type)
            self.assertEqual(-1, packet.seat)
            return (client, packet)
        d.addCallback(checkWrongSeat)
        d.addCallback(self.quit)
        return d

    def test07_rebuy(self):
        """ test07_rebuy """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(lambda (client, packet): self.cashIn(client, "ONE", 400000))
        def rebuy((client, packet),):
            client.sendPacket(PacketPokerTableJoin(serial = client.getSerial(),
                                                   game_id = TABLE1))
            client.sendPacket(PacketPokerSeat(serial = client.getSerial(),
                                              game_id = TABLE1))
            client.sendPacket(PacketPokerBuyIn(serial = client.getSerial(),
                                               game_id = TABLE1,
                                               amount = 200000))
            client.sendPacket(PacketPokerRebuy(serial = client.getSerial(),
                                               game_id = TABLE1,
                                               amount = 200000))
            return client.packetDeferred(True, PACKET_POKER_PLAYER_CHIPS)
        d.addCallback(rebuy)
        def checkSit((client, packet),):
            self.assertEqual(PACKET_POKER_PLAYER_CHIPS, packet.type)
            self.assertEqual(0, packet.money)
            return client.packetDeferred(True, PACKET_POKER_PLAYER_CHIPS)
        d.addCallback(checkSit)
        def checkBuyIn((client, packet),):
            self.assertEqual(PACKET_POKER_PLAYER_CHIPS, packet.type)
            self.assertEqual(200000, packet.money)
            return client.packetDeferred(True, PACKET_POKER_PLAYER_CHIPS)
        d.addCallback(checkBuyIn)
        def checkRebuy((client, packet),):
            self.assertEqual(PACKET_POKER_PLAYER_CHIPS, packet.type)
            self.assertEqual(400000, packet.money)
            return (client, packet)
        d.addCallback(checkRebuy)
        d.addCallback(self.quit)
        return d

    def processingHand(self, (client, packet),):
        print "processingHand"
        self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
        client.sendPacket(PacketPokerProcessingHand(serial = client.getSerial(),
                                                    game_id = TABLE1))
        return (client, packet)

    def readyToPlay(self, (client, packet),):
        client.sendPacket(PacketPokerReadyToPlay(serial = client.getSerial(),
                                                 game_id = TABLE1))
        return (client, packet)

    def test08_processing_readytoplay(self):
        """ test08_processing_readytoplay """
        d = [None, None]
        for index in (0,1):
            d[index] = self.client_factory[index].established_deferred
            d[index].addCallback(self.login, index)
            d[index].addCallback(lambda (client, packet): self.cashIn(client, "ONE", 600000))
            d[index].addCallback(self.sit)
            d[index].addCallback(self.processingHand)
            d[index].addCallback(self.allIn)
            def atShowdown((client, packet),):
                print "atShowdown"
                client.sendPacket(PacketPokerRebuy(serial = client.getSerial(),
                                                   game_id = TABLE1,
                                                   amount = 200000))
                client.sendPacket(PacketPokerSit(serial = client.getSerial(),
                                                 game_id = TABLE1))
                return (client, packet)
            d[index].addCallback(atShowdown)
            if index == 1:
                d[index].addCallback(self.readyToPlay)
            def nextTurn((client, packet),):
                print "nextTurn"
                return client.packetDeferred(True, PACKET_POKER_START)
            d[index].addCallback(nextTurn)
            #
            # Game will start after the client index=0 times out 
            # and is marked as bugous because it failed to send
            # the READY_TO_PLAY packet
            #
            if index == 0:
                def checkBugousClient((client, packet),):
                    print "checkBugousClient for %d" % client.getSerial()
                    table = self.service.tables[0]
                    has_bugous = False
                    for (serial, server_client) in table.serial2client.iteritems():
                        if server_client.bugous_processing_hand == True:
                            has_bugous = True
                    self.assertEqual(True, has_bugous, "has bugous")
                    return (client, packet)
                d[index].addCallback(checkBugousClient)
            d[index].addCallback(self.quit)
        return defer.DeferredList(d)
    
    def test09_serverShutdown(self):
        """ test04_serverShutdown : the clients are still seated """
        d = [None, None]
        for index in (0,1):
            d[index] = self.client_factory[index].established_deferred
            d[index].addCallback(self.login, index)
            d[index].addCallback(lambda (client, packet): self.cashIn(client, "ONE", 200000))
            d[index].addCallback(self.sit)
            d[index].addCallback(self.allIn)
        return defer.DeferredList(d)
    
    def test10_playerImage(self):
        """ test10_login """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        def setPlayerImage((client, packet),):
            client.sendPacket(PacketPokerPlayerImage(serial = client.getSerial(),
                                                     image = "2345"))
            return client.packetDeferred(True, PACKET_ACK)
        d.addCallback(setPlayerImage)
        def getPlayerImage((client, packet),):
            self.assertEqual(PACKET_ACK, packet.type)
            client.sendPacket(PacketPokerGetPlayerImage(serial = client.getSerial()))
            return client.packetDeferred(True, PACKET_POKER_PLAYER_IMAGE)
        d.addCallback(getPlayerImage)
        def checkPlayerImage((client, packet),):
            self.assertEqual(PACKET_POKER_PLAYER_IMAGE, packet.type)
            self.assertEqual("2345", packet.image)
            return (client, packet)
        d.addCallback(checkPlayerImage)
        d.addCallback(self.quit)
        return d

    def cashOut(self, client, url, value):
        client.sendPacket(PacketPokerCashOut(serial = client.getSerial(), url = url, value = value))
        return client.packetDeferred(True, PACKET_POKER_CASH_OUT)

    def cashOutCommit(self, (client, packet)):
        self.assertEquals(PACKET_POKER_CASH_OUT, packet.type)
        client.sendPacket(PacketPokerCashOutCommit(serial = client.getSerial(), transaction_id = packet.name))
        return client.packetDeferred(True, PACKET_ACK)

    def test11_cashOut_zero(self):
        """ test11_cashOut_zero """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(lambda (client, packet): self.cashIn(client, "ONE", 100))
        d.addCallback(lambda (client, packet): self.cashIn(client, "TWO", 200))
        d.addCallback(self.check_cashIn)
        d.addCallback(lambda (client, packet): self.cashOut(client, "ONE", 100))
        d.addCallback(self.cashOutCommit)
        def check_cashOut((client, packet),):
            print "check_cashOut_zero"
            client.sendPacket(PacketPokerGetUserInfo(serial = client.getSerial()))
            d = client.packetDeferred(True, PACKET_POKER_USER_INFO)
            def validate((client, packet),):
                print "check_cashOut " + str(packet)
                self.assertEquals(PACKET_POKER_USER_INFO, packet.type)
                self.assertEquals(2, len(packet.money))
                self.assertEquals([1, 2], packet.money.keys())
                self.assertEquals(0, packet.money[1][0])
                self.assertEquals(200, packet.money[2][0])
                return (client, packet)
            d.addCallback(validate)
            return d
        d.addCallback(check_cashOut)
        d.addCallback(self.quit)
        return d

    def test12_cashOut(self):
        """ test12_cashOut """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(lambda (client, packet): self.cashIn(client, "ONE", 100))
        d.addCallback(lambda (client, packet): self.cashIn(client, "TWO", 200))
        d.addCallback(self.check_cashIn)
        d.addCallback(lambda (client, packet): self.cashOut(client, "ONE", 50))
        d.addCallback(self.cashOutCommit)
        def check_cashOut((client, packet),):
            print "check_cashOut"
            client.sendPacket(PacketPokerGetUserInfo(serial = client.getSerial()))
            d = client.packetDeferred(True, PACKET_POKER_USER_INFO)
            def validate((client, packet),):
                print "check_cashOut " + str(packet)
                self.assertEquals(PACKET_POKER_USER_INFO, packet.type)
                self.assertEquals(2, len(packet.money))
                self.assertEquals([1, 2], packet.money.keys())
                self.assertEquals(50, packet.money[1][0])
                self.assertEquals(200, packet.money[2][0])
                return (client, packet)
            d.addCallback(validate)
            return d
        d.addCallback(check_cashOut)
        d.addCallback(self.quit)
        return d

    def test13_cashOut_failure(self):
        """ test12_cashOut """
        currencyclient.Verbose = True
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(lambda (client, packet): self.cashIn(client, "ONE", 100))
        d.addCallback(lambda (client, packet): self.cashIn(client, "TWO", 200))
        d.addCallback(self.check_cashIn)
        def cashOutFail((client, packet),):
            currencyclient.FakeCurrencyFailure = True
            client.sendPacket(PacketPokerCashOut(serial = client.getSerial(), url = "ONE", value = 50))
            client.sendPacket(PacketPokerGetUserInfo(serial = client.getSerial()))
            return client.packetDeferred(True, PACKET_POKER_USER_INFO)

        d.addCallback(cashOutFail)
        def check_cashOutFail((client, packet),):
            print "check_cashOutFail " + str(packet)
            self.assertEquals(PACKET_POKER_USER_INFO, packet.type)
            self.assertEquals(2, len(packet.money))
            self.assertEquals([1, 2], packet.money.keys())
            self.assertEquals(100, packet.money[1][0])
            self.assertEquals(200, packet.money[2][0])
            return (client, packet)
        d.addCallback(check_cashOutFail)
        d.addCallback(self.quit)
        return d

    def test14_messages(self):
        d = self.client_factory[0].established_deferred
        def waitForMessage(client):
            db = self.service.db.db
            db.query("INSERT INTO messages (send_date, message) VALUES (" + str(_seconds_value + 2) + ", 'the message')")
            return client.packetDeferred(True, PACKET_MESSAGE)
        d.addCallback(waitForMessage)
        return d

    def sitngo(self, (client, packet)):
        client.sendPacket(PacketPokerTableJoin(serial = client.getSerial(),
                                               game_id = TABLE1))
        client.sendPacket(PacketPokerSeat(serial = client.getSerial(),
                                          game_id = TABLE1))
        client.sendPacket(PacketPokerAutoBlindAnte(serial = client.getSerial(),
                                                   game_id = TABLE1))
        client.sendPacket(PacketPokerBuyIn(serial = client.getSerial(),
                                           game_id = TABLE1,
                                           amount = 200000))
        client.sendPacket(PacketPokerSit(serial = client.getSerial(),
                                         game_id = TABLE1))
        return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)
        
    def search_sitngo2(self, (client, packet),):
        client.sendPacket(PacketPokerTourneySelect(string = "sitngo2"))
        return client.packetDeferred(True, PACKET_POKER_TOURNEY_LIST)

    def register_sitngo2(self, (client, packet),):
        self.assertEqual(PACKET_POKER_TOURNEY_LIST, packet.type)
        self.assertEqual(1, len(packet.packets))
        tourney = packet.packets[0]
        client.sendPacket(PacketPokerTourneyRegister(serial = client.getSerial(),
                                                     game_id = tourney.serial))
        return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)

    def tourneyRank(self, (client, packet), ):
        self.assertEqual(PACKET_POKER_WIN, packet.type)
        return client.packetDeferred(True, PACKET_POKER_TOURNEY_RANK)

    # -----------------------------------------------
    def test15_playTourney(self):
        """ Play regular tourney, all players go allin immediately. Simplest case, no tricks. """
        d = [None, None]
        for index in (0,1):
            d[index] = self.client_factory[index].established_deferred
            d[index].addCallback(self.login, index)
            d[index].addCallback(lambda (client, packet): self.cashIn(client, "ONE", 200000000))

            d[index].addCallback(self.search_sitngo2)
            d[index].addCallback(self.register_sitngo2)
            d[index].addCallback(lambda arg: self.allIn(arg, sit_out = False))
            d[index].addCallback(self.tourneyRank)
            d[index].addCallback(self.quit)

        return defer.DeferredList(d)

    # -----------------------------------------------
    def test16_playTourney_sitout_sit(self):
        """ Play regular tourney, one player sits out and sits back immediately afterwards. """
        d = [None, None]
        for index in (0,1):
            d[index] = self.client_factory[index].established_deferred
            d[index].addCallback(self.login, index)
            d[index].addCallback(lambda (client, packet): self.cashIn(client, "ONE", 200000000))

            d[index].addCallback(self.search_sitngo2)
            d[index].addCallback(self.register_sitngo2)
            if index == 0:
                def sitout((client, packet),):
                    print "(A) SITOUT"
                    self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
                    client.sendPacket(PacketPokerSitOut(serial = packet.serial,
                                                        game_id = packet.game_id))
                    client.sendPacket(PacketPokerSit(serial = packet.serial,
                                                     game_id = packet.game_id))
                    return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)
                d[index].addCallback(sitout)
            else:
                def callNraise((client, packet),):
                    print "(A) CALLNRAISE"
                    self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
                    game = client.getGame(packet.game_id)
                    player = game.getPlayer(packet.serial)
                    client.sendPacket(PacketPokerRaise(serial = packet.serial,
                                                       game_id = packet.game_id,
                                                       amount = player.money))
                    return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)
                d[index].addCallback(callNraise)
                    
            d[index].addCallback(self.check_or_call)
            d[index].addCallback(lambda arg: self.allIn(arg, sit_out = False))
            d[index].addCallback(self.tourneyRank)
            d[index].addCallback(self.quit)

        return defer.DeferredList(d)

    # -----------------------------------------------
    def test17_playTourney_timeout_sit(self):
        """ Play regular tourney, one player timeouts out and sits back immediately afterwards. """
        self.service.settings.headerSet("/server/delays/@showdown", '20')
        for tourney  in self.service.tourneys.values():
            tourney.player_timeout = 100
        d = [None, None]
        for index in (0,1):
            d[index] = self.client_factory[index].established_deferred
            d[index].addCallback(self.login, index)
            d[index].addCallback(lambda (client, packet): self.cashIn(client, "ONE", 200000000))

            d[index].addCallback(self.search_sitngo2)
            d[index].addCallback(self.register_sitngo2)
            if index == 0:
                def timeout((client, packet),):
                    print "(A) TIMEOUT"
                    self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
                    return client.packetDeferred(True, PACKET_POKER_TIMEOUT_NOTICE)
                d[index].addCallback(timeout)
                def sitback((client, packet),):
                    print "(A) SITBACK"
                    self.assertEqual(PACKET_POKER_TIMEOUT_NOTICE, packet.type)
                    client.sendPacket(PacketPokerSit(serial = packet.serial,
                                                     game_id = packet.game_id))
                    return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)
                d[index].addCallback(sitback)
            else:
                def callNraise((client, packet),):
                    print "(A) CALLNRAISE"
                    self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
                    game = client.getGame(packet.game_id)
                    player = game.getPlayer(packet.serial)
                    client.sendPacket(PacketPokerRaise(serial = packet.serial,
                                                       game_id = packet.game_id,
                                                       amount = player.money))
                    return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)
                d[index].addCallback(callNraise)
                    
            d[index].addCallback(self.check_or_call)
            d[index].addCallback(lambda arg: self.allIn(arg, sit_out = False))
            d[index].addCallback(self.tourneyRank)
            d[index].addCallback(self.quit)

        return defer.DeferredList(d)
    test17_playTourney_timeout_sit.timeout = 50000

    def test18_blindAllIn(self):
        """ test18_blindAllIn """
        def raiseAlmostAllIn((client, packet)):
            self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
            self.assertEqual(client.getSerial(), packet.serial)
            game = client.getGame(packet.game_id)
            player = game.getPlayer(packet.serial)
            print "(A) ALMOST ALLIN RAISE " + str(packet.serial)
            client.sendPacket(PacketPokerRaise(serial = packet.serial,
                                               game_id = packet.game_id,
                                               amount = player.money - 50))
            return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)

        def fold((client, packet), expect = PACKET_POKER_SELF_IN_POSITION):
            self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
            self.assertEqual(client.getSerial(), packet.serial)
            game = client.getGame(packet.game_id)
            player = game.getPlayer(packet.serial)
            print "(A) FOLD " + str(packet.serial)
            client.sendPacket(PacketPokerFold(serial = packet.serial,
                                              game_id = packet.game_id))
            return client.packetDeferred(True, expect)

        def muck((client, packet),):
            self.assertEqual(client.getSerial(), packet.muckable_serials[0])
            game = client.getGame(packet.game_id)
            player = game.getPlayer(packet.serial)
            print "(A) MUCK " + str(client.getSerial())
            client.sendPacket(PacketPokerMuckAccept(serial = client.getSerial(),
                                                    game_id = packet.game_id))
            return client.packetDeferred(True, PACKET_POKER_WIN)

        def call((client, packet), expect = PACKET_POKER_SELF_IN_POSITION):
            self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
            self.assertEqual(client.getSerial(), packet.serial)
            game = client.getGame(packet.game_id)
            player = game.getPlayer(packet.serial)
            print "(A) ALLIN CALL " + str(packet.serial)
            client.sendPacket(PacketPokerCall(serial = packet.serial,
                                              game_id = packet.game_id))
            return client.packetDeferred(True, expect)

        d = [None, None]
        for index in (0,1):
            d[index] = self.client_factory[index].established_deferred
            d[index].addCallback(self.login, index)
            d[index].addCallback(lambda (client, packet): self.cashIn(client, "ONE", 200000))
            d[index].addCallback(self.sit, TABLE3, index, pokergame.AUTO_MUCK_NEVER)
            if index == 0: # serial 4
                d[index].addCallback(call, PACKET_POKER_MUCK_REQUEST)
                d[index].addCallback(muck)
            else:
                d[index].addCallback(raiseAlmostAllIn)
                d[index].addCallback(fold, PACKET_POKER_WIN)
            if index == 1: # serial 5
                d[index].addCallback(self.win, PACKET_POKER_MUCK_REQUEST)
                d[index].addCallback(muck)
            else:
                def waitWin((client, packet)):
                    return client.packetDeferred(True, PACKET_POKER_WIN)
                d[index].addCallback(waitWin)
            d[index].addCallback(self.quit)
        return defer.DeferredList(d)

class PokerClientFactoryMockup(pokerclient.PokerClientFactory):
    def __init__(self, *args, **kwargs):
        pokerclient.PokerClientFactory.__init__(self, *args, **kwargs)
        self.call_networkNotAvailable = False
        self.call_networkAvailable = False
        self.rsync_host_no_network = False
        self.rsync_host_not_responding = False
        self.resolve_return_error = False

    def resolve(self, url):
        if self.resolve_return_error is True:
            return defer.fail(url)
        else:
            return defer.succeed(url)

    def networkNotAvailable(self):
        self.call_networkNotAvailable = True

    def networkAvailable(self):
        self.call_networkAvailable = True

    def failedUpgradeHostDoesNotRespond(self, logs, reason):
        self.rsync_host_not_responding = True

    def failedUpgradeNoNetwork(self, logs, reason):
        self.rsync_host_no_network = True

class PokerClientFactoryTestCase(unittest.TestCase):

    def setUp(self):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml_client, len(settings_xml_client))
        settings.header = settings.doc.xpathNewContext()
        self.client_factory = PokerClientFactoryMockup(settings = settings)

    def tearDown(self):
        pass

    def checkResultFalse(self, d):
        self.assertEqual(True, self.client_factory.call_networkNotAvailable)
        self.assertEqual(False, self.client_factory.call_networkAvailable)

    def checkResultTrue(self, d):
        self.assertEqual(False, self.client_factory.call_networkNotAvailable)
        self.assertEqual(True, self.client_factory.call_networkAvailable)

    def testCheckNetworkSucess(self):
        self.resolve_return_error = False
        return self.client_factory.checkNetwork("dummy").addCallback(self.checkResultTrue)

    def testCheckNetworkError(self):
        self.resolve_return_error = True
        return self.client_factory.checkNetwork("dummy").addErrback(self.checkResultFalse)


class InterfaceMockup(dispatch.EventDispatcher):
    def __init__(self):
        dispatch.EventDispatcher.__init__(self)
        self.msg = None
        
    def messageBox(self, msg):
        self.msg = msg

class SettingMockup:
    def __init__(self):
        self.return_batch = False
        self.return_upgrade = False
        
    def headerGet(self, path):
        if path == "/settings/@batch":
            return self.return_batch
        if path == "/settings/@upgrades":
            return self.return_upgrade
        return None

# class PokerClientFactoryMockup2(PokerClientFactory2D):
#     def __init__(self, *args, **kwargs):
#         self.interface = InterfaceMockup()
#         self.settings = SettingMockup()
#         self.call_quit = False
#         self.call_clientVersionOk = False
#         self.call_checkClientVersion = False

#     def quit(self):
#         self.call_quit = True

#     def clientVersionOk(self):
#         self.call_clientVersionOk = True

#     def checkClientVersion(self, arg):
#         self.call_checkClientVersion = True

# class PokerClientFactoryTestCase2(unittest.TestCase):

#     def setUp(self):
#         pass
    
#     def tearDown(self):
#         pass

#     def testNetworkNotAvailableNoBatch(self):
#         self.client_factory = PokerClientFactoryMockup2()
#         self.client_factory.networkNotAvailable()
#         self.client_factory.interface.publishEvent(pokerinterface.INTERFACE_MESSAGE_BOX)
#         self.assertEqual("No network available or maybe your firewall block your connexion\n", self.client_factory.interface.msg)
#         self.assertEqual(True, self.client_factory.call_quit)

#     def testNetworkNotAvailableBatch(self):
#         self.client_factory = PokerClientFactoryMockup2()
#         self.client_factory.settings.return_batch = "yes"
#         self.client_factory.networkNotAvailable()
#         self.client_factory.interface.publishEvent(pokerinterface.INTERFACE_MESSAGE_BOX)
#         self.assertEqual(False, self.client_factory.call_quit)

#     def testNetworkAvailableUpgradeNo(self):
#         self.client_factory = PokerClientFactoryMockup2()
#         self.client_factory.networkAvailable()
#         self.client_factory.interface.publishEvent(pokerinterface.INTERFACE_MESSAGE_BOX)
#         self.assertEqual(True, self.client_factory.call_clientVersionOk)

#     def testNetworkAvailableUpgradeYes(self):
#         self.client_factory = PokerClientFactoryMockup2()
#         self.client_factory.settings.return_upgrade = "yes"
#         self.client_factory.networkAvailable()
#         self.client_factory.interface.publishEvent(pokerinterface.INTERFACE_MESSAGE_BOX)
#         self.assertEqual(True, self.client_factory.call_checkClientVersion)

#     def testFailedUpgradeNoNetworkNoBatch(self):
#         self.client_factory = PokerClientFactoryMockup2()
#         self.client_factory.failedUpgradeNoNetwork("mockup", None)
#         self.client_factory.interface.publishEvent(pokerinterface.INTERFACE_MESSAGE_BOX)
#         self.assertEqual("No network available or maybe your firewall block your connexion\nmockup", self.client_factory.interface.msg)
#         self.assertEqual(True, self.client_factory.call_quit)

#     def testFailedUpgradeNoNetworkBatch(self):
#         self.client_factory = PokerClientFactoryMockup2()
#         self.client_factory.settings.return_batch = "yes"
#         self.client_factory.failedUpgradeNoNetwork("mockup", None)
#         self.client_factory.interface.publishEvent(pokerinterface.INTERFACE_MESSAGE_BOX)
#         self.assertEqual(False, self.client_factory.call_quit)

#     def testFailedHostNotFoundNoBatch(self):
#         self.client_factory = PokerClientFactoryMockup2()
#         self.client_factory.failedUpgradeHostNotFound("mockup", None)
#         self.client_factory.interface.publishEvent(pokerinterface.INTERFACE_MESSAGE_BOX)
#         self.assertEqual("Host not found\nmockup", self.client_factory.interface.msg)
#         self.assertEqual(True, self.client_factory.call_quit)

#     def testFailedHostNotFoundBatch(self):
#         self.client_factory = PokerClientFactoryMockup2()
#         self.client_factory.settings.return_batch = "yes"
#         self.client_factory.failedUpgradeHostNotFound("mockup", None)
#         self.client_factory.interface.publishEvent(pokerinterface.INTERFACE_MESSAGE_BOX)
#         self.assertEqual(False, self.client_factory.call_quit)

# ------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test14"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerClientTestCase))
#    suite.addTest(loader.loadClass(PokerClientFactoryTestCase))
#    suite.addTest(loader.loadClass(PokerClientFactoryTestCase2))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
#                              tracebackFormat='verbose',
                              tracebackFormat='default',
                              ).run(suite)

# ------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerclient.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokeravatar.py ../pokernetwork/pokertable.py ../pokernetwork/pokerservice.py ../pokernetwork/pokerclient.py  ../pokernetwork/pokerserver.py' TESTS='coverage-reset test-pokerclient.py coverage-report' check )"
# End:
