#!@PYTHON@
# -*- mode: python -*-
#
# Copyright (C) 2008 Loic Dachary <loic@dachary.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.
#

import sys, os
sys.path.insert(0, "@srcdir@/..")
sys.path.insert(0, "..")

import libxml2
import base64
import cgi

from twisted.trial import unittest, runner, reporter
from twisted.internet import defer
from twisted.python import failure
import twisted.internet.base
twisted.internet.base.DelayedCall.debug = True

from tests.testmessages import silence_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from tests import testclock

from pokernetwork import pokersite
from pokernetwork import pokernetworkconfig
from pokernetwork import pokeravatar
from pokernetwork.pokerpackets import *

class PokerServiceMockup:

      def __init__(self):
            self.verbose = 6
            self.serial2client = {}
            self.dirs = []

      def getPlayerInfo(self, serial):
            return PacketPokerPlayerInfo(serial = serial)

      def createAvatar(self):
            return pokeravatar.PokerAvatar(self)

      def destroyAvatar(self, avatar):
            pass

      player_image = None
      def setPlayerImage(self, player_image):
            self.player_image = player_image      
      player_serial = None
      def getPlayerImage(self, serial):
            self.player_serial = serial
            return self.player_image

class HelpersTestCase(unittest.TestCase):

      def test_fromutf8(self):
            self.assertEqual(['b', {'a': 'c'}, ('d',), 1], pokersite.fromutf8([u'b', {u'a': u'c'}, (u'd',), 1]))
            self.assertEqual([u'b', {u'a': u'c'}, (u'd',), 1], pokersite.toutf8(['b', {'a': 'c'}, ('d',), 1]))
                             
      def test_args2packets(self):
            self.assertEqual([PacketPing()], pokersite.args2packets([{'type':'PacketPing'}]))
            packets = pokersite.args2packets([{'type':'BadPacket'}])
            self.assertSubstring('Unable to instantiate', packets[0].message)
            packets = pokersite.args2packets([{'type':'0'}])
            self.assertSubstring('Invalid type', packets[0].message)

      def test_packets2maps(self):
            self.assertEqual([{'type': 'PacketPing'}], pokersite.packets2maps([PacketPing()]))
            self.assertEqual([{'packets': [{'type': 'PacketPing'}], 'type': 'PacketList'}], pokersite.packets2maps([PacketList(packets = [PacketPing()])]))
            packet = Packet()
            packet.message = "MESSAGE"
            packet.what = { 0: 1 }
            self.assertEqual([{'message': 'MESSAGE', 'type': 'Packet', 'what': {'X0': 1}}], pokersite.packets2maps([packet]))

class MemcacheTestCase(unittest.TestCase):

      def test01(self):
            memcache = pokersite.MemcacheMockup.Client([''])
            memcache.set('a', 'b')
            self.assertEqual(None, memcache.get('c'))
            self.assertEqual('b', memcache.get('a'))
            self.assertEqual(0, memcache.add('a', 'd'))
            self.assertEqual(1, memcache.add('f', 'g'))
            self.assertEqual(0, memcache.replace('z', 'k'))
            self.assertEqual(1, memcache.replace('f', 'l'))
            self.assertEqual(0, memcache.delete('r'))
            self.assertEqual(1, memcache.delete('f'))
            
class PokerSiteBase(unittest.TestCase):

      def setUp(self):
            testclock._seconds_reset()        
            settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" />
"""
            self.settings = pokernetworkconfig.Config([])
            self.settings.loadFromString(settings_xml)
            pokersite.memcache = pokersite.MemcacheMockup
            self.service = PokerServiceMockup()
            self.site = pokersite.PokerSite(self.settings, pokersite.PokerResource(self.service))
      
class PokerResourceTestCase(PokerSiteBase):

      class Transport:
            def getPeer(self):
                  return None
            def getHost(self):
                  return None

      class Channel:
            def __init__(self, site):
                  self.transport = PokerResourceTestCase.Transport()
                  self.site = site

      def test01_render(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            d = r.notifyFinish()
            def finish(result):
                  self.assertSubstring('\r\n\r\n[]', r.transport.getvalue())
                  self.failIfSubstring('Expire', r.transport.getvalue())
                  self.assertEqual(0, len(r.cookies))
            d.addCallback(finish)
            r.requestReceived('GET', '/', '')
            return d
      
      def test02_render_error(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            error_pattern = 'UNLIKELY'
            def handlePacketLogic(packet):
                  raise UserWarning, error_pattern
            r.args = { 'name': [ 'name' ] }
            r.getSession().avatar.handlePacketLogic = handlePacketLogic
            r.requestReceived('GET', '/', '')
            self.assertSubstring(error_pattern, r.transport.getvalue())

      def test03_render_chained(self):
            """
            requests that are received while another request is being handled (this
            may happen if the packet logic returned a deferred) are added to the
            callback chain
            """
            channel = self.Channel(self.site)
            r1 = pokersite.Request(channel, True)
            r1.site = r1.channel.site
            input = '{"type": "PacketPing"}'
            r1.gotLength(len(input))
            r1.handleContentChunk(input)
            d1 = defer.Deferred()
            r1.args = { 'name': [ 'name' ] }
            avatar1 = r1.getSession().avatar
            def handlePacketLogic1(packet):
                  avatar1.sendPacket(d1)
            avatar1.handlePacketLogic = handlePacketLogic1
            r1.requestReceived('GET', '/', '')

            r2 = pokersite.Request(channel, True)
            r2.site = r2.channel.site
            input = '{"type": "PacketPing"}'
            r2.gotLength(len(input))
            r2.handleContentChunk(input)
            r2.args = { 'name': [ 'name' ] }
            avatar2 = r2.getSession().avatar
            def handlePacketLogic2(packet):
                  avatar2.sendPacket(PacketPing())
            r2.getSession().avatar.handlePacketLogic = handlePacketLogic2
            r2.requestReceived('GET', '/', '')

            self.assertEqual('', r1.transport.getvalue())
            self.assertEqual('', r2.transport.getvalue())
            d1.callback(PacketAck())
            self.assertSubstring('PacketAck', r1.transport.getvalue())
            self.assertSubstring('PacketPing', r2.transport.getvalue())

      def test04_render_jsonp(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            r.gotLength(0)
            r.handleContentChunk('')
            r.requestReceived('GET', '/?jsonp=FUN&packet={"type":"PacketPing"}', '')

            self.assertSubstring('\r\n\r\nFUN([])', r.transport.getvalue())

      def test05_render_expire_cookie(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            r.received_cookies['TWISTED_SESSION'] = 'session'
            d = r.notifyFinish()
            def finish(result):
                  self.assertSubstring('\r\n\r\n[]', r.transport.getvalue())
                  self.assertSubstring('Expire', r.transport.getvalue())
            d.addCallback(finish)
            r.requestReceived('GET', '/', '')
            return d

      def test06_render_expire_logged(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            session = 'session'
            serial = '5'
            r.received_cookies['TWISTED_SESSION'] = session
            r.site.memcache.set(session, serial)
            r.site.memcache.set(serial, session)
            d = r.notifyFinish()
            def finish(result):
                  self.assertSubstring('\r\n\r\n[]', r.transport.getvalue())
                  self.failIfSubstring('Expire', r.transport.getvalue())
            d.addCallback(finish)
            r.requestReceived('GET', '/', '')
            return d

class PokerImageUploadTestCase(unittest.TestCase):

      class Transport:
            def getPeer(self):
                  return None
            def getHost(self):
                  return None

      class Channel:
            def __init__(self, site):
                  self.transport = PokerImageUploadTestCase.Transport()
                  self.site = site

      def setUp(self):
            testclock._seconds_reset()        
            settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" />
"""
            self.settings = pokernetworkconfig.Config([])
            self.settings.loadFromString(settings_xml)
            pokersite.memcache = pokersite.MemcacheMockup
            self.service = PokerServiceMockup()
            self.site = pokersite.PokerSite(self.settings, pokersite.PokerImageUpload(self.service))
            self.image_data = "image data"
            def parse_multipart_mockup(content, dict):
                  return {'filename':[self.image_data]}
            self.cgi_parse_multipart = cgi.parse_multipart
            cgi.parse_multipart = parse_multipart_mockup
            
      def tearDown(self):
            cgi.parse_multipart = self.cgi_parse_multipart

      def test01_render(self):            
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            
            r.args = {}
            session = self.site.makeSession()
            r.session = session
            self.assertNotEquals(None, r.getSession().avatar);
            user_serial = 111
            r.getSession().avatar.user.serial = user_serial
            self.assertEquals(True, r.getSession().avatar.isLogged());

            image_data = "image data"
            r.received_headers['content-type'] = 'multipart/form-data'
            input = ''
            r.gotLength(len(input))
            r.handleContentChunk(input)
            import cgi
            def parse_multipart_mockup(content, dict):
                  return {'filename':[image_data]}
            cgi.parse_multipart = parse_multipart_mockup
            r.requestReceived('POST', '/', '')
            self.assertSubstring('image uploaded', r.transport.getvalue())
            self.assertEquals(base64.b64encode(self.image_data),
                              self.service.player_image.image)
            session.expire()

      def test02_unauthorized(self):            
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            
            r.args = {}
            session = self.site.makeSession()
            r.session = session
            self.assertNotEquals(None, r.getSession().avatar);
            self.assertEquals(False, r.getSession().avatar.isLogged());

            r.received_headers['content-type'] = 'multipart/form-data'
            input = ''
            r.gotLength(len(input))
            r.handleContentChunk(input)
            r.requestReceived('POST', '/', '')
            self.assertSubstring('not logged', r.transport.getvalue())
            self.assertEquals(None, self.service.player_image)

class PokerAvatarResourceTestCase(unittest.TestCase):

      class Transport:
            def getPeer(self):
                  return None
            def getHost(self):
                  return None

      class Channel:
            def __init__(self, site):
                  self.transport = PokerImageUploadTestCase.Transport()
                  self.site = site

      def setUp(self):
            testclock._seconds_reset()        
            settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" />
"""
            self.settings = pokernetworkconfig.Config([])
            self.settings.loadFromString(settings_xml)
            pokersite.memcache = pokersite.MemcacheMockup
            self.service = PokerServiceMockup()
            self.site = pokersite.PokerSite(self.settings, pokersite.PokerAvatarResource(self.service))

      def test01_render(self):
            data = 'image data'
            serial = 64
            self.service.setPlayerImage(PacketPokerPlayerImage(image = base64.b64encode(data), serial = serial))
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            r.gotLength(0)
            r.handleContentChunk('')
            r.requestReceived('GET', '/%i' % serial, '')
            self.assertSubstring('\r\n\r\n%s' % data, r.transport.getvalue())
            self.assertEquals(serial, self.service.player_serial)

      def test02_render_error(self):
            serial = 100
            self.service.setPlayerImage(PacketPokerPlayerImage(image = '', serial = serial))
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            r.gotLength(0)
            r.handleContentChunk('')
            r.requestReceived('GET', '/%i' % serial, '')
            self.assertSubstring('not found', r.transport.getvalue())
            self.assertEquals(serial, self.service.player_serial)

class FilterTestCase(unittest.TestCase):

      def setUp(self):
            testclock._seconds_reset()        
            settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" >
<rest_filter>../@srcdir@/testfilter.py</rest_filter>
<rest_filter>../@srcdir@/../pokernetwork/nullfilter.py</rest_filter>
</server>
"""
            self.settings = pokernetworkconfig.Config([])
            self.settings.loadFromString(settings_xml)
            pokersite.memcache = pokersite.MemcacheMockup
            self.service = PokerServiceMockup()
            self.site = pokersite.PokerSite(self.settings, pokersite.PokerResource(self.service))

      class Transport:
            def getPeer(self):
                  return None
            def getHost(self):
                  return None

      class Channel:
            def __init__(self, site):
                  self.transport = PokerResourceTestCase.Transport()
                  self.site = site

      def test01_render(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            r.requestReceived('GET', '/', '')
            
            self.assertSubstring('\r\n\r\n[]', r.transport.getvalue())
            self.assertEqual(True, hasattr(r, "HERE"))

class FilterErrorTestCase(unittest.TestCase):

      def setUp(self):
            testclock._seconds_reset()        
            settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" >
<rest_filter>../@srcdir@/testerrorfilter.py</rest_filter>
</server>
"""
            self.settings = pokernetworkconfig.Config([])
            self.settings.loadFromString(settings_xml)
            pokersite.memcache = pokersite.MemcacheMockup
            self.service = PokerServiceMockup()
            self.site = pokersite.PokerSite(self.settings, pokersite.PokerResource(self.service))

      class Transport:
            def getPeer(self):
                  return None
            def getHost(self):
                  return None

      class Channel:
            def __init__(self, site):
                  self.transport = PokerResourceTestCase.Transport()
                  self.site = site

      def test01_render(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            
            d = r.notifyFinish()
            def finish(reason):
                  self.assertSubstring('UNLIKELY', r.transport.getvalue())
                  self.assertEqual(True, isinstance(reason, failure.Failure))
                  return True
            d.addBoth(finish)
            r.requestReceived('GET', '/', '')
            return d

class SessionTestCase(PokerSiteBase):

      def test01_checkExpired(self):
            serial = 111
            uid = 'uid'
            self.site.memcache.set(uid, serial)
            self.site.memcache.set(serial, uid)
            session = self.site.getSession(uid)
            self.assertEqual(True, session.checkExpired())
            self.site.memcache.delete(uid)
            self.site.memcache.delete(serial)
            self.assertEqual(False, session.checkExpired())

class RequestTestCase(PokerSiteBase):

      def test01_name(self):
            class Channel:
                  def __init__(self, site):
                        self.site = site
            
            r = pokersite.Request(Channel(self.site), True)
            r.site = r.channel.site
            r.args = { 'name': [ 'name' ] }
            session = r.getSession()
            self.assertSubstring('name=', r.cookies[0])
            session.expire()
            self.assertEqual(True, session.expired)

class PokerSiteTestCase(PokerSiteBase):

      def test01_init_full(self):
            settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" memcached="127.0.0.1:11211" session_timeout="60" session_check="10" />
"""
            settings = pokernetworkconfig.Config([])
            settings.loadFromString(settings_xml)
            site = pokersite.PokerSite(settings, pokersite.PokerResource)
            self.assertEqual([ '127.0.0.1:11211' ], site.memcache.addresses)
            self.assertEqual(60, site.sessionFactory.sessionTimeout)
            self.assertEqual(10, site.sessionCheckTime)

      def test02_init_default(self):
            sessionTimeout = pokersite.PokerSite.sessionFactory.sessionTimeout
            sessionCheckTime = pokersite.PokerSite.sessionCheckTime
            site = pokersite.PokerSite(self.settings, pokersite.PokerResource)
            self.assertEqual([ ], site.memcache.addresses)
            self.assertEqual(sessionTimeout, site.sessionFactory.sessionTimeout)
            self.assertEqual(sessionCheckTime, site.sessionCheckTime)

      def test03_01_getSession(self):
            """
            A session exists in core but not in memcache :
            the in core session expires
            """
            session = self.site.makeSession()
            self.site.memcache.delete(session.uid)
            exception = False
            try:
                  self.site.getSession(session.uid)
            except KeyError:
                  exception = True
            self.assertEqual(True, exception)
            self.assertEqual(True, session.expired)

      def test03_02_getSession(self):
            """
            A session exists in core and in memcache. The memcache serial
            is set from the outside.
            """
            session = self.site.makeSession()
            serial = 111
            self.site.memcache.set(session.uid, serial)
            self.site.memcache.set(serial, session.uid)
            self.site.getSession(session.uid)
            self.assertEquals(serial, session.avatar.getSerial())
            self.assertNotEquals(None, session.avatar.explain)
            self.assertEquals(serial, session.avatar.explain.serial)
            self.assertEquals(True, PacketPokerRoles.PLAY in session.avatar.roles)
            """
            Memcache serial changed and becomes inconsistent.
            """
            self.site.memcache.set(session.uid, serial + 1)
            self.site.memcache.set(serial + 1, session.uid)
            session = self.site.getSession(session.uid)
            self.assertEquals(serial + 1, session.avatar.getSerial())
            session.expire()

      def test03_03_getSession(self):
            """
            If the serial in memcache is associated to a session name
            that does not match the in core session name, abort.
            """
            session = self.site.makeSession()
            serial = 111
            self.site.memcache.set(session.uid, serial)
            self.site.memcache.set(serial, 'fakesession')
            exception = False
            try: 
                  self.site.getSession(session.uid)
            except AssertionError:
                  exception = True
            self.assertEquals(True, exception)
            session.expire()

      def test04_01_updateSession(self):
            """
            the session expires after upateSession, unless there are tables
            """
            session = self.site.makeSession()
            session.avatar.tables[1] = 'table'
            self.site.updateSession(session)
            self.assertEquals(False, session.expired)
            session.avatar.tables = []
            self.site.updateSession(session)
            self.assertEquals(True, session.expired)

      def test04_02_updateSession(self):
            """
            expire the session if the memcache serial changed since the request started
            """
            session = self.site.makeSession()
            self.site.memcache.set(session.uid, 100)
            self.assertEquals(False, self.site.updateSession(session))
            self.assertEquals(True, session.expired)

      def test04_03_updateSession(self):
            """
            expire the session if the memcache uid for the serial
            changed since the request started
            """
            session = self.site.makeSession()
            serial = 100
            self.site.memcache.set(session.uid, serial)
            session.avatar.user.serial = serial
            self.site.memcache.set(serial, 'other uid')
            self.assertEquals(False, self.site.updateSession(session))
            self.assertEquals(True, session.expired)

      def test04_04_updateSession(self):
            """
            memcache serial is 0 and serial is > 0, meaning the user logged in
            the memcache must be updated accordingly by adding an entry 
            with the serial as a key
            """
            session = self.site.makeSession()
            serial = 100
            session.avatar.user.serial = serial
            self.site.updateSession(session)
            self.assertEquals(serial, int(self.site.memcache.get(session.uid)))
            self.assertEquals(session.uid, self.site.memcache.get(str(serial)))

      def test04_05_updateSession(self):
            """
            memcache serial is > 0 and serial is == 0, meaning the user logged out
            the memcache must be updated by killing the entry that had the former
            serial as a key
            """
            session = self.site.makeSession()
            #
            # login
            #
            serial = 100
            session.avatar.user.serial = serial
            session.avatar.tables[1] = 'table'
            self.site.updateSession(session)
            self.assertEquals(serial, int(self.site.memcache.get(session.uid)))
            self.assertEquals(session.uid, self.site.memcache.get(str(serial)))
            #
            # logout
            #
            session.memcache_serial = serial # would be set by getSession()
            session.avatar.user.serial = 0
            self.site.updateSession(session)
            self.assertEquals(0, int(self.site.memcache.get(session.uid)))
            self.assertEquals(None, self.site.memcache.get(str(serial)))
            session.expire()

      def test04_06_updateSession(self):
            """
            memcache serial is > 0 and serial is == 0, meaning the user logged out
            the memcache must be updated by killing the entry that had the former
            serial as a key
            """
            session = self.site.makeSession()
            #
            # login
            #
            serial = 100
            session.avatar.user.serial = serial
            session.avatar.tables[1] = 'table'
            self.site.updateSession(session)
            self.assertEquals(serial, int(self.site.memcache.get(session.uid)))
            self.assertEquals(session.uid, self.site.memcache.get(str(serial)))
            #
            # inconsistency
            #
            new_serial = 200
            session.memcache_serial = serial # would be set by getSession()
            session.avatar.user.serial = new_serial
            self.site.updateSession(session)
            self.assertEquals(new_serial, int(self.site.memcache.get(session.uid)))
            self.assertEquals(session.uid, self.site.memcache.get(str(new_serial)))
            session.expire()

      def test05_startFactory(self):
            self.site.startFactory()
            self.assertEqual(False, hasattr(self.site, "logFile"))

      class Transport:
            def getPeer(self):
                  return None
            def getHost(self):
                  return None

      class Channel:
            def __init__(self, site):
                  self.transport = PokerResourceTestCase.Transport()
                  self.site = site

      def test06_getSession_assert(self):
            """
            An inconsistency in the memcache invalidates the session and an assert
            kills the request. When this happens, the assert must be caught and
            returned as a server error to the client.
            """
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            session = 'session'
            serial = '5'
            r.received_cookies['TWISTED_SESSION'] = session
            r.site.memcache.set(session, serial)
            r.site.memcache.set(serial, 'yerk')
            d = r.notifyFinish()
            def finish(result):
                  self.assertSubstring('AssertionError', str(result.getTraceback()))
                  return True
            d.addErrback(finish)
            r.requestReceived('GET', '/', '')
            return d

def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test17"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(FilterErrorTestCase))
    suite.addTest(loader.loadClass(FilterTestCase))
    suite.addTest(loader.loadClass(PokerResourceTestCase))
    suite.addTest(loader.loadClass(PokerImageUploadTestCase))
    suite.addTest(loader.loadClass(PokerAvatarResourceTestCase))
    suite.addTest(loader.loadClass(SessionTestCase))
    suite.addTest(loader.loadClass(RequestTestCase))
    suite.addTest(loader.loadClass(PokerSiteTestCase))
    suite.addTest(loader.loadClass(MemcacheTestCase))
    suite.addTest(loader.loadClass(HelpersTestCase))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
        tracebackFormat='default',
        ).run(suite)

if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokersite.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokersite.py' VERBOSE_T=-1 TESTS='coverage-reset test-pokersite.py coverage-report' check )"
# End:
