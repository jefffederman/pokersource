#!@PYTHON@
# -*- mode: python -*-
#
# Copyright (C) 2006, 2007 Loic Dachary <loic@dachary.org>
# Copyright (C) 2008       Bradley M. Kuhn <bkuhn@ebb.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.
#
import sys, os
sys.path.insert(0, "@srcdir@/../..")
sys.path.insert(0, "..")

import libxml2
from pprint import pprint
from string import split
import time

from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor, defer

twisted.internet.base.DelayedCall.debug = True

from tests.testmessages import silence_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from pokerengine import pokertournament
from pokernetwork import pokertable, pokernetworkconfig
from pokernetwork.pokerpackets import *
from pokernetwork.pokeravatar import DEFAULT_PLAYER_USER_DATA

settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="3" autodeal="yes" >
  <delays autodeal="2" autodeal_max="2" autodeal_check="0" round="0" position="0" showdown="0" finish="0" />

  <path>@POKER_ENGINE_PKGSYSCONFDIR@ @POKER_NETWORK_PKGSYSCONFDIR@</path>
  <users temporary="BOT"/>
</server>
"""

settings_stripped_deck_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="3" autodeal="yes" >
  <delays autodeal="2" autodeal_max="2" autodeal_check="0" round="0" position="0" showdown="0" finish="0" />

  <decks>
    <deck>9c 9d 9h Ts Tc Td Th Ts Jc Jd Jh Js Qc Qd Qh Qs Kc Kd Kh Ks Ac Ad Ah As</deck>
  </decks>

  <path>@POKER_ENGINE_PKGSYSCONFDIR@ @POKER_NETWORK_PKGSYSCONFDIR@</path>
  <users temporary="BOT"/>
</server>
"""

class MockService:

    def __init__(self, settings):
        self.settings = settings
        self.verbose = settings.headerGetInt("/server/@verbose")
        self.dirs = split(settings.headerGet("/server/path"))
        self.simultaneous = 4
        self.shutting_down = False
        self.hand_serial = 0
        self.chat = False
        self.players = {}

    def message(self, message):
        if self.verbose >= 0:
            print "MockService " + message
        
    def getName(self, serial):
        return "MockServiceName%d" % serial

    def error(self, message):
        self.message("error " + message)

    def seatPlayer(self, serial, table_id, amount):
        if self.players.has_key(serial):
            self.error("Player is already seated at table, ." % table_id)
            return False
        else:
            self.players[serial] = { 'table_id' : table_id, 'amount' : amount }
            return True

    def buyInPlayer(self, serial, game_id, currency_serial, amount):
        return amount

    def getHandSerial(self):
        self.hand_serial += 1
        return self.hand_serial

    def tableMoneyAndBet(self, table_id):
        return (0, 0)

    def leavePlayer(self, serial, table_id, currency_serial):
        if self.players.has_key(serial):
            del self.players[serial]
            return True
        else:
            self.error("Player is already seated at table, ." % table_id)
            return False
        

class MockClient:

    def __init__(self, serial):
        self.verbose = int(os.environ.get('VERBOSE_T', '-1'))
        self.serial = serial
        self.deferred = None
        self.raise_if_packet = None
        self.type = None
        self.tables = []
        self.packets = []

    def __str__(self):
        return "MockClient of Player%d" % self.serial

    def waitFor(self, type):
        self.deferred = defer.Deferred()
        self.type = type
        return self.deferred

    def raiseIfPacket(self, type):
        self.raise_if_packet = type

    def lookForPacket(self, type):
        for packet in self.packets:
            if packet.type == type:
                return True
        return False

    def message(self, message):
        if self.verbose >= 0:
            print "MockClient " + message
        
    def error(self, message):
        self.message("error " + message)

    def join(self, table):
        pass

    def removePlayer(self, table, serial):
        if self.tables.count(table) != 1:
            self.error(table + " does not occur exactly once for this player.")
        self.tables.remove(table)

        # Loic indicates that it's the job of the Client to pass along
        # player removes to the game class, so this is done here to be
        # consistent with what the pokertable API expects.

        return table.game.removePlayer(serial)

    def sitPlayer(self, table, serial):
        table.game.sit(serial)

    def addPlayer(self, table, seat):
        self.tables.append(table)
        if table.game.addPlayer(self.serial, seat):
            player = table.game.getPlayer(self.serial)
            player.setUserData(DEFAULT_PLAYER_USER_DATA.copy())
        return True
    def sendPacket(self, packet):
        self.message("sendPacket: " + str(packet))
        self.packets.append(packet)
        if self.deferred:
            if self.raise_if_packet and packet.type == self.raise_if_packet:
                reactor.callLater(0, lambda: self.deferred.errback(packet))
            elif self.type == packet.type:
                reactor.callLater(0, lambda: self.deferred.callback(packet))

    def getSerial(self):
        return self.serial

    def setMoney(self, table, amount):
        return table.game.payBuyIn(self.serial, amount)

    def getName(self):
        return "Player%d" % self.serial

class PokerTableTestCase(unittest.TestCase):

    # -------------------------------------------------------------------
    def setUp(self, settingsXmlStr=settings_xml):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settingsXmlStr, len(settingsXmlStr))
        settings.header = settings.doc.xpathNewContext()
        self.table = pokertable.PokerTable(MockService(settings), 100, 
                                           { 'name': "table1",
                                             'variant': "holdem",
                                             'betting_structure': "2-4-limit",
                                             'seats': 4,
                                             'currency_serial': 0
                                             })
        self.clients = {}

    # -------------------------------------------------------------------
    def tearDown(self):
        self.table.cancelDealTimeout()
        self.table.cancelPlayerTimers()
        del self.table

    def createPlayer(self, serial, buySit=True):
        client = MockClient(serial)
        self.clients[serial] = client
        self.table.joinPlayer(client, serial)
        if buySit:
            self.assertEqual(True, self.table.seatPlayer(client, serial, -1))
            self.assertEqual(True, self.table.buyInPlayer(client, self.table.game.maxBuyIn()))
            self.table.sitPlayer(client, serial)
        return client

    # -------------------------------------------------------------------
    def test01_autodeal(self):
        self.createPlayer(1)
        self.createPlayer(2)
        self.table.scheduleAutoDeal()
        return defer.DeferredList((self.clients[1].waitFor(PACKET_POKER_START),
                                   self.clients[2].waitFor(PACKET_POKER_START)))

    # -------------------------------------------------------------------
    def test02_autodeal_check(self):
        self.createPlayer(1)
        self.table.processingHand(1)
        self.table.game_delay["delay"] = 2
        self.table.game_delay["start"] = time.time()
        self.createPlayer(2)
        self.table.scheduleAutoDeal()
        return self.clients[2].waitFor(PACKET_POKER_MESSAGE)

    # -------------------------------------------------------------------
    def test03_autodeal_transient(self):
        """ Transient tables hand deal has a minimum duration if all players are in auto mode """
        self.createPlayer(1)
        self.table.game.autoPlayer(1)
        self.createPlayer(2)
        self.table.game.autoPlayer(2)
        self.table.transient = True
        self.table.game_delay["start"] = time.time()
        self.table.scheduleAutoDeal()
        return self.clients[2].waitFor(PACKET_POKER_MESSAGE)

    # -------------------------------------------------------------------
    def test04_autodeal_transient_now(self):
        """ Transient tables hand deal has no minium duration if all players are in auto mode but the hand lasted more than the required minium """
        self.createPlayer(1)
        self.table.game.autoPlayer(1)
        self.createPlayer(2)
        self.table.game.autoPlayer(2)
        self.table.game_delay["start"] = time.time() - 300
        self.table.transient = True
        self.table.scheduleAutoDeal()
        self.clients[2].raiseIfPacket(PACKET_POKER_MESSAGE)
        return self.clients[2].waitFor(PACKET_POKER_START)

    # -------------------------------------------------------------------
    def test05_autodeal_transient_normal(self):
        """ Transient tables hand deal normaly if at least one player is not in auto mode """
        self.createPlayer(1)
        self.createPlayer(2)
        self.table.transient = True
        self.table.scheduleAutoDeal()
        self.clients[2].raiseIfPacket(PACKET_POKER_MESSAGE)
        return self.clients[2].waitFor(PACKET_POKER_START)

    # -------------------------------------------------------------------
    def test06_duplicate_buyin(self):
        """ Buy in requested twice for a given player """
        self.createPlayer(1)
        client = self.clients[1]
        self.assertEqual(False, self.table.buyInPlayer(client, self.table.game.maxBuyIn()))

    # -------------------------------------------------------------------
    def test07_break_message(self):
        """ Tournament break issue a message to all players """
        class Tournament:
            def __init__(self):
                self.state = pokertournament.TOURNAMENT_STATE_BREAK_WAIT
                
        self.createPlayer(1)
        self.createPlayer(2)
        self.table.transient = True
        self.table.tourney = Tournament()
        self.table.game.isTournament = lambda: True
        self.table.scheduleAutoDeal()
        self.failUnless(self.clients[1].lookForPacket(PACKET_POKER_GAME_MESSAGE))
        self.failUnless(self.clients[2].lookForPacket(PACKET_POKER_GAME_MESSAGE))
    # -------------------------------------------------------------------
    def test08_player_has_trouble_joining(self):
        """Test for when the table is full and a player is trying hard to join"""
        # Do not use serials of 0's here -- pokerengine will hate that. :)
        for ii in [1, 2, 3, 4]:
            self.createPlayer(ii)
        self.createPlayer(5, False)
        player1 = self.clients[1]
        player5 = self.clients[5]

        # player5 can't sit because the table is full of 0-3
        self.assertEqual(False, self.table.seatPlayer(player5, 5, -1))

        # player1 leaves on his own...
        self.assertEqual(True, self.table.leavePlayer(player1, 1))
        self.assertEqual(True, self.table.seatPlayer(player5, 5, -1))
        self.assertEqual(True, self.table.buyInPlayer(player5, self.table.game.maxBuyIn()))
        # And we kick of player2; We hate that guy! 
        self.assertEqual(None, self.table.kickPlayer(2))

    # -------------------------------------------------------------------
    def test09_list_players(self):
        """Test to make sure the list of players given by pokertable is right"""
        d = {}
        for ii in [1, 2, 3, 4]:
            d['Player%d' % ii] = self.createPlayer(ii)
        for x in self.table.listPlayers():
            del d[x[0]]
        self.assertEqual({}, d)

# -------------------------------------------------------------------
class PokerTableTestCaseWithPredefinedDecks(PokerTableTestCase):
    def setUp(self, settingsXmlStr=settings_stripped_deck_xml):
        PokerTableTestCase.setUp(self, settingsXmlStr)

# -------------------------------------------------------------------

def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test07"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerTableTestCase))
    suite.addTest(loader.loadClass(PokerTableTestCaseWithPredefinedDecks))
    return runner.TrialRunner(reporter.VerboseTextReporter,
#                              tracebackFormat='verbose',
                              tracebackFormat='default',
                              ).run(suite)

# -----------------------------------------------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokertable.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokertable.py' TESTS='coverage-reset test-pokertable.py coverage-report' check )"
# End:
