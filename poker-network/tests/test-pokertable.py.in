#!@PYTHON@
# -*- mode: python -*-
#
# Copyright (C) 2006, 2007 Loic Dachary <loic@dachary.org>
# Copyright (C) 2008       Bradley M. Kuhn <bkuhn@ebb.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.
#
import sys, os
sys.path.insert(0, "@srcdir@/../..")
sys.path.insert(0, "..")

import libxml2
from pprint import pprint
from string import split
import time

from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor, defer

from random import seed, randint
import copy

twisted.internet.base.DelayedCall.debug = True

from tests.testmessages import silence_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from pokerengine import pokertournament
from pokernetwork import pokertable, pokernetworkconfig
from pokernetwork.pokerpackets import *
from pokernetwork.pokeravatar import DEFAULT_PLAYER_USER_DATA
from pokerengine.pokercards import PokerCards

global table1ID
global table2ID
table1ID = 100
table2ID = 200
settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="4" autodeal="yes" >
  <delays autodeal="2" autodeal_max="2" autodeal_check="0" round="0" position="0" showdown="0" finish="0" />

  <path>@POKER_ENGINE_PKGSYSCONFDIR@ @POKER_NETWORK_PKGSYSCONFDIR@</path>
  <users temporary="BOT"/>
</server>
"""
settings_stripped_deck_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="4" autodeal="yes" >
  <delays autodeal="2" autodeal_max="2" autodeal_check="0" round="0" position="0" showdown="0" finish="0" />

  <decks>
    <deck>9c 9d 9h Ts Tc Td Th Ts Jc Jd Jh Js Qc Qd Qh Qs Kc Kd Kh Ks Ac Ad Ah As</deck>
  </decks>

  <path>@POKER_ENGINE_PKGSYSCONFDIR@ @POKER_NETWORK_PKGSYSCONFDIR@</path>
  <users temporary="BOT"/>
</server>
"""

board = PokerCards() 
hand1 = PokerCards(['Qd', 'Ts'])
hand2 = PokerCards(['Kh', 'Kc'])
hand1_extra_river = PokerCards(['Qd', 'Ts', '9c'])
hand2_extra_river = PokerCards(['Qd', 'Ts', '9h'])
flop  = PokerCards(['Jd', 'Js', "Jc"])
turn  = PokerCards(['Tc', 'Js', 'Jc', 'Tc'])
river  = PokerCards(['Tc', 'Js', 'Jc', 'Tc', 'Ad'])
river_extra_river  = PokerCards(['Tc', 'Js', 'Jc', 'Tc', 'Ad', '9d'])

exampleHand =  [ \
        ('wait_for', 1, 'first_round'), \
        ('player_list', [1, 2]), \
        ('round', 'round1', board, { 1 : hand1, 2 : hand2}), \
        ('round', 'round2', flop, { 1 : hand1, 2 : hand2}), \
        ('round', 'round3', turn, { 1 : hand1, 2 : hand2}), \
        ('round', 'round4', river, { 1 : hand1, 2 : hand2}), \
# Round 5 doesn't changed the board to test certain code in
# compressedHistory: it expects that if you haven't changed the board in a
# new round, the history gives you "None"
        ('round', 'round5', river, { 1 : hand1, 2 : hand2}), \
        ('showdown', river, {1 : hand1, 2 : hand2}), \
        ('showdown', river_extra_river, {1 : hand1_extra_river, 2 : hand2_extra_river}), \
        ('position', 1), \
        ('blind_request', 1, 222, 735, 'big_and_dead'), \
        ('wait_blind', 1), \
        ('blind', 1, 222, 0), \
        ('ante_request', 1, 111), \
        ('ante', 1, 111), \
        ('ante', 5, 555), \
        ('all-in', 1), \
        ('call', 1, 411), \
        ('call', 6, 626), \
        ('check', 1), \
        ('fold', 1), \
        ('raise', 1, 888), \
# Note: 3 appears first here to test something appearing first as a raise.
        ('raise', 10, 976), \
        ('canceled', 4, 10), \
        ('rake', 7, { 1 : 7}), \
        ('end', [8, 1], [{ 'serial2share': { 8: 888, 1: 233 } }]), \
        ('sitOut', 1), \
        ('leave', [(1, 2), (2, 7)]), \
        ('finish', 1), \
        ('muck', (1,2)), \
        ('rebuy', 1, 9999), \
        ('unknown',) ]

def convertHandHistoryToDict (hist):
    dict = {}
    for entry in hist:
        key = entry[0]
        dict[key] = entry[1:-1]
    return dict

class MockService:

    def __init__(self, settings):
        self.settings = settings
        self.verbose = settings.headerGetInt("/server/@verbose")
        self.dirs = split(settings.headerGet("/server/path"))
        self.simultaneous = 4
        self.shutting_down = False
        self.hand_serial = 0
        self.hands = {}
        self.chat = False
        self.players = {}
        self.table1 = None
        self.table2 = None
        self.testObject = None

    def getTable(self, gameId):
        if gameId == self.table1.game.id:
            return self.table1
        elif gameId == self.table2.game.id:
            return self.table2
        else:
            self.error("Unknown game requested: " + gameId)
            return None

    def message(self, message):
        if self.verbose >= 0:
            print "MockService " + message
        
    def getName(self, serial):
        return "MockServiceName%d" % serial

    def getPlayerInfo(self, serial):
        class Dummy:
            def __init__(self):
                self.name = "MockServicePlayerInfo"
        return Dummy()

    def error(self, message):
        self.message("error " + message)

    def movePlayer(self, serial, fromGameId, toGameId):
        return 0

    def seatPlayer(self, serial, table_id, amount):
        if self.players.has_key(serial):
            self.error("Player is already seated at table, ." % table_id)
            return False
        else:
            self.players[serial] = { 'table_id' : table_id, 'amount' : amount }
            return True

    def buyInPlayer(self, serial, game_id, currency_serial, amount):
        return amount

    def getHandSerial(self):
        self.hand_serial += 1
        return self.hand_serial

    def tableMoneyAndBet(self, table_id):
        return (0, 0)

    def leavePlayer(self, serial, table_id, currency_serial):
        if self.players.has_key(serial):
            del self.players[serial]
            return True
        else:
            self.error("Player is already seated at table, ." % table_id)
            return False

    def deleteTable(self, x):
        pass

    def destroyTable(self, x):
        pass

    def loadHand(self, handId):
        # Only ever return the one hand; the only one this mock game ever had...
        #  ... but only if they give a positive integer as a handId.
        if handId <= 0:
            return None
        else:
            l = copy.deepcopy(exampleHand)
            l.insert(0, ('game', 1, handId, 3, time.time(), 'variant','betting_structure', [1, 2], 7, { 1 : 7890, 2 : 1234, 'values' : ''}))
            self.hands[handId] = convertHandHistoryToDict(l)
            return l

    def saveHand(self, history, serial):
        if self.testObject:
            historyDict = convertHandHistoryToDict(history)
            handId = historyDict['game'][1]
            origDict = self.hands[handId]
            for (action, fields) in historyDict.iteritems():
                if action == "showdown":
                    self.testObject.failUnless(fields == (None,) or fields == (PokerCards([34, 48, 35, 34, 25, 20]),))
                elif action == "round" and fields[0] == "round5":
                    self.testObject.assertEqual(fields, ('round5', None,))
                else:
                    self.testObject.assertEqual(origDict[action], fields)

    def updatePlayerMoney(self, serial, gameId, amount):
        # Most of this function matches up with the false hand history above
        #  Compare it to that when figuring out where these numbers come from,
        #  except for serial 3, which is based on the ante he makes in test21
        if self.testObject:
            self.testObject.assertEqual(gameId,  self.testObject.table1_value)
            if serial == 1:
                self.testObject.assertEqual(amount,  -1399)
            elif serial == 3:
                self.testObject.assertEqual(amount,  -100)
            elif serial == 10:
                self.testObject.assertEqual(amount,  -976)
            elif serial == 4:
                self.testObject.assertEqual(amount,  10)
            elif serial == 5:
                self.testObject.assertEqual(amount,  -555)
            elif serial == 6:
                self.testObject.assertEqual(amount,  -626)
            elif serial == 8:
                self.testObject.assertEqual(amount,  888)
            else:
                self.testObject.fail("Unkown serial in hand history: %d" % serial)
                

    def updatePlayerRake(self, currencySerial, serial, rakeAmount):
        if self.testObject:
            self.testObject.assertEqual(rakeAmount,  7)
            self.testObject.assertEqual(serial,  1)

    def tourneyEndTurn(self, tourney, game_id):
        if self.testObject:
            self.testObject.assertEqual(game_id,  self.testObject.table1_value)
            self.testObject.assertEqual(tourney,  'My Old Sit and Go')

    def resetBet(self, gameId):
        if self.testObject:
            self.testObject.assertEqual(gameId,  self.testObject.table1_value)

class MockClient:
    def __init__(self, serial):
        self.verbose = int(os.environ.get('VERBOSE_T', '-1'))
        self.serial = serial
        self.deferred = None
        self.raise_if_packet = None
        self.type = None
        self.tables = {}
        self.packets = []

    def __str__(self):
        return "MockClient of Player%d" % self.serial

    def waitFor(self, type):
        self.deferred = defer.Deferred()
        self.type = type
        return self.deferred

    def raiseIfPacket(self, type):
        self.raise_if_packet = type

    def lookForPacket(self, type):
        for packet in self.packets:
            if packet.type == type:
                return packet
        return False

    def message(self, message):
        if self.verbose >= 0:
            print "MockClient " + message
        
    def error(self, message):
        self.message("error " + message)

    def join(self, table):
        pass

    # Loic indicates that it's the job of the Client to pass along a few
    # things, including "player removes", and various clients settings, to
    # the game class.  These next few functions do that to be consistent
    # with what the pokertable API expects.

    def removePlayer(self, table, serial):
        if not self.tables.has_key(table.game.id):
            self.error("Table with game number %d does not occur exactly once for this player." % table.game.id)
        if serial == 9:
            table.game.removePlayer(serial)
            return False
        return table.game.removePlayer(serial)

    def autoBlindAnte(self, table, serial, auto):
        table.game.getPlayer(serial).auto_blind_ante = auto

    def sitPlayer(self, table, serial):
        table.game.sit(serial)

    def addPlayer(self, table, seat):
        self.tables[table.game.id] = table
        if table.game.addPlayer(self.serial, seat):
            player = table.game.getPlayer(self.serial)
            player.setUserData(DEFAULT_PLAYER_USER_DATA.copy())
        return True

    def sitOutPlayer(self, table, serial):
        table.game.sitOutNextTurn(serial)

    def sendPacket(self, packet):
        self.message("sendPacket: " + str(packet))
        self.packets.append(packet)
        if self.deferred:
            if self.raise_if_packet and packet.type == self.raise_if_packet:
                reactor.callLater(0, lambda: self.deferred.errback(packet))
            elif self.type == packet.type:
                reactor.callLater(0, lambda: self.deferred.callback(packet))

    def sendPacketVerbose(self, packet):
        self.sendPacket(packet)

    def getSerial(self):
        return self.serial

    def setMoney(self, table, amount):
        return table.game.payBuyIn(self.serial, amount)

    def getName(self):
        return "Player%d" % self.serial

    def getPlayerInfo(self):
        class MockPlayerInfo:
            def __init__(self, player):
                self.player = player
                self.name = self.player.getName()
                self.url = "http://fake"
                self.outfit = None
        return MockPlayerInfo(self)
# --------------------------------------------------------------------------------
class MockClientWithTableDict(MockClient):
    def __init__(self, serial):
        self.tables = {}
        MockClient.__init__(self, serial)

    def addPlayer(self, table, seat):
        MockClient.addPlayer(self, table, seat)
        self.tables[table.game.id] = seat

# --------------------------------------------------------------------------------
class MockClientWithRemoveTable(MockClient):
    def removeTable(self, gameId):
        return True
# --------------------------------------------------------------------------------
class PokerTableTestCase(unittest.TestCase):
    # -------------------------------------------------------------------
    def setUp(self, settingsXmlStr=settings_xml):
        global table1ID
        global table2ID
        table1ID = table1ID + 1
        table2ID += 1
        self.table1_value = table1ID
        self.table2_value = table2ID

        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settingsXmlStr, len(settingsXmlStr))
        settings.header = settings.doc.xpathNewContext()
        self.service = MockService(settings)
        self.table = pokertable.PokerTable(self.service, table1ID, 
                                           { 'name': "table1",
                                             'variant': "holdem",
                                             'betting_structure': "2-4-limit",
                                             'seats': 4,
                                             'player_timeout' : 6, 
                                             'muck_timeout' : 1,
                                             'currency_serial': 0
                                             })
        self.table2 = pokertable.PokerTable(self.service, table2ID, 
                                           { 'name': "table2",
                                             'variant': "holdem",
                                             'betting_structure': "2-4-limit",
                                             'seats': 4,
                                             'player_timeout' : 6, 
                                             'muck_timeout' : 1,
                                             'currency_serial': 0
                                             })
        self.service.table1 = self.table
        self.service.table2 = self.table2
        self.clients = {}
    # -------------------------------------------------------------------
    def tearDown(self):
        self.table.cancelDealTimeout()
        self.table.cancelPlayerTimers()
        del self.table
        del self.service

    def createPlayer(self, serial, getReadyToPlay=True, clientClass=MockClient, table=None):
        if table == None:
            table = self.table
        client = clientClass(serial)
        self.clients[serial] = client
        if getReadyToPlay:
            self.assertEqual(True, table.joinPlayer(client, serial))
            self.assertEqual(True, table.seatPlayer(client, serial, -1))
            self.assertEqual(True, table.buyInPlayer(client, self.table.game.maxBuyIn()))
            self.table.sitPlayer(client, serial)
        return client

    # -------------------------------------------------------------------
    def test01_autodeal(self):
        self.createPlayer(1)
        self.createPlayer(2)
        self.table.scheduleAutoDeal()
        return defer.DeferredList((self.clients[1].waitFor(PACKET_POKER_START),
                                   self.clients[2].waitFor(PACKET_POKER_START)))
    # -------------------------------------------------------------------
    def test02_autodeal_check(self):
        self.createPlayer(1)
        self.table.processingHand(1)
        self.table.game_delay["delay"] = 2
        self.table.game_delay["start"] = time.time()
        self.createPlayer(2)
        self.table.scheduleAutoDeal()
        return self.clients[2].waitFor(PACKET_POKER_MESSAGE)
    # -------------------------------------------------------------------
    def test06_duplicate_buyin(self):
        """ Buy in requested twice for a given player """
        self.createPlayer(1)
        client = self.clients[1]
        self.assertEqual(False, self.table.buyInPlayer(client, self.table.game.maxBuyIn()))
    # -------------------------------------------------------------------
    def test07_break_message(self):
        """ Tournament break issue a message to all players """
        class Tournament:
            def __init__(self):
                self.state = pokertournament.TOURNAMENT_STATE_BREAK_WAIT
                
        self.createPlayer(1)
        self.createPlayer(2)
        self.table.transient = True
        self.table.tourney = Tournament()
        self.table.game.isTournament = lambda: True
        self.table.scheduleAutoDeal()
        self.failUnless(self.clients[1].lookForPacket(PACKET_POKER_GAME_MESSAGE))
        self.failUnless(self.clients[2].lookForPacket(PACKET_POKER_GAME_MESSAGE))
    # -------------------------------------------------------------------
    def test08_player_has_trouble_joining(self):
        """Test for when the table is full and a player is trying hard to join"""
        # Do not use serials of 0's here -- pokerengine will hate that. :)
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
        player[5] = self.createPlayer(5, False)

        # people at table aren't obsrevers
        self.assertEqual(False, self.table.isSerialObserver(1))

        # player5 can't sit because the table is full of 1-4...
        self.assertEqual(False, self.table.seatPlayer(player[5], 5, -1))
        # player5 still not an observer
        self.assertEqual(False, self.table.isSerialObserver(5))

        self.assertEqual(True, self.table.joinPlayer(player[5], 5))
        # player5 now an observer
        self.assertEqual(True, self.table.isSerialObserver(5))
        #  ... but player5 decides to set all sorts of things that she can't
        #      because she's still just an observer.
        self.assertEqual(False, self.table.muckAccept(player[5], 5))
        self.assertEqual(False, self.table.muckDeny(player[5], 5))
        self.assertEqual(False, self.table.autoBlindAnte(player[5], 5, True))
        self.assertEqual(False, self.table.buyInPlayer(player[5], 0))
        self.assertEqual(False, self.table.rebuyPlayerRequest(player[5], 30))

        # player5 cannot sit out either because she isn't joined yet.
        self.assertEqual(False, self.table.sitOutPlayer(player[5], 5))

        # player1 leaves on his own...
        self.assertEqual(True, self.table.leavePlayer(player[1], 1))

        # ... which allows player5 to finally join legitimately and change
        # her settings.  However, she tries to sit in everyone else's
        # seat, she tries to sit out before getting the seat, rebuy before
        # even buying, and then buys in for nothing, and thus must rebuy

        for p in self.table.game.playersAll():
            self.assertEqual(False, self.table.seatPlayer(player[5], 5, p.seat))

        self.assertEqual(False, self.table.sitPlayer(player[5], 5))

        self.assertEqual(True, self.table.seatPlayer(player[5], 5, -1))
        self.assertEqual(False, self.table.rebuyPlayerRequest(player[5], 2))

        self.assertEqual(True, self.table.buyInPlayer(player[5], 0))

        # ... but cannot sit down again
        self.assertEqual(False, self.table.seatPlayer(player[5], 5, -1))

        # I wonder if these should really return True rather than None?  -- bkuhn
        self.assertEqual(None, self.table.muckAccept(player[5], 5))
        self.assertEqual(None, self.table.muckDeny(player[5], 5))
        self.assertEqual(None, self.table.autoBlindAnte(player[5], 5, True))

        self.assertEqual(True, self.table.rebuyPlayerRequest(player[5], \
                                              self.table.game.maxBuyIn()))
    # -------------------------------------------------------------------
    def test08_2_brokenSeatFactory(self):
        player = self.createPlayer(1)
        self.table.factory.seatPlayer = lambda (a, b, c): False
        self.assertEqual(False, self.table.seatPlayer(player, 1, -1))

    # -------------------------------------------------------------------
    def test08_5_kick(self):
        """Test that kick works correctly"""
        player = self.createPlayer(2)

        self.assertEqual(None, self.table.kickPlayer(2))
        # Test to make sure it's ok if we kick him twice.
        try:
            self.assertEqual(None, self.table.kickPlayer(2))
        except KeyError, ke:
            self.assertEqual(2, ke[0])
        # Special test: player 9's removePlayer always fails, so it covers error
#         def fakeGameRemovePlayer(serial):
#             ret = PokerGame.removePlayer(serial)
#             if x == 9:
#                 return False
#             else:
#                 return ret

#         self.table.game.removePlayer = fakeGameRemovePlayer
#         p = self.createPlayer(9)
#         self.assertEquals(None, self.table.kickPlayer(9))

    # -------------------------------------------------------------------
    def test08_7_sitout(self):
        """Test that sitOut works correctly"""
        player = self.createPlayer(4)

        # player4 sits out but tries it twice.  (Guess he clicked too much
        # on the button)
        self.assertEqual(True, self.table.sitOutPlayer(player, 4))
        self.assertEqual(True, self.table.sitOutPlayer(player, 4))
    # -------------------------------------------------------------------
    def test08_8_buyinOverMax(self):
        """Test that buyins over the maximum are refused"""
        player = self.createPlayer(1)

        self.assertEqual(False, self.table.rebuyPlayerRequest(player, 1))
        self.assertEqual(False, self.table.rebuyPlayerRequest(player, 2))
    # -------------------------------------------------------------------
    def test09_list_players(self):
        """Test to make sure the list of players given by pokertable is right"""
        d = {}
        for ii in [1, 2, 3, 4]:
            d['Player%d' % ii] = self.createPlayer(ii)
        for x in self.table.listPlayers():
            del d[x[0]]
        self.assertEqual({}, d)
    # -------------------------------------------------------------------
    def test10_info_and_chat(self):
        """Test player discussions and info"""
        p = {}
        for ii in [1, 2, 3, 4]:
            p[ii] = self.createPlayer(ii)
        d = self.table.getPlayerInfo(2)
        self.failUnlessSubstring("Player2", d.name)
        self.table.chatPlayer(self.clients[1], 1, "Hi, I am the One.")
        x = p[ii].waitFor(PACKET_POKER_CHAT)
        def chatCatch(packet):
            self.assertEqual(serial, 1)
            self.assertEqual(serial, "Hi, I am the One.")
        x.callback(chatCatch)
        return x
    # -------------------------------------------------------------------
    def test11_packet(self):
        """Test toPacket"""
        packetStr = "%s" % self.table.toPacket()
        idstr = 'id = %d' % self.table.game.id
        for str in [ idstr, 'name = table1', 'variant = holdem', \
                     'betting_structure = 2-4-limit', 'seats = 4', \
                     'average_pot = 0', 'hands_per_hour = 0', \
                     'percent_flop = 0', 'players = 0', 'observers = 0', \
                     'waiting = 0', 'player_timeout = 6', 'muck_timeout = 1', \
                     'currency_serial = 0', 'skin = default' ]:
            self.failUnlessSubstring(str, packetStr)
    # -------------------------------------------------------------------
    def test12_everyone_timeout(self):
        """Test if all players fall through timeout"""
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
        self.table.update()

        return defer.DeferredList((player[1].waitFor(PACKET_POKER_TIMEOUT_NOTICE),
                                   player[2].waitFor(PACKET_POKER_TIMEOUT_NOTICE),
                                   player[3].waitFor(PACKET_POKER_TIMEOUT_NOTICE),
                                   player[4].waitFor(PACKET_POKER_TIMEOUT_NOTICE)))
    # -------------------------------------------------------------------
    def test13_disconnect(self):
        """Test a disconnected player"""
        p1 = self.createPlayer(1, clientClass=MockClientWithTableDict)
        self.table.disconnectPlayer(p1, 1)
    # -------------------------------------------------------------------
    def test13altForNewClientAPI_disconnect(self):
        """Test player disconnection once the client API has a removeTable method
           This is currently turned off because the change has not been
           made.  See the FIXME around line 1218 of pokertable.py in
           pokertable.destroyPlayer
        """
        # This is disabled until the API changes
        return True
        p1 = self.createPlayer(1, clientClass=MockClientWithRemoveTable)
        self.table.disconnectPlayer(p1, 1)
    # -------------------------------------------------------------------
    def test14_closed_games(self):
        """Do typical operations act as expected when the game is closed?"""
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
        self.table.game.close()
        self.table.quitPlayer(player[1], 1)

        # Leaving a closed table generates an error.  player[2] is going
        # to leave, we wait for the error packet to come back, and make
        # sure that they other_type indicates it's a response to our leave
        # request.
        deferredLeaveErrorWait = player[2].waitFor(PACKET_POKER_ERROR)
        def checkReturnPacket(packet):
            self.assertEqual(PACKET_POKER_PLAYER_LEAVE, packet.other_type)
            self.failUnlessSubstring("annot leave", packet.message)
        deferredLeaveErrorWait.addCallback(checkReturnPacket)

        self.table.leavePlayer(player[2], 2)
        return deferredLeaveErrorWait
    # -------------------------------------------------------------------
    def test15_moveTo(self):
        """Make sure a player can move from one place to another"""
        player = self.createPlayer(1)
        otherTablePlayer = self.createPlayer(2, table=self.table2)

        expectPlayerDeferred = otherTablePlayer.waitFor(PACKET_POKER_PLAYER_ARRIVE)
        def checkReturnPacket(packet):
            self.assertEqual(packet.name, "Player1")
            self.assertEqual(packet.game_id, self.table2_value)
        expectPlayerDeferred.addCallback(checkReturnPacket)

        self.table.movePlayer(player, 1, self.table2.game.id)

        return expectPlayerDeferred
    # -------------------------------------------------------------------
    def test16_autoMuckTimeoutPolicy(self):
        """Make sure other timeout policies function properly"""
        player = self.createPlayer(1)
        player2 = self.createPlayer(2)
        # Sit out policy is the default
        self.assertEqual(self.table.timeout_policy,  "sitOut")
        self.table.timeout_policy =  "fold"

        expectPlayerAutoFold = player2.waitFor(PACKET_POKER_AUTO_FOLD)
        def checkReturnPacket(packet):
            # Don't assert which serial we get here, as it could be from
            # either player
            self.assertEqual(packet.game_id, self.table1_value)
        expectPlayerAutoFold.addCallback(checkReturnPacket)

        self.table.update()

        return expectPlayerAutoFold
    # -------------------------------------------------------------------
    def test17_bogusTimeoutPolicy(self):
        self.table.timeout_policy =  "muck"
        player = self.createPlayer(1)
        player2 = self.createPlayer(2)
        self.table.update()
        return player.waitFor(PACKET_POKER_TIMEOUT_NOTICE)
    # -------------------------------------------------------------------
    def test17a_resetTimeoutPolicy(self):
        """Set timeout policy back to the default"""
        self.table.timeout_policy = "sitOut"
    # -------------------------------------------------------------------
    def test18_handReplay(self):
        """Test replay of hand from pokertable"""
        player1 = self.createPlayer(1)

        # First try a hand that doesn't exist
        self.assertEqual(None, self.table.handReplay(player1, 0))

        myHandId = randint(777, 79825)
        def checkHandSerial(packet):
            self.assertEqual(packet.hand_serial, myHandId)
        def checkAmount(amount, value):
            self.assertEqual(amount, value)
        def checkAnteAmount(packet):
            checkAmount(packet.amount, 111)
        def checkBlindAmount(packet):
            checkAmount(packet.amount, 222)
        def checkCallAmount(packet):
            checkAmount(packet.amount, 411)
        def checkRaiseAmount(packet):
            checkAmount(packet.amount, 888)
        def checkRebuyAmount(packet):
            checkAmount(packet.amount, 9999)
        def checkCanceledAmount(packet):
            checkAmount(packet.amount, 10)
        def checkRakeAmount(packet):
            self.assertEqual(packet.value, 7)
        def checkPosition(packet):
            self.assertEqual(packet.position, 1)
        def checkBlindRequest(packet):
            self.assertEqual(packet.state, "big_and_dead")
            checkBlindAmount(packet)
        def checkPlayerMoney(packet):
            self.assertEqual(True, packet.serial == 1 or packet.serial == 2)
            if packet.serial == 1:
                self.assertEqual(packet.amount, 7890)
            else:
                self.assertEqual(packet.amount, 1234)
        def checkPlayerCards(packet):
            self.assertEqual(True, packet.serial == 1 or packet.serial == 2)
            if packet.serial == 1:
                self.assertEqual(packet.cards, [23, 47])
            else:
                self.assertEqual(packet.cards, [11, 37])
        def checkMuckSerials(packet):
            self.assertEqual(packet.muckable_serials, (1, 2))

        # To get coverage of a player who isn't joined to the table requesting.
        player2 = self.createPlayer(2, False)

        for player in (player1, player2):
            self.table.handReplay(player, myHandId)
            checkHandSerial(player.lookForPacket(PACKET_POKER_START))
            checkPlayerCards(player.lookForPacket(PACKET_POKER_PLAYER_CARDS))
            checkPlayerCards(player.lookForPacket(PACKET_POKER_PLAYER_CARDS))
            checkPosition(player.lookForPacket(PACKET_POKER_POSITION))
            checkBlindRequest(player.lookForPacket(PACKET_POKER_BLIND_REQUEST))
            checkBlindAmount(player.lookForPacket(PACKET_POKER_BLIND))
            checkAnteAmount(player.lookForPacket(PACKET_POKER_ANTE_REQUEST))
            checkAnteAmount(player.lookForPacket(PACKET_POKER_ANTE))
            checkRebuyAmount(player.lookForPacket(PACKET_POKER_REBUY))
            player.lookForPacket(PACKET_POKER_CALL)
            player.lookForPacket(PACKET_POKER_CHECK)
            player.lookForPacket(PACKET_POKER_FOLD)
            checkRaiseAmount(player.lookForPacket(PACKET_POKER_RAISE))
            checkCanceledAmount(player.lookForPacket(PACKET_POKER_CANCELED))
            checkRakeAmount(player.lookForPacket(PACKET_POKER_RAKE))
            player.lookForPacket(PACKET_POKER_SIT_OUT)
            checkMuckSerials(player.lookForPacket(PACKET_POKER_MUCK_REQUEST))
            checkRebuyAmount(player.lookForPacket(PACKET_POKER_REBUY))
    # -------------------------------------------------------------------
    def test19_serial2clientEmpty(self):
        """Test replay of hand from pokertable"""
        self.assertEqual("MockServiceName1", self.table.getName(1))
        d = self.table.getPlayerInfo(1)
        self.failUnlessSubstring("MockServicePlayerInfo", d.name)
    # -------------------------------------------------------------------
    def test20_quitting(self):
        p = self.createPlayer(1)
        self.assertEquals(True, self.table.quitPlayer(p, 1))
        p = self.createPlayer(2, False, clientClass=MockClientWithTableDict)
        self.assertEqual(True, self.table.joinPlayer(p, 2))
        p.tables[self.table.game.id] = self.table
        self.assertEquals(True, self.table.quitPlayer(p, 2))
        # Special test: player 9's removePlayer always fails
        p = self.createPlayer(9)
        self.assertEquals(True, self.table.quitPlayer(p, 9))
    # -------------------------------------------------------------------
    def test20altForNewClientAPI_quitting(self):
        # This is disabled until the API changes
        return True

        p = self.createPlayer(1)
        self.assertEquals(True, self.table.quitPlayer(p, 1))
        p = self.createPlayer(2, False, clientClass=MockClientWithRemoveTable)
        self.assertEqual(True, self.table.joinPlayer(p, 2))
        self.assertEquals(True, self.table.quitPlayer(p, 2))
    # -------------------------------------------------------------------
    def test21_syncDatabase(self):
        """Test syncing the Database back to the MockService"""
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
            self.table.readyToPlay(ii)
        self.service.testObject = self
        self.table.game.turn_history = self.service.loadHand(randint(777, 8975))
#        self.table.syncDatabase()
#        self.table.tourneyEndTurn()
        self.table.update()
        return player[4].waitFor(PACKET_POKER_TIMEOUT_NOTICE)

#        return defer.DeferredList(l)

#         reactor.iterate()
#         pending = reactor.getDelayedCalls()
#         if pending:
#             for p in pending:
#                 if p.active():
#                     print "still pending:" + str(p)
#                     p.cancel()

    # -------------------------------------------------------------------
    def test22_possibleObserverLoggedIn(self):
        """Test possibleObserverLoggedIn"""
        p = self.createPlayer(1)
        self.table.disconnectPlayer(p, 1)
        p2 = self.createPlayer(2)
        # Player 1 is already at the table, so this should be meaningless:
        self.table.possibleObserverLoggedIn(p, 1)
        # Player 2's object has been "lost", s owe created
        p2_reconnected = self.createPlayer(3, getReadyToPlay=False) 
        self.table.joinPlayer(p2_reconnected, 3)
        self.table.possibleObserverLoggedIn(p2_reconnected, 2)
    # -------------------------------------------------------------------
    def test23_broadcastingPlayerCards(self):
        """Test to make sure PokerPlayerCards are broadcasted correctly.  This
        test is not particularly good, in my view, because it was written
        to target certain lines in private2public directly and may not
        actually be an adequate test of actual functionality."""
        p = self.createPlayer(1)
        p2 = self.createPlayer(2)
        c1 = PokerCards([ 'As', 'Ah' ])
        c1.allHidden()
        self.table.game.getPlayer(2).hand.set(c1)
        self.table.broadcast([ PacketPokerPlayerCards(game_id = self.table.game.id, serial = 2,
                                                      cards = self.table.game.getPlayer(2).hand.toRawList())])
        def checkReturnPacketBySerial(packet, serial):
            self.assertEqual(packet.serial, 2)
            if serial == 2:
                hand_expected = [243, 204]
            else:
                hand_expected = [255, 255]
            self.assertEqual(packet.cards, hand_expected)
            self.assertEqual(packet.game_id, self.table1_value)
        
        checkReturnPacketBySerial(p.lookForPacket(PACKET_POKER_PLAYER_CARDS), 1)
        checkReturnPacketBySerial(p2.lookForPacket(PACKET_POKER_PLAYER_CARDS), 2)
    # -------------------------------------------------------------------
    def test24_treeFallingInWoodsWithNoPlayerToHearIt(self):
        """Test a broadcast message that no one is here to hear"""
        self.assertEqual(False, self.table.broadcastMessage(PacketPokerGameMessage, "Tommy, can you hear me?"))
    # -------------------------------------------------------------------
    def test99_destroy_table(self):
        """Test table destruction"""
        p1 = self.createPlayer(1, clientClass=MockClientWithTableDict)
        d = p1.waitFor(PACKET_POKER_TABLE_DESTROY)
        self.table.destroy()
        return d
    # -------------------------------------------------------------------
    def test99altForNewClientAPI_destroy_table(self):
        """Test table destruction once the client API has a removeTable method
           This is currently turned off because the change has not been made.
           See the FIXME around line 117 of pokertable.py in pokertable.destroy
        """
        # This is disabled until the API changes
        return True
        p1 = self.createPlayer(1, clientClass=MockClientWithRemoveTable)
        d = p1.waitFor(PACKET_POKER_TABLE_DESTROY)
        self.table.destroy()
        return d
# -------------------------------------------------------------------

# I seriously considered not having *all* the same tests run with
# predifined decks because it was not needed to get coverage.  A simple
# setup test would have worked.  However, I think it's good leaving it
# this way because if predifined decks are later used extensively, we
# would want all the tests to run and when additional use of predefined
# decks is added.  -- bkuhn, 2008-01-21

class PokerTableTestCaseWithPredefinedDecks(PokerTableTestCase):
    def setUp(self, settingsXmlStr=settings_stripped_deck_xml):
        PokerTableTestCase.setUp(self, settingsXmlStr)

# -------------------------------------------------------------------

# This class tests the same operations as PokerTableTestCase but for tables that
#  are transient.  Note the outcome of various operations are quite different
#  when the table is transient.
class PokerTableTestCaseTransient(PokerTableTestCase):
    def setUp(self, settingsXmlStr=settings_xml):
        global table1ID
        global table2ID
        table1ID = table1ID + 1
        table2ID += 1
        self.table1_value = table1ID
        self.table2_value = table2ID

        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settingsXmlStr, len(settingsXmlStr))
        settings.header = settings.doc.xpathNewContext()
        self.service = MockService(settings)
        self.table = pokertable.PokerTable(self.service, table1ID, 
                                           { 'name': "table1",
                                             'variant': "holdem",
                                             'betting_structure': "2-4-limit",
                                             'seats': 4,
                                             'player_timeout' : 6, 
                                             'muck_timeout' : 1,
                                             'transient' : True,
                                             'tourney' : 'My Old Sit and Go',
                                             'currency_serial': 0
                                             })
        self.table2 = pokertable.PokerTable(self.service, table2ID, 
                                           { 'name': "table2",
                                             'variant': "holdem",
                                             'betting_structure': "2-4-limit",
                                             'seats': 4,
                                             'player_timeout' : 6, 
                                             'muck_timeout' : 1,
                                             'transient' : True,
                                             'tourney' : 'My Old Sit and Go',
                                             'currency_serial': 0
                                             })
        self.service.table1 = self.table
        self.service.table2 = self.table2
        self.clients = {}

    def createPlayer(self, serial, getReadyToPlay=True, clientClass=MockClient, table=None):
        if table == None:
            table = self.table
        client = clientClass(serial)
        self.clients[serial] = client
        table.joinPlayer(client, serial)
        if getReadyToPlay:
            self.assertEqual(True, table.seatPlayer(client, serial, -1))
            table.sitPlayer(client, serial)
        return client

    # -------------------------------------------------------------------
    def test01_autodeal(self):
        """ Transient tables hand deal has a minimum duration if all players are in auto mode """
        self.createPlayer(1)
        self.table.game.autoPlayer(1)
        self.createPlayer(2)
        self.table.game.autoPlayer(2)
        self.table.game_delay["start"] = time.time()
        self.table.scheduleAutoDeal()
        return self.clients[2].waitFor(PACKET_POKER_MESSAGE)
    # -------------------------------------------------------------------
    def test02_autodeal_check(self):
        self.createPlayer(1)
        self.table.processingHand(1)
        self.table.game_delay["delay"] = 2
        self.table.game_delay["start"] = time.time()
        self.createPlayer(2)
        self.table.scheduleAutoDeal()
        return self.clients[2].waitFor(PACKET_POKER_MESSAGE)
    # -------------------------------------------------------------------
    def test04_autodeal_transient_now(self):
        """ Transient tables hand deal has no minium duration if all players are in auto mode but the hand lasted more than the required minium """
        self.createPlayer(1)
        self.table.game.autoPlayer(1)
        self.createPlayer(2)
        self.table.game.autoPlayer(2)
        self.table.game_delay["start"] = time.time() - 300
        self.table.scheduleAutoDeal()
        self.clients[2].raiseIfPacket(PACKET_POKER_MESSAGE)
        return self.clients[2].waitFor(PACKET_POKER_START)
    # -------------------------------------------------------------------
    def test05_autodeal_transient_normal(self):
        """ Transient tables hand deal normaly if at least one player is not in auto mode """
        self.createPlayer(1)
        self.createPlayer(2)
        self.table.scheduleAutoDeal()
        self.clients[2].raiseIfPacket(PACKET_POKER_MESSAGE)
        return self.clients[2].waitFor(PACKET_POKER_START)

    def test08_player_has_trouble_joining(self):
        """Test for when the table is full and a player is trying hard to join"""
        # Do not use serials of 0's here -- pokerengine will hate that. :)
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
        player[5] = self.createPlayer(5, False)

        # player5 can't sit because the table is full of 1-4...
        self.assertEqual(False, self.table.seatPlayer(player[5], 5, -1))

        #  ... but player5 decides to set all sorts of things that she can't
        #      because she's still just an observer.
        self.assertEqual(False, self.table.muckAccept(player[5], 5))
        self.assertEqual(False, self.table.muckDeny(player[5], 5))
        self.assertEqual(False, self.table.autoBlindAnte(player[5], 5, True))
        self.assertEqual(False, self.table.rebuyPlayerRequest(player[5], 30))

        # player5 cannot sit out either because she isn't joined yet.
        self.assertEqual(False, self.table.sitOutPlayer(player[5], 5))

        # player1 leaves on his own...
        self.assertEqual(True, self.table.leavePlayer(player[1], 1))

        # ... which allows player5 to finally join legitimately and change
        # her settings.  However, she tries to sit out before getting the
        # seat, rebuy before even buying, and then buys in for nothing,
        # and thus must rebuy

        self.assertEqual(True, self.table.seatPlayer(player[5], 5, -1))
        self.assertEqual(False, self.table.rebuyPlayerRequest(player[5], 2))

        # this table is transient, so no one can buy in.
        self.assertEqual(False, self.table.buyInPlayer(player[5], 0))

        # I wonder if these should really return True rather than None?  -- bkuhn
        self.assertEqual(None, self.table.muckAccept(player[5], 5))
        self.assertEqual(None, self.table.muckDeny(player[5], 5))
        self.assertEqual(None, self.table.autoBlindAnte(player[5], 5, True))

        self.assertEqual(False, self.table.rebuyPlayerRequest(player[5], \
                                              self.table.game.maxBuyIn()))

        # player2 tries to rebuy but is already at the max, and besides,
        # in transient mode, this doesn't work anyway

        self.assertEqual(False, self.table.rebuyPlayerRequest(player[2], 1))
# -------------------------------------------------------------------
def Run():
    seed(time.time())
    loader = runner.TestLoader()
#    loader.methodPrefix = "test24"
    os.environ['VERBOSE_T'] = '4'
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerTableTestCase))
    suite.addTest(loader.loadClass(PokerTableTestCaseWithPredefinedDecks))
    suite.addTest(loader.loadClass(PokerTableTestCaseTransient))
    return runner.TrialRunner(reporter.VerboseTextReporter,
#                              tracebackFormat='verbose',
                              tracebackFormat='default',
                              ).run(suite)
# ------------------------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokertable.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokertable.py' TESTS='coverage-reset test-pokertable.py coverage-report' check )"
# End:




